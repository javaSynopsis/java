писать в папке проекта, инициализирует создавая служебные файлы
git init

закачивает с репозитория в католог mygrit
git clone git://github.com/schacon/grit.git mygrit

############### ДОБАВЛЕНИЕ ФАЙЛОВ
добавление на контроль, индексирование, если не выполнить эту команду для фалов после изменения еще раз, то в комит они не войдут (но можно использовать commit -a чтобы не добавлять повторно, написано ниже)
git add
пример:
git add *.c
git add README
$ git add README test.rb LICENSE

статус репозитория, ветка и комиты, список отслеживаемых фалов, список измененных фалов
git status

############### РАЗЛИЧИЯ В ФАЙЛАХ
более точное сравнение изменений, показывает что конкретно поменялось, а не только список измененных файлов
git diff

индексирование, то что войдет в последний коммит
git diff --cached
(команда git diff --staged аналог этой)

############### КОМИТЫ
комит, по умолчанию выполнение открывает текстовый редактор системы
(текстовый редактор устанавливается git config --global core.editor emacs)
по умолчанию комит содержит закомментированный вывод команды, можно оставить то что есть или написать свое
git commit

с аргуметом добавляет в то что выше еще и вывод команды git diff
git commit -v

можно и так написать примечание к комиту, после -m
git commit -m "Story 182: Fix benchmarks for speed"

комманда -a индексирует перед коммитом (аналог повторного add для уже добавленных на контроль)
уже добавленные командой add файлы и тогда их не нужно добавлять коммандой add повторно
git commit -a -m 'added new benchmarks'

меняем сообщение последнего commit, если случайно отправили не то
git commit --amend -m "New commit message"

############### ФАЙЛ .gitignore И ПРИМЕР GLOB ШАБЛОНОВ
файл .gitignore - игнорируемые файлы, если добавляется группа файлов коммандой add, то описанные в этом файле не добавляются с остальной группой
Пример:
*.[oa]
*~
1 строка - игнорит файлы оканчивающиеся на .o или .a
2 - оканчивающиеся на тильду
К шаблонам в файле .gitignore применяются следующие правила:
    Пустые строки, а также строки, начинающиеся с #, игнорируются.
    Можно использовать стандартные glob шаблоны.
    Можно заканчивать шаблон символом слэша (/) для указания каталога.
    Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.
---
Glob-шаблоны представляют собой упрощённые регулярные выражения используемые командными интерпретаторами. Символ * соответствует 0 или более символам; последовательность [abc] — любому символу из указанных в скобках (в данном примере a, b или c); знак вопроса (?) соответствует одному символу; [0-9] соответствует любому символу из интервала (в данном случае от 0 до 9).
---
пример файла .gitignore
---
# комментарий — эта строка игнорируется
# не обрабатывать файлы, имя которых заканчивается на .a
*.a
# НО отслеживать файл lib.a, несмотря на то, что мы игнорируем все .a файлы с помощью предыдущего правила
!lib.a
# игнорировать только файл TODO находящийся в корневом каталоге, не относится к файлам вида subdir/TODO
/TODO
# игнорировать все файлы в каталоге build/
build/
# игнорировать doc/notes.txt, но не doc/server/arch.txt
doc/*.txt
# игнорировать все .txt файлы в каталоге doc/
doc/**/*.txt
---

###############УДАЛЕНИЕ ФАЙЛОВ ИЗ Git
удаляем файл
rm grit.gemspec
добавляем удаленный файл в индекс
git rm grit.gemspec
после коммита файл исчезнет и не будет отслеживаться
если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра -f.

то удалить файл из индекса, оставив его при этом в рабочем каталоге
git rm --cached readme.txt

В команду git rm можно передавать файлы, каталоги или glob-шаблоны.
$ git rm log/\*.log

###############ПЕРЕИМЕНОВАНИЕ ФАЙЛОВ
переименование фалов
git mv file_from file_to
эквивалентно
$ mv README.txt README
$ git rm README.txt
$ git add README

###############ПРОСМОТР LOG ИЗМЕНЕНИЙ
просмотр истории коммитов
git log

-p показывать различия файлов diff
-2 показать две последние записи
git log -p -2

просмотр изменения файлов на уровне слов, а не строк.
-U1 сократить обычные три строки контекста в выводе команды diff
Добавленное слово заключено в {+ +}, а удалённое в [- -]
$ git log -U1 --word-diff

краткая статистика по каждому коммиту
$ git log --stat

выводить комиты в 1 строку
git log --pretty=oneline
меняя oneline на short, full, и fuller можно выводить больше или меньше параметров

свой формат вывода лога
$ git log --pretty=format:"%h - %an, %ar : %s"
----
Параметр 	Описание выводимых данных
%H 	Хеш коммита
%h 	Сокращённый хеш коммита
%T 	Хеш дерева
%t 	Сокращённый хеш дерева
%P 	Хеши родительских коммитов
%p 	Сокращённые хеши родительских коммитов
%an 	Имя автора
%ae 	Электронная почта автора
%ad 	Дата автора (формат соответствует параметру --date=)
%ar 	Дата автора, относительная (пр. "2 мес. назад")
%cn 	Имя коммитера
%ce 	Электронная почта коммитера
%cd 	Дата коммитера
%cr 	Дата коммитера, относительная
%s 	Комментарий
----

--graph добавляет графф слияния к логу
git log --pretty=format:"%h %s" --graph

###############ПАРАМЕТРЫ Git
установка параметров git
git config
настройки в файле /etc/gitconfig для всех пользователей системы
(параметр к команде --system)
~/.gitconfig в папке пользователя только для конкретного
(параметр к команде --global)
настройки system перекрывают настройки system (имеют высший приоритет)

установка имени и адреса пользователя
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com

установка текстового редактора
git config --global core.editor emacs (команда или путь?)

добавление утилиты сторонней сравнения
git config --global merge.tool vimdiff

список настроек
могут быть повторы названий потому что одинаковые названия у опций системных и пользовательских
git config --list

просмотр конкретной настройки
git config user.name

открытие help в git
$ git help <команда>
$ git <команда> --help
$ man git-<команда>
например: $ git help config

ПРОБЛЕМА КОДИРОВКИ
Also, for users of Unix/Mac:
Run:

git config --global core.autocrlf input
git config --global core.safecrlf true

For Windows users:
Run:

git config --global core.autocrlf true
git config --global core.safecrlf true

###############ОТКАТ

Замена коммента последнего комита, отправляется последний сделанный комит только с измененным комментом
На практике: в IDE перед commit можно отметить amend и тогда отправленное заменит текущий commit (т.е. id у commit будет то же)
Это нужно потому что некоторые системы позволяют обновить pull request только если их id совпало, иначе создастся новый (например так в gerrit)
$ git commit --amend

Исключение из индекса после добавления коммандой add
git reset HEAD benchmarks.rb

отмена изменений файла
$ git checkout -- benchmarks.rb

отмена коммита с заданным хэшем
$ git commit -a
$ git revert 1b6d

восстановить состояние до указанного и отменить все следующие коммиты
git reset --hard 766f

сбросить последние 12 комитов
git reset --hard HEAD~12

Можно также восстановить только определенные файлы и подкаталоги, перечислив их имена после команды:
$ git checkout 82f5 какой-то.файл другой.файл
восстановление состояния файлов из коммита 82f5

Быстро перескочить к старому состоянию. В этом случае наберите
$ git checkout 82f5
затем переключиться на другую ветку и commit, место с которого перепрыгнули сохранится
можно вернуться

"master~2" - состояние второе с конца ветки мастер
"HEAD~2" - второе с головы
"@{yesterday}" - вчерашнее
$ git whatchanged --since="2 weeks ago" - 2 недели назад

при слиянии веток текущая HEAD становится первым родителем, другим назначается номер
HEAD^2 - второй родитель
HEAD^ - первый

можно сочетать
$ git checkout 1b6d^^2~10 -b ancient
создаст новую ветку «ancient» («древняя», прим. пер.), отражающую состояние на десять коммитов назад от второго родителя первого родителя коммита, начинающегося с 1b6d.

типы reset: soft, mixed, hard

###############ВРЕМЕННЫЕ ВЕТКИ
во всех командах git stash если не указан commit, то действие на последний

git stach
создаём временный тайник текущего состояния
теперь можно делать разные изменения

git stash apply
возвращаемся в состояние тайника (только файлы, но не в индексе, не в git?)

git stash list
список тайников

git stash show -p stash@{0} | git apply -R
Откат применения спрятанных изменений

git stash apply --index
возвращаемся в состояние тайника (в том числе в индекс, в git?)

git stash branch testchanges
создаст новую ветку с началом из того коммита, на котором вы находились во время прятанья
(чтобы слить ее с текущей после изменений, чтобы не было конфликта)

###############РАБОТА С РЕПОЗИТОРИЯМИ

просмотр настроенных репозиториев
git remote

просмотр сокращенных имен для url
$ git remote -v
origin  git://github.com/schacon/ticgit.git (fetch)
origin  git://github.com/schacon/ticgit.git (push)

добавление репозиторий с именем pb
$ git remote add pb git://github.com/paulboone/ticgit.git
при добавлении сокращенного имени его можно использовать вместо url

загрузка из репозитория
$ git fetch pb
слитая из репа ветка master доступна как pb/master

отправка проекта на сервер в ветку master
$ git push origin master
если при первом запуске проблемы выполнить git push --set-upstream origin master
(где origin - сервер, master - ветка)

дополнительная инфа о репозитории
$ git remote show origin

переименование репозитория из pb в paul
$ git remote rename pb paul
имена веток также поменялись pb/master стало paul/master

удалить репозиторий
$ git remote rm paul

(pull vs fetch) сливает из удаленной ветки в вашу текущую ветку
(кроме этого командой git fetch загружается список веток с сервера)
git pull
pull это просто fetch, а затем merge

###############ВЕТКИ
Каждый комит содержит указать на свое дерево.
Дерево содержит указатель на список измненений каждого файла (каждое изменение - ветка)

Ветка - подвижный указатель на один из коммитов, указывает на последний коммит. При  новом комите сдвигается на новый.

HEAD указывает на текущую ветку которая при коммитах движется вперед (переключаться git checkout)

создание ветки testing
$ git branch testing

создание и сразу переход на ветку
git checkout -b style

переключение на ветку
git checkout testing

                   testing
                     |
-----    -----     -----
|   |---|     |---|     |
-----    -----     -----
           |
         master
           |
          HEAD
		  
сливает текущую ветку с веткой hotfix
$ git merge hotfix

удаление ветки
$ git branch -d hotfix

список веток
git branch

последний коммт каждой ветки
$ git branch -v

ветки которые слили с текущей
$ git branch --merged

ветки которые НЕ слили с текущей
$ git branch --no-merged

взять все изменения, которые попали в коммиты на одной из веток, и повторить их на другой.
git rebase master

Удаление веток на удалённом сервере (пробел ниже важен?)
$ git push origin :serverfix

-d -m - удаляют и перемещают ветки

############### rebase

rebase - взять все изменения, которые попали в коммиты на одной из веток, и повторить их на другой.
Вообще команда rebase может менять историю commits, может разбить историю на 2 репозитория и т.д.

склеить последние commits (перезаписав историю):
    git rebase -i HEAD~3
    
Также может объединять ветки перенося commits (как альтернатива merge, см. стратегии merge)

взять все изменения, которые попали в коммиты на одной из веток, и повторить их на другой.
git rebase master

Команда:
    git pull --rebase
Это аналог команды:
    git fetch
    git rebase origin/master
############### cherry-pick

git cherry-pick - берет отдельный commit (даже из другой ветки) и применяет его на текущей
git rebase — это "автоматизированный" cherry-pick, делает тоже, но не с 1им commit, а с цепочкой.
git revert — противоположность git cherry-pick, создает commit отменяющий отдельный commit

############### Стратегии merge

Оформленную статью про merge можно почитать тут: https://habr.com/post/195674/

Стратегию для merge можно выбрать так:
    git merge -s ours obsolete

3-way merge algorithm - используется для resolve, recursive; только меняются вариации. Вообще этот алгоритм универсальный для слияния 2х наследников от общего предка.
    Как работает:
    1. поиск общего предка,
    2. поиск блоков, изменившихся в обеих версиях относительно общего предка,
    3. записываются блоки, оставшиеся без изменения,
    4. блоки, изменившиеся только в одном из потомков, записываются как измененные,
    5. блоки, изменившиеся в обеих версиях, записываются только если изменения идентичны, в ином случае объявляется конфликт, разрешение которого предоставляется пользователю.

true merge - это  понятие означает обычное слияние от 2х предков.
    
resolve - Нужно использовать для 2х веток, если у них не более 1го общих ветки-предка.

recursive (по умолчанию) - еще называют non-fast-forward merge. Нужно использовать для 2х веток, если у них более 1го общих ветки-предка.
    ours - принять в случае конфликта свои правки
    theirs - принять в случае конфликта их правки
    
    Не основные опции:
    1. subtree[=<path>] - Выполнение рекурсивного слияния с этой опцией будет более продвинутым вариантом стратегии subtree, где алгоритм основывается на предположении, как деревья должны совместиться при слиянии. Вместо этого в этом случае указывается конкретный вариант.
    2. patience - делать merge медленно, но более качественно разрешать конфликты
    3. renormalize (no-renormalize) - Предотвращает ложные конфликты при слиянии вариантов с разными типами перевода строк.
    4. diff-algorithm=[patience|minimal|histogram|myers] - различные алгоритмы diff, которые помогают обойти ошибки merge незначительных строк кода (напр. скобок)
    и еще много др. опций
        1. default, myers — стандартный, жадный алгоритм. Он используется по умолчанию.
        2. minimal — производится поиск минимальнейших изменений, что занимает дополнительное время.
        3. patience — использовать алгоритм «patience diff». О нем можно почитать у автора алгоритма, либо в сокращенном варианте на SO.
        4. histogram — расширяет алгоритм patience с целью, описанной как «support low-occurrence common elements». Сказать честно, я не смог найти достаточно ясного ответа на 5. вопрос, какие конкретно случаи подразумеваются и буду очень рад, если кто-нибудь поможет найти этот ответ.
    5. rename-threshold=<n> - Данная опция задает порог, по достижении которого файл может считаться не новым, а переименованным файлом, которого git-diff не досчитался. Например, -Xrename-threshold=90% подразумевает, что переименованным считается файл, который содержит от 90% контента некоторого удаленного файла.
    6. gnore-space-change, ignore-all-space, ignore-space-at-eol - названия говорят за себя
    
resolve vs recursive - recursive стратегия решает проблемы стратегии resolve. Она так же реализует трехстороннее слияние, но в качестве предка используется не реальный, а «виртуальный» предок, который конструируется по следующему условному алгоритму:
    1. проводится поиск всех кандидатов на общего предка,
    2. по цепочке проводится слияние кандидатов, в результате чего появляется новый «виртуальный» предок, причем более свежие коммиты имеют более высокий приоритет, что позволяет избежать повторного проявления конфликтов.
В отличии от recursive стратегия resolve выбирает basis случайно (то есть ветку в которую слить другую ветку?). Т.к. пользователи часто работают с разными кусками кода, то этот алгоритм как правило работает нормально (потому что изменения не пересекаются).
    
ours - не делает merge, фактически merge только отображается в истории, чтобы эту историю обновить. Например для merge старой ветки от которой нужна только история.

octopus - выбирается автоматически в случае merge нескольких веток
(линии слияния веток на графике в 1у точку выглядят как ноги осьминога)
    git merge branch1 branch2 branch3

subtree - делает merge совершенно другого под-проекта в текущий проект сливая его git с текущим

Основные (хотя rebase не совсем стратегия, скорее альтернатива merge):
1. rebase еще называют fast-forward merge. История в этом случае чистая, т.к. commits переносятся на новую ветку как если бы они были сделаны на ней. И сам график слияния - прямая линия, как буд-то слияния не было.
2. recursive еще называют non-fast-forward merge (команда -no-ff). Эта стратегия по умолчанию, делает слияние двух ветвей с записью в истории о слиянии. На самом графике инфы о commits не будет, только инфа о слиянии с веткой. График - рисунок слияния.
Note: Многие разработчики предпочитают rebase вместо merge, потому что там чистая история.

Важно:
    Значимы только ours и subtree стратегии. Остальные стратегии выбирает git сам автоматически.
    В некоторых случаях может понадобиться resolve

############### Прерывание merge и rebase (когда ветка уже вошла в эти режимы)
Прерываем merge или rebase, без прерывания этих состояний, например, rebase не исчезает даже при git reset
Т.е. если операции merge и rebase начались, то их нужно или закончить, или прервать этими командами.
В ide появляется специальная кнопка для этого.

git merge --abort
git rebase --abort

############### git rerere

git rerere (reuse recorded resolution) - запоминает разрешения конфликтов для ФАЙЛОВ, если включен (например при git rebase). Если конфликт будет повторным, то разрешит конфликт также как это было до этого автоматически.

включение
git config --global rerere.enabled true

############### Squashing a commit

Squashing a commit - объединить несколько коммитов в 1. Есть несколько форм подходящих под это название.

Склеить 3 последние commits в 1ин.
(Рекомендуется не отправлять сначала несклеенные, потом склеенные варианты, чтобы не путать людей.)
git rebase -i HEAD~3

Возьмет все commits в ветке bugfix, сожмет в 1ин commit и сделает merge
git merge --squash bugfix
git commit

Важно: git merge --squash bugfix не делает commit сам, например на случай если commits недоделаны.
Аналог, сливает 2 ветки, но не делает commit:
    git merge feature --no-commit

Можно делать merge --squash не только для ветки:
git merge --squash HEAD@{1}

############### ПАТЧ
Различие между определенной версией и версией, сделанной 2 коммита назад:
$ git diff 1b6d "master~2" > test.patch
комманда diff просто создаёт раличие файлов

Создание патча с сохранением автора, подписи между текущей точко и указанным комитом
$ git format-patch 1b6d > test.patch

Вы также можете указать диапазон коммитов создаваемого патча:
$ git format-patch 1b6d..HEAD^^

для применения патча созданного diff
$ git apply < мой.patch

для применения созданного с format-patch (с данными автора)
$ git am < email.txt
как видно патч можно сохранить в текстовый файл

тест патча до его пременения
git apply --check fix_empty_poster.patch

############### fast forward

По умолчанию если merge не содержит изменений (если ветка с который делается merge пуста) будет применен fast forward
fast forward - это просто перемещение указателя с одной ветки на другую вместо merge. Оно не будет отмечено как слияние и не прорисуется на диаграмме как слияние.
(инфа о слиянии не сохранится)

Можно принудительно отключить fast forward чтобы видеть слияние пустой ветки с текущей
git merge -no-ff branch1/branch2

--ff-only - applies the remote changes only if they can be fast-forwarded
Команда:
    git fetch
    git merge --ff-only origin/master
Это аналог команды выше:
    git pull --ff-only
    
############### git LFS

Large File Storage (LFS) - заменяет большие файлы в git точнее указатели на них (как в файловой системе). Т.е. позволяет хранить в git большие файлы.

############### git prune

Удаляет все недостежимые объекты из git (чистит)

############### Gitflow

Это просто разделение проекта по веткам, каждая ветка имеет свое назначение.

По шагам:
1. Создается репозиторий
2. Репозиторий инициализируется
3. Начинается работа на ветке develop
4. Возникает необходимость опробовать новую штуку – создается feature-ветка и делаются коммиты
5. Закончив работу на feature-ветке, вы сливаете ее с develop
6. Если вы довольны текущей версией, но хотите продолжить работу, создается ветка release, куда перемещается текущая версия. Правка багов будет происходить на этой же ветке.
7. Когда с веткой release покончено, время слить ее в master и продолжить работу с develop
8. Кроме того, этот момент можно отметить на master-ветке

На практике:
1. Создаем ветку (например bugfix/mybug-123)
2. В UI например gitlab добавить свою ветку и целевую ветку с которой она сольется.
3. gitlab (или что-то другое) вызовет запуск jenkins и прогонит тесты.
4. Ветка mybug-123 станет в режим approve в котором назначенные люди посмотрят код и потвердят, что он верен
5. После подтверждения approve разблокируется merge и можно делать merge с основной веткой.
Note. При merge принято применять squash чтобы сжать все commit в 1ин, некоторые системы смотрят на id в commit и на каждый pull request допускают только один commit (возможно это зависит от настроек)

############### Делаем squash чтобы при merge в истории отображался один наш commit в точке merge
И чтобы не было много commit по всей истории комитов за все даты когда во на ветки которая merge были сделаны commits

git checkout master         # переключаемся
git merge --squash bugfix   # сжимаем в один commit всю ветку, при этом сообщения комитов будут склеены в одно большое
git commit

Note. В программе tortoisen можно использовать Combine to one commit для squash

Из практики squash определенного числа commit
(можно сжать и 1ин commit с самим собой чтобы перезаписать текущий commit, например если изменилось имя пользователя и нужно его передобавить в commit)
git reset --hard HEAD~12	# переход на 12 комитов назад (чтобы сжать 12 комитов в 1ин)
git merge --squash HEAD@{1}	# сжимаем, число в скобках не менять
git commit					# нужно сделать commit после этого

############### смотрим сколько было коммитов по сравнению с master веткой (например чтобы указать в squash если он делается через rebase)
Число (right) нужно чтобы прописать его в squash если squash делается через rebase, а не через merge и тогда он склеет нужное число комитов ветки.

git rev-list --left-right --count master...feature/mybranchname

############### интерактивный rebase
В idea и других средах есть режим интерактивного rebase, в нем можно открыть окно где указать какие commits склеить в один или несколько
чтобы при merge или rebase в истории на ветке куда делается merge или rebase отображались только склеенные несколько commits, а не все

############### hooks
На некоторых проектах нужно клонировать репозитории специальными командами, чтобы включить hooks иначе работа с git будет некорректна
например:
	git clone "http://jone_dou@example.com/a/microservice-client" && (cd "microservice-client" && mkdir -p .git/hooks && curl -Lo `git rev-parse --git-dir`/hooks/commit-msg http://jone_dou@example.com/tools/hooks/commit-msg; chmod +x `git rev-parse --git-dir`/hooks/commit-msg)
	
############### git annotate
git annotate - показывает кто и когда сделал правку, например для каждой строки кода. В ide обычно используется UI инструмент для этого.