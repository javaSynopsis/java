Про веб в целом.

- [Аутентификация vs Авторизация](#Аутентификация-vs-Авторизация)
- [Cookies](#cookies)
- [Salt](#salt)
- [Security и все что с ней связано](#security-и-все-что-с-ней-связано)
  - [CSRF / XSRF](#csrf--xsrf)
  - [CSRF token](#csrf-token)
  - [JWT (JSON Web Token) токен](#jwt-json-web-token-токен)
  - [JWT vs CSRF token](#jwt-vs-csrf-token)
  - [Единая точка входа (Single Sign On, SSO)](#Единая-точка-входа-single-sign-on-sso)
  - [XSSI](#xssi)
  - [CSP](#csp)
  - [CORS](#cors)
  - [SOP](#sop)
- [REST](#rest)
- [XSS](#xss)
- [Про сеть](#Про-сеть)
  - [Разное](#Разное)
  - [Протокол http](#Протокол-http)
  - [Модель OSI](#Модель-osi)
- [блокирующие vs неблокирующие обработки запросов в серверах (на пример Java)](#блокирующие-vs-неблокирующие-обработки-запросов-в-серверах-на-пример-java)
- [Load balancing](#load-balancing)
- [Reverse proxy (nginx, zuul etc) и модели обработки запросов серверами](#reverse-proxy-nginx-zuul-etc-и-модели-обработки-запросов-серверами)

# Аутентификация vs Авторизация
**Аутентификация** - это проверка соответствия субъекта и того, за кого он пытается себя выдать, с помощью некой уникальной информации (отпечатки пальцев, цвет радужки, голос и тд.), в простейшем случае - с помощью имени входа и пароля.

**Авторизация** - это проверка и определение полномочий на выполнение некоторых действий (например, чтение файла /var/mail/eltsin) в соответствии с ранее выполненной аутентификацией,

# Cookies
**HttpOnly** - параметр куков, если установлен, то кука не может быть прочитана скриптом. Всегда установлен для сессии (тоже по сути куки с идентификатором). Так никто не угонит сессию, потому что она уникальна и вычисляется при каждом входе заново.

# Salt
Источник: [тут](http://www.internet-technologies.ru/articles/article_1807.html)

**Соль** - когда перед хэшированием к каждому паролю добавляется постоянная строка (число и т.д.). В результате на выходе хэширования - нестандартный хэш. Так труднее раз хэшировать украденные пароли.  
С солью длинна пароля искуственно удленняется. Так хэш не страдает от коротких паролей.

обычно ее сохраняют в базе данных пользовательских аккаунтов вместе с хеш-кодом, или как часть самой строки хеш-кода. (т.е. у каждого пароля будет своя соль, даже у одинаковых)

придумывать разные хэш алгоритмы самому - плохо

Соль не обязательно держать в секрете. Просто при использовании случайной величины для построения хеш-кода таблицы поиска, обратные таблицы поиска и радужные таблицы становятся неэффективными. Злоумышленник не узнает заранее, какая будет соль, поэтому он не может предварительно вычислить таблицу поиска или радужную таблицу.

**примеры чокнутых хеш-функций:**
```
md5(sha1(пароль))
md5(md5(соль) + md5(пароль))
sha1(sha1(пароль))
sha1(str_rot13(пароль + соль))
md5(sha1(md5(md5(пароль) + sha1(пароль)) + md5(пароль)))
Не используйте ни одну из них.
```

**Атаки по словарю** - Самый простой способ взломать хеш-код – это попробовать угадать пароль, вычисляя хеш-код для каждого предположения и проверяя, совпадает ли этот хеш-код со взламываемым.
(использует самые популярные фразу)

**Атака полным перебором** - пробует все возможные комбинации символов до заданной длины. Эти атаки требуют очень больших вычислительных затрат,

**Таблицы поиска** – это крайне эффективный метод для очень быстрого взлома большого количества хеш-кодов одного типа. Основная идея заключается в том, чтобы заранее вычислить хеш-коды паролей из словаря паролей, а затем сохранить хеш-коды и соответствующие им пароли в структуру данных типа таблица поиска.

**Радужные таблицы** – это техника, являющаяся компромиссом между временем поиска и занимаемой памятью. Они похожи на таблицы поиска, за исключением того, что они жертвуют скоростью взлома хеш-кодов, чтобы сделать таблицы поиска меньше.

# Security и все что с ней связано
## CSRF / XSRF
**CSRF / XSRF** (Cross-site request forgery) token - token отправляется одним из параметров запроса, у каждого пользователя свой используется чтобы проверить можно обрабатывать запрос на сервер (если token верный) или нет. Угроза: если CSRF token не будет, то любой сможет отсылать value для input на сервер (и др. данные)
- CSRF token может быть полем форму, частью http referer, содержаться в спец. http header
- CSRF token не передают в адресе, а только в теле запроса. Следовательно используют только для методов которые изменяют данные на сервере (POST, PUT, DELETE). Методы GET, HEAD не изменяют данные и не имеют тела запроса, для них не нужен token.

## CSRF token
token - защита от CSRF, отправляется в header или cookie, хранится в localStorage (это безопасно не смотря на некоторые статьи и видно только своему домену). Это короткоживущий объект поэтому его кража не так страшна.

Т.е. cookie позволяет определить кто вошел, но не кто отправил данные (какой именно сайт). 
Поэтому используется token для запросов изменяющих данные. (в стандартном rest это все запросы кроме get, в нестандартном rest запросы post могут работать как get)

Как:
* Сервер ставит куку: csrf-token
* клиент ставит header

Т.е. уязвимость происходит из того что **cookies отсылаются с каждым запросом.** Атакующий может создать вредоносную ссылку на ваш сайт и т.к. cookie отошлется при любом клике, то переход по ней вызовет операцию на сайте. Чтобы это предотвратить отсылается csrf-token в **http header или параметре запроса**. Альтернативно можно хранить JWT в localStorage и отсылать в http header, это защитит от csrf, но будет уязвимо к XSS.

Фреймворкти типа **Angular** имеют **встроенную** поддержку CSRF token.

**Общая техника (так работает в Angular, это техника из Angular Tutorial):**
1. сервер генерирует случайный csrf token и сетает в cookie. Эти cookies может читать только js с того же сайта из-за SOP.
2. js читает этот csrf token и сетает его в http header отправляемый к этому сайту
3. В Angular при работе с модулем http автоматически читается кука с именем `XSRF-TOKEN` и сетает значение в `X-XSRF-TOKEN`. (имена по умолчанию можно поменять)

CSRF аттака может быть предотвращена проверкой `Referer` и `Origin`, т.к. они содержат URL происхождения запроса и если он отличен от адреса сайта и разрешенных доменов, то это аттака.

```js
var rq = new XMLHttpRequest();
var csrfCookie = document.cookie.match(/csrf-token=/); // тут вырезаем куку
if(csrfCookie) rq.setRequestHeader('x-csrf-token', csrfCookie[1]);
```

## JWT (JSON Web Token) токен
jwt - это стандартизированный token, состоит из: **Header** . **Payload** . **Signature**

* **Header** - инфа о алгоритмы хэширования токена
* **Payload** - UserInfo - id, имя, роли и прочее
* **Signature** - крипто подпись, которая проходит через алгоритмы указанные в **Header**

jwt - это self contained token, т.е. его не нужно хранить на сервере в DB, он сам содержит информацию, которая подписана ключом и ее нельзя изменить т.к. подпись станет невалидной, а переподписать может только сервер приватным ключом.

JWT хранится в localStorage, его могут похитить. Поэтому он короткоживущий (short lived). Т.е. он перегенирируется скажем каждые 60 сек и старый перестанет действовать (дата истечения хранится в нем самом, как я понял).

Один из вариантов: хранить JWT вместе с CSRF в cookies с secure и httpOnly атрибутами.

```js
const token = base64urlEncoding(header) + '.' + base64urlEncoding(payload) + '.' + base64urlEncoding(signature)
```

Статья с обзором различных способов, кажется предлагается использовать cookie + доп. механизмы [тут](https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage) и [тут](https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc)

## JWT vs CSRF token

JWT можно использовать как CSRF (т.е. jwt может брать на себя роль не только авторизации, но и роль CSRF), но это сложно. CSRF в отличии от JWT не должен иметь криптографии или нести информацию.

CSRF генерируется **каждый** новый **request** и помещают в http header или в параметр запроса (post, put, patch, delete). JWT отправляется с каждым запросом.

CSRF должен быть непредсказуем для атакующего, т.е. в отличии от JWT каждый раз иметь разные значения.

CSRF token - никогда **не отправляют в cookie**.

**JWT можно отправлять в:**
1. **cookie** - это stateless вариант (видимо имеется ввиду, что front end не обрабатывает запросы)
2. **http header**
3. **в параметрах запросов**

## Единая точка входа (Single Sign On, SSO)
Источники про SSO: [тут хорошо на русском](https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc), [тут](http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/) и [тут](http://cryto.net/%7Ejoepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/) написано почему jwt для сессий это плохо, [тут на русском и понятно](https://habr.com/ru/post/422765/) и [тут](https://habr.com/ru/company/dataart/blog/311376/) и [тут](https://yourcmc.ru/wiki/%D0%9A%D1%80%D0%B0%D1%82%D0%BA%D0%BE_%D0%BE%D0%B1_SSO_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_OAuth2) и [Зачем нужен Refresh Token, если есть Access Token?](https://habr.com/ru/company/Voximplant/blog/323160/) и [What is the purpose of a “Refresh Token”?](https://stackoverflow.com/questions/38986005/what-is-the-purpose-of-a-refresh-token) и [Про токены, JSON Web Tokens (JWT), аутентификацию и авторизацию. Token-Based Authentication](https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc)

Это протоколы для доступа к ресурсам через единый вход на какой-то сервис.

**Протоколы:**
* Актуальные:
  * OAuth 2.0 - выдает токены для доступа к ресурсам
  * OpenID Attribute Exchange 1.0 - доступ к отдельным частям профиля (например к фото или email)
  * OpenID Connect - объединяет возможности OpenID 2.0, OpenID Attribute Exchange 1.0, и OAuth 2.0
* Старые:
  * OpenID
  * OAuth 1.0

## XSSI
XSSI - Cross-site script inclusion, др. название: JSON vulnerability

Эта атака работает в старых браузерах путем подмены constructors объектов js. (подробности тут: https://angular.io/guide/security#xssi )

## CSP

**Определяет** какие из потенциально опасных функций js можно запускать.

CSP - против XSS (cross site script). Для чего: чтобы запрещать: eval, inline, script src, style src, img src

CSP - запрещает внедрять в страницу inline скрипты, использовать eval(), разрешать запросы для js со страницы только к выбранным доменам.
- существуют различные методы обхода, например берем часть страницы скриптом, вставляем в тег <img src="!here!"> и в запросе GET к враждебному домену будет кусок страницы.
- можно проделывать тоже с атрибутами CSS запрашивающими данными через src свойство.

Пример настройки CSP через http headers:
```csp
Content-Security-Policy: default_src 'self'
```

Пример настройки CSP через `<meta>` (у http headers приоритет перед `<meta>`)
```html
<meta http-equiv="Content-Security-Policy" content="default_src 'self'">
```

## CORS
CORS - cross origin resource sharing

**Определяет** какие запросы и к каким сайтам можно делать. CORS - это "ослабленный" SOP, который разрешает некоторые запрос к некоторым другим сайтам.

```
Access-Control-Allow-Origin: www.bla.com
```

## SOP
SOP - (Single origin policy)

# REST
**REST** - Representational State Transfer (передачи представлений о состоянии) - это архитектурный подход.
**RESTful** - называют сервисы (или что-то другое), что следует архитектуре REST.

* **URL** - Uniform Resource Locator, подмножество URI
* **URI** - Uniform Resource Identifiers

**verb** - part of a URL path  
**Идемпотентный метод** - может изменять или не изменять состояние ресурса, но повторные запросы, следующие за первым, не должны оказывать влияния на состояние ресурса  
**безопасный метод** -  не изменяет состояние ресурса

**типы запросов:**
```
GET - получение
POST - добавление
PUT - обновление
PATCH - как put, но применяется к части ресурса
DELETE - удаление
OPTIONS - возвращает параметры сервера или соединения
HEAD - как get, но в ответе только headers без body
TRACE - возвращает отправленное body назад
CONNECT - тунелирует соединение в удаленный ip, используется для цепочки прокси
```

**Http запрос состоит из:**
1. Http header
2. Http body

**http статусы:**
```
1xx - informational
2xx - Success
3xx - Redirection
4xx - Client Error
5xx - Server Error
```
    
Пример массива в get (с одинаковыми name складываются в один параметр, возможно зависит от настроек сервера):
`/about?name=Tom&name=Bob&name=Sam`

* Параметр запроса - параметры после &: `/about&m=2`
* Параметр маршрута - часть пути: `users/12`
    
**Http header Content-Type для REST:**
 1. application/hal+json для HATEOAS (Hypermedia)
 2. или application/json для чистого REST
    
**Некоторые headers из http:**
* Accept: text/plain - типы допустимых ресурсов пользователю.
* Accept-Charset: utf-8 - кодировка

**Note.** Можно сказать, что в REST вместе с запросом отправляется тип операции с ресурсом (GET/POST/etc тип запроса, или строки "port"/"get"/etc в одном из полей запроса в виде текста или еще как-то).

**Note:** есть подход при котором используется только POST запросы, а описание операции (create, read, update, delete) передаются внутри запроса.
Это плохая практика и в некоторых статьях названа антипаттерном.

При https шифруются и POST, и GET, но POST обычно не логируется на сервере, НО это зависит от настроек сервера.  
Для GET (как и для других запросов) шифруется весь запрос в том числе и URL, т.к. шифрование происходит вообще до создания запроса.  
POST может использоваться там, где не нужно показывать данные в адресной строке, например пароля.

GET запрос обычно имеет ограниченный размер который меньше чем у других типов запросов, но это настраивается на сервере.

**Поисковой запрос REST** на сервер или любой запрос с большим количеством параметров:  
Его нужно делать не в GET, а в POST не смотря на то, что это отход от стандартов.
Потому что GET имеет ограничение на длину.
При этом современные front-end фреймворки могут отображать в адресной строке браузера любой url, поэтому это не так критично.

**HATEOAS** (Hypermedia as the Engine of Application State) - когда передается список связанных сущностей в отдельном свойстве. Точнее ссылки на них по которым их можно получить (в Spring модуль HAL)

Браузеры преобразовывают значение атрибута http-equiv, заданное с помощью content, в формат заголовка ответа HTTP и обрабатывают их, как будто они прибыли непосредственно от сервера.
```html
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="expires" content="Sun, 01 Jan 2013 07:01:00 GMT">
```

**Один из подходов отправки запроса REST (интерпританции пустого массива и неотправки поля вообще):**
1) пустой массив отправленный с клиента на сервер затирает уже имеющиеся данные (т.е. если этот массив представляет коллекцию вложенную в Entity, то отправленный пустой массив очистит коллекцию)
2) null отправленный с клиента на сервер ничего не делает, это при неуказании поля в json вообще (т.е. диссериализатор из json в Object если поле не отправлено представит его как null, и если мы получаем null, то мы не очищаем поле, а вообще с ним ничего не делаем т.к. в запросе его не было)

**Описание:**
1. какое-то поле не указано при создании, то оно напр. пустой массив (если оно null)
2. какое-то поле не указано при обновлении, то ничего с ним не делать (если оно null)
3. если при обновлении поле пустой массив, то заменить им то что уже есть (и вообще заменять содержимым этого массива то что уже есть)

Почему работает так: парсеры преобразующие json в object, например jackson в Java, интерпретируют его как null.

# XSS
**XSS** - это когда вставленный в ссылку или текстовое поле javascript встраивается в страницу и может выполнится от лица пользователя (кликнувшего по ссылке со скриптом или зашедшего на страницу если скрипт добавлен сообщением и весит там постоянно)

# Про сеть
## Разное
Note. Перенести отсюда про NAT и прочее: https://www.youtube.com/watch?v=aKMLgFVxZYk&list=PLQnljOFTspQVMeBmWI2AhxULWEeo7AaMC&index=2

* **NAT** (Network Address Translation)
* **TCP Tunneling Applications** - 
  * local port forwarding tunneling
  * reverse port forwarding tunnel

## Протокол http
Протокол IP содержи TCP и UDP

IP резервирует первые 1024 порта для протоколов

URI и его подмножество URL и URN

кэширование в http

## Модель OSI


# блокирующие vs неблокирующие обработки запросов в серверах (на пример Java)
https://dzone.com/articles/tens-of-thousands-of-socket-connections-in-java

# Load balancing
Источник: [тут](https://www.youtube.com/watch?v=aKMLgFVxZYk&list=PLQnljOFTspQVMeBmWI2AhxULWEeo7AaMC&index=2)

**Коротко:** Типы балансировки делятся на **Layer 4 balancing** и **Layer 7 balancing**. Layers тут - это уровни модели OSI и показывают что видят блокировщики на каждом уровне при передаче данных. Layer 4 это когда нагрузка балансируется между двумя или больше серверами (не сервисами, а именно машинами или копия приложения). Потому что на Layer 4 балансировщик видит только ip и port и ничего не знает о данных (например они зашифрованы), он не может кэшировать контент или фильтровать запросы (потому что не может получить доступ к данным). На Layer 7 балансировщик видит данные, может фильтровать данные или запросы, кэшировать и прочее (что делают такие reverse proxy как nginx). Layer 7 балансировщик может балансировать нагрузку между разными копиями микросервисов, но он более тяжелый потому что должен парсить данные и расшировывать соединения.

**Note.** `load balancer` еще называют **fault tolerant** (т.к. он предотвращает падения перенаправляя запросы на копию приложения или микросервиса).

**Алгоритмы балансировки:**
* **round robin** - выбирает по очереди следующий сервер или микросервис (самый частый алгоритм по умолчанию, например в nginx или zuul)

# Reverse proxy (nginx, zuul etc) и модели обработки запросов серверами
Источники: [тут](https://vps.ua/wiki/nginx/) и [тут](http://www.opennet.ru/base/net/nginx_intro.txt.html)

**reverse proxy** (обратное проксирование) - процесс, в котором сервер (reverse proxy), получающий запрос от клиента, не обрабатывает его полностью самостоятельно, а частично или целиком отправляет этот запрос для обработки другим (upstream) серверам. То есть, не перенаправляет клиента, а самостоятельно отправляет запрос и возвращает полученный ответ обратно клиенту. **reverse proxy** не генерирует контент сам. **reverse proxy** может буферизовать контент.

**Note.** можно сказать что reverse proxy нужен т.к. он быстро общается с сервером, а с медленными клиентами общается используя один поток (или несколько из пулла) вместо отдельные потоков на каждый connect.

**Note.** некоторые **reverse proxy** пока не прочитали весь request не отдают response, это может сломать некоторый функционал, например отправку прогресса при upload файла, это решается подключением дополнительных модулей к **reverse proxy** и настройкой.

**Для чего reverse proxy:** балансировки нагрузки, защита от DDoS-атак

**Модели обработки запросов серверами:**
* **Последовательная** - Сервер открывает слушающий сокет и ждет, когда появится соединение (во время ожидания он находится в заблокированном состоянии). приходит соединение, сервер обрабатывает его в том же контексте, закрывает соединение и снова ждет соединения. Медленная, не многопроцессная, в реальности почти не используется.
* **Многопроцессная** (многопоточная) - Сервер открывает слушающий сокет. Когда приходит соединение, он принимает его, после чего создает (или берет из пула заранее созданных) новый процесс или поток, который может сколь угодно долго работать с соединением, а по окончании работы завершиться или вернуться в пул. Главный поток тем временем готов принять новое соединение. Это может быть медленно, потому что поток не умирает пока не отдаст клиенты все данные даже если клиент медленный.
  * **Другими словами:** на каждое соединение порождается поток и это затратно при медленных клиентах (т.к. поток может жить долго пока клиент общается с ним)
* **Неблокируемые сокеты** / **конечный автомат** - Сервер работает в рамках одного потока, но использует неблокируемые сокеты и механизм поллинга. Т.е. сервер на каждой итерации бесконечного цикла выбирает из всех сокетов тот, что готов для приема/отправки данных. После того, как сокет выбран, сервер отправляет на него данные или читает их, но не ждет подтверждения, а переходит в начальное состояние и ждет события на другом сокете или же обрабатывает следующий, в котором событие произошло во время обработки предыдущего. Это сложнее в реализации и обработка событий должна быть быстрой.
  * **Другими словами:** обрабатывает соединения один процесс (может и несколько процессов из пулла, но процессы не создаются по одному на каждое соединение). Реализована через неблокирующий **io** (e.g. **NIO** в Java), т.е. операции обработки соединений помещаются в очередь, один и тот же процесс по определенным событиям обрабатывает одно соединение, если работы нет засыпает, а если есть переходит к другому соединению (работа напоминает работу процессора контролируемую task manager системы).

**Почему reverse proxy лучше чем (некоторые) сервера.** Потому что дешевле обрабатывать много соединений в одном процессе (или нескольких процессах из пулла и возвращать их в пулл после этого) чем порождать новый поток на каждое соединение. Т.к. медленный клиент может долго получать ответ и все это время отдельный поток живет, это затратно.  
**Note.** Возможно тут имеется ввиду, что reverse proxy хорош для серверов не реализующих хорошую модель обработки запросов.

**Про nginx.** К нему можно подключить множество модулей, которые могут обрабатывать динамический контент (e.g. передавать запрос PHP интерпретатору)

**Про Zuul.** Zuul это reverse proxy используемый с микросервисами на Java. Вместо того чтобы обращаться к каждому микросервисы отдельно обращение идет к Zuul, а уже он обращается к микросервису и отдает ответ. Чтобы не реализовывать CORS, authentication или security в каждом микросервисе эту бизнес логику можно реализовать в Zuul. Он также может добавлять разные headers, пропускать запросы через фильтры с логикой и устанавливать разные алгоритмы балансировки. Внутри он использует Netty сервер.

**reverse proxy vs load balancer** - load balancing это одна из функций, которую может выполнять reverse proxy, но reverse proxy может не только балансировать нагрузку (распределяя ее между несколькими серверами или микросервисами), но и работать как фильтр для запросов, CORS, проверять security. load balancer может быть отдельным приложением, но все что он делает только распределяет нагрузку и ничего больше их того что делает reverse proxy не делает.