Про веб в целом.

- [Аутентификация vs Авторизация](#Аутентификация-vs-Авторизация)
- [Cookies](#cookies)
- [Salt](#salt)
- [Security и все что с ней связано](#security-и-все-что-с-ней-связано)
  - [CSRF / XSRF](#csrf--xsrf)
  - [CSRF token](#csrf-token)
  - [JWT (JSON Web Token) токен](#jwt-json-web-token-токен)
  - [JWT vs CSRF token](#jwt-vs-csrf-token)
  - [Единая точка входа (Single Sign On, SSO)](#Единая-точка-входа-single-sign-on-sso)
  - [XSSI](#xssi)
  - [CSP](#csp)
  - [CORS](#cors)
  - [SOP](#sop)
- [REST](#rest)
- [XSS](#xss)
- [Протокол http](#Протокол-http)
- [Модель OSI](#Модель-osi)

# Аутентификация vs Авторизация
**Аутентификация** - это проверка соответствия субъекта и того, за кого он пытается себя выдать, с помощью некой уникальной информации (отпечатки пальцев, цвет радужки, голос и тд.), в простейшем случае - с помощью имени входа и пароля.

**Авторизация** - это проверка и определение полномочий на выполнение некоторых действий (например, чтение файла /var/mail/eltsin) в соответствии с ранее выполненной аутентификацией,

# Cookies
**HttpOnly** - параметр куков, если установлен, то кука не может быть прочитана скриптом. Всегда установлен для сессии (тоже по сути куки с идентификатором). Так никто не угонит сессию, потому что она уникальна и вычисляется при каждом входе заново.

# Salt
Источник: [тут](http://www.internet-technologies.ru/articles/article_1807.html)

**Соль** - когда перед хэшированием к каждому паролю добавляется постоянная строка (число и т.д.). В результате на выходе хэширования - нестандартный хэш. Так труднее раз хэшировать украденные пароли.  
С солью длинна пароля искуственно удленняется. Так хэш не страдает от коротких паролей.

обычно ее сохраняют в базе данных пользовательских аккаунтов вместе с хеш-кодом, или как часть самой строки хеш-кода. (т.е. у каждого пароля будет своя соль, даже у одинаковых)

придумывать разные хэш алгоритмы самому - плохо

Соль не обязательно держать в секрете. Просто при использовании случайной величины для построения хеш-кода таблицы поиска, обратные таблицы поиска и радужные таблицы становятся неэффективными. Злоумышленник не узнает заранее, какая будет соль, поэтому он не может предварительно вычислить таблицу поиска или радужную таблицу.

**примеры чокнутых хеш-функций:**
```
md5(sha1(пароль))
md5(md5(соль) + md5(пароль))
sha1(sha1(пароль))
sha1(str_rot13(пароль + соль))
md5(sha1(md5(md5(пароль) + sha1(пароль)) + md5(пароль)))
Не используйте ни одну из них.
```

**Атаки по словарю** - Самый простой способ взломать хеш-код – это попробовать угадать пароль, вычисляя хеш-код для каждого предположения и проверяя, совпадает ли этот хеш-код со взламываемым.
(использует самые популярные фразу)

**Атака полным перебором** - пробует все возможные комбинации символов до заданной длины. Эти атаки требуют очень больших вычислительных затрат,

**Таблицы поиска** – это крайне эффективный метод для очень быстрого взлома большого количества хеш-кодов одного типа. Основная идея заключается в том, чтобы заранее вычислить хеш-коды паролей из словаря паролей, а затем сохранить хеш-коды и соответствующие им пароли в структуру данных типа таблица поиска.

**Радужные таблицы** – это техника, являющаяся компромиссом между временем поиска и занимаемой памятью. Они похожи на таблицы поиска, за исключением того, что они жертвуют скоростью взлома хеш-кодов, чтобы сделать таблицы поиска меньше.

# Security и все что с ней связано
## CSRF / XSRF
**CSRF / XSRF** (Cross-site request forgery) token - token отправляется одним из параметров запроса, у каждого пользователя свой используется чтобы проверить можно обрабатывать запрос на сервер (если token верный) или нет. Угроза: если CSRF token не будет, то любой сможет отсылать value для input на сервер (и др. данные)
- CSRF token может быть полем форму, частью http referer, содержаться в спец. http header
- CSRF token не передают в адресе, а только в теле запроса. Следовательно используют только для методов которые изменяют данные на сервере (POST, PUT, DELETE). Методы GET, HEAD не изменяют данные и не имеют тела запроса, для них не нужен token.

## CSRF token
token - защита от CSRF, отправляется в header или cookie, хранится в localStorage (это безопасно не смотря на некоторые статьи и видно только своему домену). Это короткоживущий объект поэтому его кража не так страшна.

Т.е. cookie позволяет определить кто вошел, но не кто отправил данные (какой именно сайт). 
Поэтому используется token для запросов изменяющих данные. (в стандартном rest это все запросы кроме get, в нестандартном rest запросы post могут работать как get)

Как:
* Сервер ставит куку: csrf-token
* клиент ставит header

Т.е. уязвимость происходит из того что **cookies отсылаются с каждым запросом.** Атакующий может создать вредоносную ссылку на ваш сайт и т.к. cookie отошлется при любом клике, то переход по ней вызовет операцию на сайте. Чтобы это предотвратить отсылается csrf-token в **http header или параметре запроса**. Альтернативно можно хранить JWT в localStorage и отсылать в http header, это защитит от csrf, но будет уязвимо к XSS.

Фреймворкти типа **Angular** имеют **встроенную** поддержку CSRF token.

**Общая техника (так работает в Angular, это техника из Angular Tutorial):**
1. сервер генерирует случайный csrf token и сетает в cookie. Эти cookies может читать только js с того же сайта из-за SOP.
2. js читает этот csrf token и сетает его в http header отправляемый к этому сайту
3. В Angular при работе с модулем http автоматически читается кука с именем `XSRF-TOKEN` и сетает значение в `X-XSRF-TOKEN`. (имена по умолчанию можно поменять)

CSRF аттака может быть предотвращена проверкой `Referer` и `Origin`, т.к. они содержат URL происхождения запроса и если он отличен от адреса сайта и разрешенных доменов, то это аттака.

```js
var rq = new XMLHttpRequest();
var csrfCookie = document.cookie.match(/csrf-token=/); // тут вырезаем куку
if(csrfCookie) rq.setRequestHeader('x-csrf-token', csrfCookie[1]);
```

## JWT (JSON Web Token) токен
jwt - это стандартизированный token, состоит из: **Header** . **Payload** . **Signature**

* **Header** - инфа о алгоритмы хэширования токена
* **Payload** - UserInfo - id, имя, роли и прочее
* **Signature** - крипто подпись, которая проходит через алгоритмы указанные в **Header**

jwt - это self contained token, т.е. его не нужно хранить на сервере в DB, он сам содержит информацию, которая подписана ключом и ее нельзя изменить т.к. подпись станет невалидной, а переподписать может только сервер приватным ключом.

JWT хранится в localStorage, его могут похитить. Поэтому он короткоживущий (short lived). Т.е. он перегенирируется скажем каждые 60 сек и старый перестанет действовать (дата истечения хранится в нем самом, как я понял).

Один из вариантов: хранить JWT вместе с CSRF в cookies с secure и httpOnly атрибутами.

```js
const token = base64urlEncoding(header) + '.' + base64urlEncoding(payload) + '.' + base64urlEncoding(signature)
```

Статья с обзором различных способов, кажется предлагается использовать cookie + доп. механизмы [тут](https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage) и [тут](https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc)

## JWT vs CSRF token

JWT можно использовать как CSRF (т.е. jwt может брать на себя роль не только авторизации, но и роль CSRF), но это сложно. CSRF в отличии от JWT не должен иметь криптографии или нести информацию.

CSRF генерируется **каждый** новый **request** и помещают в http header или в параметр запроса (post, put, patch, delete). JWT отправляется с каждым запросом.

CSRF должен быть непредсказуем для атакующего, т.е. в отличии от JWT каждый раз иметь разные значения.

CSRF token - никогда **не отправляют в cookie**.

**JWT можно отправлять в:**
1. **cookie** - это stateless вариант (видимо имеется ввиду, что front end не обрабатывает запросы)
2. **http header**
3. **в параметрах запросов**

## Единая точка входа (Single Sign On, SSO)
Это протоколы для доступа к ресурсам через единый вход на какой-то сервис.

**Протоколы:**
* Актуальные:
  * OAuth 2.0 - выдает токены для доступа к ресурсам
  * OpenID Attribute Exchange 1.0 - доступ к отдельным частям профиля (например к фото или email)
  * OpenID Connect - объединяет возможности OpenID 2.0, OpenID Attribute Exchange 1.0, и OAuth 2.0
* Старые:
  * OpenID
  * OAuth 1.0

## XSSI
XSSI - Cross-site script inclusion, др. название: JSON vulnerability

Эта атака работает в старых браузерах путем подмены constructors объектов. (подробности тут: https://angular.io/guide/security#xssi )

## CSP

**Определяет** какие из потенциально опасных функций js можно запускать.

CSP - против XSS (cross site script). Для чего: чтобы запрещать: eval, inline, script src, style src, img src

CSP - запрещает внедрять в страницу inline скрипты, использовать eval(), разрешать запросы для js со страницы только к выбранным доменам.
- существуют различные методы обхода, например берем часть страницы скриптом, вставляем в тег <img src="!here!"> и в запросе GET к враждебному домену будет кусок страницы.
- можно проделывать тоже с атрибутами CSS запрашивающими данными через src свойство.

Пример http headers:
```csp
Content-Security-Policy: default_src 'self'
```

Эквивалет через `<meta>`
```html
<meta http-equiv="Content-Security-Policy" content="default_src 'self'">
```

## CORS
CORS - cross origin resource sharing

**Определяет** какие запросы и к каким сайтам можно делать. CORS - это "ослабленный" SOP, который разрешает некоторые запрос к некоторым другим сайтам.

```
Access-Control-Allow-Origin: www.bla.com
```

## SOP
SOP - (Single origin policy)

# REST
**REST** - Representational State Transfer (передачи представлений о состоянии) - это архитектурный подход.
**RESTful** - называют сервисы (или что-то другое), что следует архитектуре REST.

* **URL** - Uniform Resource Locator, подмножество URI
* **URI** - Uniform Resource Identifiers

**verb** - part of a URL path  
**Идемпотентный метод** - может изменять или не изменять состояние ресурса, но повторные запросы, следующие за первым, не должны оказывать влияния на состояние ресурса  
**безопасный метод** -  не изменяет состояние ресурса

**типы запросов:**
```
GET - получение
POST - добавление
PUT - обновление
PATCH - как put, но применяется к части ресурса
DELETE - удаление
OPTIONS - возвращает параметры сервера или соединения
HEAD - как get, но в ответе только headers без body
TRACE - возвращает отправленное body назад
CONNECT - тунелирует соединение в удаленный ip, используется для цепочки прокси
```

**Http запрос состоит из:**
1. Http header
2. Http body

**http статусы:**
```
1xx - informational
2xx - Success
3xx - Redirection
4xx - Client Error
5xx - Server Error
```
    
Пример массива в get (с одинаковыми name складываются в один параметр, возможно зависит от настроек сервера):
`/about?name=Tom&name=Bob&name=Sam`

* Параметр запроса - параметры после &: `/about&m=2`
* Параметр маршрута - часть пути: `users/12`
    
**Http header Content-Type для REST:**
 1. application/hal+json для HATEOAS (Hypermedia)
 2. или application/json для чистого REST
    
**Некоторые headers:**
* Accept: text/plain - типы допустимых ресурсов пользователю.
* Accept-Charset: utf-8 - кодировка

**Note:** есть подход при котором используется только POST запросы, а описание операции (create, read, update, delete) передаются внутри запроса.
Это плохая практика и в некоторых статьях названа антипаттерном.

При https шифруются и POST, и GET, но POST обычно не логируется на сервере, НО это зависит от настроек сервера.  
Для GET (как и для других запросов) шифруется весь запрос в том числе и URL, т.к. шифрование происходит вообще до создания запроса.  
POST может использоваться там, где не нужно показывать данные в адресной строке, например пароля.

GET запрос обычно имеет меньший размер, но это настраивается на сервере.

**Поисковой запрос REST** на сервер или любой запрос с большим количеством параметров:  
Его нужно делать не в GET, а в POST не смотря на то, что это отход от стандартов.
Потому что GET имеет ограничение на длину.
При этом современные front-end фреймворки могут отображать в адресной строке браузера любой url, поэтому это не так критично.

**HATEOAS** (Hypermedia as the Engine of Application State) - когда передается список связанных сущностей в отдельном свойстве. Точнее ссылки на них по которым их можно получить (в Spring модуль HAL)

Браузеры преобразовывают значение атрибута http-equiv, заданное с помощью content, в формат заголовка ответа HTTP и обрабатывают их, как будто они прибыли непосредственно от сервера.
```html
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="expires" content="Sun, 01 Jan 2013 07:01:00 GMT">
```

**Один из подходов отправки запроса REST:**
1) пустой массив отправленный с клиента на сервер затирает уже имеющиеся данные
2) null отправленный с клиента на сервер ничего не делает, это при неуказании поля в json вообще

**Описание:**
1. какое-то поле не указано при создании, то оно напр. пустой массив (если оно null)
2. какое-то поле не указано при обновлении, то ничего с ним не делать (если оно null)
3. если при обновлении поле пустой массив, то заменить им то что уже есть (и вообще заменять содержимым этого массива то что уже есть)

Почему работает так: парсеры преобразующие json в object, например jackson в Java, интерпретируют его как null.

# XSS
**XSS** - это когда вставленный в ссылку или текстовое поле javascript встраивается в страницу и может выполнится от лица пользователя (кликнувшего по ссылке со скриптом или зашедшего на страницу если скрипт добавлен сообщением и весит там постоянно)

# Протокол http
Протокол IP содержи TCP и UDP

IP резервирует первые 1024 порта для протоколов

URI и его подмножество URL и URN

кэширование в http

# Модель OSI
