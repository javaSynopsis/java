что должен знать программист, кэши, система, сложность алгоритмов и много интересного
https://github.com/mr-mig/every-programmer-should-know
****************************************************
Stream - потоки

Поток - абстракция потребляющая или производящая информацию.
По сути Stream - класс, который содержит методы:
    istream osstream(istream & is, data) {
        //send data to is
        return is;
    }
    ostream isstream(ostream & os, data) {
        //get data from os
        return os;
    }
На объектах, которые вернул этот класс можно выполнять операции.
Т.к. тип принятого и возвращенного объекта тот же.

Stream - могут быть потоками ввода/вывода: байтовые, строковые и др.

Stream - это также работа с потоками объектов (фактически массивами объектов) через цепочки вызовов: filter, map, flat, reduce, find
****************************************************
OOP

Процедурно-функциональное программирование - просто использование функций.
OOP - использование классов: наследование, полиморфизм, инкапсуляция

единица инакпсуляции - класс

класс - данные и код, которые будут использоваться объектом
объект - физическое воплощение класса

благодаря наследованию программа возрастает в арифмитической, а не геометрической прогрессии

полиморфизм - один интерфейс множество методов, предок может указывать на любого наследника (которые могут заменять методы предка или дополнять их)
****************************************************
AOP - аспектно ориентированное программирование

join point - метод к которому применяется advice
aspect - комбинация pointcut и advice

В Spring AOP:
1. Создаем advice с уникальным id, правило о том к какие методы применять к другим методам если они (их имена) подходят под pattern (RegEx)
2. Создаем pointcut с уникальным id. pattern имен классов, пакетов и т.д. к которым будет применяться advisor
3. Создаем advisor с уникальным id одновременно указывает на:
    1. advice (правило по которому одни методы могут быть применены к другим)
    2. pointcut (правило по к методам какого класса применяется advisor)
    
Сами связи всех advice, pointcut, advisor делаются по id (уникальному имени). Т.е. передачей ссылок на них друг другу. 

core concerns - обычная задача, напр. бизнес логика (сервис в MVC)

crosscutting concerns or system-wide concerns (Сквозная задача) - задача через которую как бы проходят основные задач (на сквозь). Например транзакции, логирование, проверка на безопасность (security) и пр. Т.е. сквозная задача как бы оборачивает в свой код (через AOP) другие задачи.

CTW (compile-time weaving) и LTW (load-time weaving) - типы связывания в AOP, на этапе компиляции или на этапе загрузки объектов в памяти.
****************************************************
lvalue - переменная, rvalue - константа (справа от равно)

точка входа - функция с которой программа начинает работу

closure (замыкание) - структура (функция, вложенный класс и т.д.), которая содержит указатель (или ссылку) на контекст в котором она создана (например указатель на this класса в котором она вызвана). Лямбда функции не имеют this на внешний класс или функцию.

лексема - порция данных разбитая разделителями

терминал - конечный символ, его нельзя разбить на составляющие

Экспоненциа́льная за́пись — представление действительных чисел в виде мантиссы и порядка.
    k = m * n^p
    m - мантисса
    n - основание показательной функции
    p - порядок
    n^p - характеристика числа
В комп. E (exponent) обозначает не число Эйлера (2.71), а число 10, связано с особенностями комп., например: 10E-6

коллекция классов - класс могущий указывать на другой класс или его наследника(ов), т.е. содержит массив классов

ссылка - указатель на объект, при передачи в функцию объект не копируется, при передаче базового типа (int, float, char etc) происходит копирование. Если изменить объект по ссылке в функции, то он изменится.

static - это глобальные методы и переменные

enum (Перечисления) - список именованных констант

позднее связывание - на этапе выполнения (выбор какой именно объект-наследник создавать)
раннее связывание - на этапе компиляции

Coherence and conjugation понятия в программировании - ОПИСАТЬ

лексер - разборщик текста (его байтового представления) на токены (отдельный группы байт)
LR-грамматика - 
    Тут описание просто парсера правда https://habr.com/post/99162/
    
использовать регулярки для поиск открывающей и закрывающей скобочки НЕ ВОЗМОЖНО, это доказано математически

ОПИСАТЬ!
О балансере нагрузок (nginx, но может подойдет и другим?)
https://www.nginx.com/resources/glossary/load-balancing/

Мини компилятор на js (что полезно там четкое разделение на transformer, parser, lexer, generator)
https://medium.com/@kosamari/how-to-be-a-compiler-make-a-compiler-with-javascript-4a8a13d473b4

Сборник интересных статей на англ, напр. о протоколах. Написано легким языком
    (доступ платный, но можно поискать аналоги)
Список:
    Types
        Statically typed languages
        Dynamically typed languages
        Static and dynamic languages compared
        Strong and weak typing
        Gradual typing
        Compiling statically typed code
        Arguments for static and dynamic types
        Diversity of static type systems
        Type system power
        Some static type systems
    Digital Electronics
        Logic Gates
        De Morgan's Laws
        Building gates from NAND
        The Universality of NAND
        Adding numbers in computers
        Half adders
        Full adders
        Multi-bit addition
    Software Structure
        Programming language structure
        Code is mostly graphs
        Graphs in thought
        The call graph
        Reasoning about call graphs
        Module interaction graphs
        Structure of ubermodules
        Arguments against ubermodules
        Improving the module graph
        The package dependency graph
        Package granularity
        The utility of graph analysis
    Network Protocols
        Network routing
        Packet switching
        Out-of-order packets
        Transmission windows and slow start
        Reliable transmission
        Physical networking
        Networking meets the real world
        The interconnected network stack
Источник https://www.destroyallsoftware.com/compendium

CVS - система контроля версий

marshal - операция похожая на serialization, меняет формат данных на подходящий для передачи. Часто применяется для передачи данных между программами (процессами, потоками). В разных языках понятие различается. В Java в отличии от serialization операция marshal действует и на код (не только данные?).
    Неважная инфа: Для java.rmi.Remote операция marshal работает с удаленным объектом по URL (stub) вместо работы с ним самим.
unmarshal - обратная операция
****************************************************
REST

REST - Representational State Transfer (передачи представлений о состоянии) - это архитектурный подход.
RESTful - называют сервисы (или что-то другое), что следует архитектуре REST.

URL - Uniform Resource Locator, подмножество URI
URI - Uniform Resource Identifiers

verb - part of a URL path
Идемпотентный метод - может изменять или не изменять состояние ресурса, но повторные запросы, следующие за первым, не должны оказывать влияния на состояние ресурса
безопасный метод -  не изменяет состояние ресурса

типы запросов:
    GET - получение
    POST - добавление
    PUT - обновление
    PATCH - как put, но применяется к части ресурса
    DELETE - удаление
    OPTIONS - возвращает параметры сервера или соединения
    HEAD - как get, но в ответе только headers без body
    TRACE - возвращает отправленное body назад
    CONNECT - тунелирует соединение в удаленный ip, используется для цепочки прокси

Http запрос состоит из:
    1. Http header
    2. Http body

http статусы:
    1xx - informational
    2xx - Success
    3xx - Redirection
    4xx - Client Error
    5xx - Server Error
    
Пример массива в get (с одинаковыми name складываются в один параметр, возможно зависит от настроек сервера):
/about?name=Tom&name=Bob&name=Sam

Параметр запроса - параметры после &: /about&m=2
Параметр маршрута - часть пути: users/12
    
Http header Content-Type для REST:
    1. application/hal+json для HATEOAS (Hypermedia)
    2. или application/json для чистого REST
    
Некоторые headers:
    Accept: text/plain - типы допустимых ресурсов пользователю.
    Accept-Charset: utf-8 - кодировка

Note: есть подход при котором используется только POST запросы, а описание операции (create, read, update, delete) передаются внутри запроса.
Это плохая практика и в некоторых статьях названа антипаттерном.

При https шифруются и POST, и GET, но POST обычно не логируется на сервере, НО это зависит от настроек сервера.
Для GET (как и для других запросов) шифруется весь запрос в том числе и URL, т.к. шифрование происходит вообще до создания запроса.
POST может использоваться там, где не нужно показывать данные в адресной строке, например пароля.

GET запрос обычно имеет меньший размер, но это настраивается на сервере.

Поисковой запрос REST на сервер или любой запрос с большим количеством параметров:
Его нужно делать не в GET, а в POST не смотря на то, что это отход от стандартов.
Потому что GET имеет ограничение на длину.
При этом современные front-end фреймворки могут отображать в адресной строке браузера любой url, поэтому это не так критично.

HATEOAS (Hypermedia as the Engine of Application State) - когда передается список связанных сущностей в отдельном свойстве. Точнее ссылки на них по которым их можно получить (в Spring модуль HAL)

Браузеры преобразовывают значение атрибута http-equiv, заданное с помощью content, в формат заголовка ответа HTTP и обрабатывают их, как будто они прибыли непосредственно от сервера.
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta http-equiv="expires" content="Sun, 01 Jan 2013 07:01:00 GMT">

Один из подходов отправки запроса REST:
	1) пустой массив отправленный с клиента на сервер затирает уже имеющиеся данные
	2) null отправленный с клиента на сервер ничего не делает, это при неуказании поля в json вообще
Описание:
	1. какое-то поле не указано при создании, то оно напр. пустой массив (если оно null)
	2. какое-то поле не указано при обновлении, то ничего с ним не делать (если оно null)
	3. если при обновлении поле пустой массив, то заменить им то что уже есть (и вообще заменять содержимым этого массива то что уже есть)
Почему работает так: парсеры преобразующие json в object, например jackson в Java, интерпретируют его как null.

****************************************************
Процессы в ОС и принципы их работы:

Взять отсюда о том из чего состоит процесс и как работает:
    https://www.geeksforgeeks.org/memory-layout-of-c-program/

1. Принципы работы стека:
Локальные переменные и параметры хранятся в стеке. При рекурсии нужно писать условие выхода из стека, чтобы не было переполнения.
Динамические переменные хранятся в куче.

И стек и куча оба находятся физически в RAM (не рассматриваем архитектурные вывихи с использованием спец. процессоров/компов)

Их размеры и расположение определяются осью

При этом куча может быть фрагментирована (иногда довольно сильно). Обычно у осей бывают специальные процедуры для дефрагментации кучи.

Стек обычно никогда не фрагментирован (наверное можно придумать реализации стека с фрагментацией, но это оксюморон).

Стек как бы быстрее потому, что у него единственный параметр с которым работает - это указатель положения стека (обычно регистр) - поэтому все операции со стеком работают в разы быстрее чем с кучей. Операция извлечения/записи из стека это 1 телодвижение процессора POP/PUSH

С кучей сложнее именно из-за его фрагментации и простая операция извлечения значения из него может вылиться в десятки (если не сотни) телодвижений процессора.

Минусы стека в малости его размера (он всегда по сравнению с кучей на порядок меньше) - ну и в том, что доступ к нему только последовательный.
****************************************************
Методы очистки памяти (RAM)

Smart pointer - 

1. Подсчет ссылок
2. Пометить и очистить
****************************************************
Кэш:

кэш - реализуется в виде класса хранящего другие классы (коллекции). Содержит таймер, поток-демон работает, запускается иногда и проверяет устаревание объекта (сколько им можно жить). Если время истекло - удаляет.
	В Java можно использовать слабые ссылки (SoftReference), они будут сами удаляться если памяти мало (без таймера).
	
	«Уровень попаданий» кэша - означает то, насколько часто искомые данные обнаруживаются в кэше. Более эффективные политики вытеснения отслеживают обращения к наиболее используемой информации
	
	«Латентность» кэша - означает, насколько быстро кэш может вернуть запрошенные данные непосредственно после запроса (в случае, если происходит «попадание»). Более быстрые стратегии вытеснения обычно отслеживают наименее используемую информацию — или, в случае кэша прямого отображения (direct-mapped cache), отсутствие информации, чтобы снизить затраты времени на обновление информации.

http://stackoverflow.com/questions/18878802/what-is-cache-in-c-programming
кэши CPU L1, L2, L3, L4 - чем меньше номер, тем быстрее. Если код может поместиться в быстрейший - он помещается автоматически. Если нет, то помещается в менее быстрый.

Существуют различные алгоритмы работы кэша, которые по разному вытесняют редко используемые данные и дольше сохраняют часто используемые.
    Least recently used (LRU) - Вытеснение давно неиспользуемых
    Most Recently Used (MRU) - Наиболее недавно использовавшийся
    Алгоритм Белади - 
    Псевдо-LRU (PLRU) - 
    Сегментированный LRU (Segmented LRU или SLRU): - 
    и еще несколько (описать)
****************************************************
Почему 31 используется для хэшей:
	https://stackoverflow.com/a/299748

там много пояснений, одна из версий:
1. на 31 некоторые процессоры умножают быстрее
2. с 31 нужно сделать только один shift (сдвиг) влево (имеется ввиду 32 разрядное число), поэтому получается больше места (видимо имеется ввиду незанятых разрядов) которые можно использовать для хэш кодов и уменьшить коллизии.
3. на RISC процессорах 31 это разница двух чисел в степенях 2 (и видимо работает быстрее)
4. 31 это max число помещающееся в 8 бит ригистер, ничетное число и поэтому оно удобнее (т.е. система счисления в компьютерах двоичная видимо числа делящиеся на 2 неудобно работают с хэшами где значения должны быть уникальны)

public int hashCode() {
	return 31;
}
****************************************************
Модель OSI

****************************************************
сокет - это пара IP-порт (слушать/отправлять запросы)

исполняемый файл - это набор бит: код, данные
	exe - в windows
	elf - в linux?
	в каждом стандарте описывающем исполняемый файл - по разному. Первые байты указывают на тип и структуру (где кода, где данные и т.д., через сколько бит перепрыгнуть чтобы попасть на нужный адрес кода/данных)

энтропия - в сжатии это степень разброса данных. В сжатых файлах сначало идет указатель, а потом данные, так что график плавный. В незжатых он рваный
****************************************************
Криптография

публичный ключ - генерируется для раздачи всем, им можно только расшифровывать
приватный ключ - генерируется только для себя, им можно шифровать
****************************************************
процесс состоит из стэка, кучи (heap), данных

способы обмена данными между процессами:
	pipe
	...
****************************************************
как работает парсер: строится граф сивмолов (какие могут за какими следовать), проводится валидация распарсиваемого кода по этому графу. Если она верна запускается парсер.
Дальше идет тот же процесс, но строки накапливаются в переменных (для xml это название тегов). Используются if/else, switch/case для того чтобы найти заданный элемент при парсинге и сделать что-то.

обратная польская запись - используется чтобы поставить опперации в порядке их исполнения. Нужна например при реализации калькулятора. (потом текстовое представление операций заменяется на настоящие операции)
****************************************************
Многопоточность

Монитор - черный ящик, который может исполнять только 1 поток одновременно.

Spinlock - аналог монитора на уровне ассемблера. В переменную заносится значение занято/незанято, и если "занято" параллельный ПРОЦЕСС ждем пока освободится.

Семофор - класс содержит счетчик, сколько потоков может выполняться одновременно (счетчик уменьшается/увеличивается при удалении/завершении потоков)

Обмен сообщениями потоков - это методы для работы с потоками (notify(), wait() и т.д.) В других языках обмен происходит средствами операционной системы.

Thread-local storage (TLS) - метод в многопоточном программировании. По сути глобальная переменная, которая может принадлежать нескольким потокам одновременно. В Java эта переменная типа Map (в Java класс называеися ThreadLocal)

процессы и потоки демоны (сервисы) - те, что работают в фоне
	В Java поток-демон выполняется пока работает запустившая его программа

race condition - когда 2+ потока работают неправильно параллельно с одними данными (затирают, читают не в том порядке и пр.)
	
dead lock
    - deadlock может быть представлен как "контур" (на ориентированном графе путь из вершины в саму себя). Поиск deadlock может быть реализован как поиск входа их вершины в саму себя.
    - явление при котором все потоки находятся в режиме ожидания
	- это ultimate form of starvation
	
live lock - threads не могут продолжать работу, чтобы уступить ресурсы друг другу они постоянно посылают сообщения о том что ресурс свободен (в оригинале: посылают друг другу сообщения что другому потоку можно продолжить работу). Разница с dead lock в том, что потоки не блокированы, работают, но результат их работы - бесконечные попытки уступить ресурс.
	- можно представить как попеременное выставление двух флагов-переменных каждый из которых означает, что одному из двух потоков можно продолжить работу. Первый поток устанавливает один флаг, второй поток второй, первый поток видит что второй флаг изменился и устанавливает второй, второй поток делает тоже самое; и так в бесконечном цикле.

Starvation - это случай, когда процесс не получает нужный ему ресурс по какой-либо причине (мешают другие процессы, планировщик процессов системы не выделяет ресурс и прочее)
	- случается когда слишком низкий приоритет не дает работать
	- планировщик случайно выбирает запускаемые процессы и конкретному процессу не выпадает шанс работать
	- не хватает ресурсов системы, чтобы выделить ресурс процессу
	- ошибка работы планировщика

Пример, один из приемов решения deadlock в DB - произвольное отпускание (releasing) одного из процессов.

Double checked locking - Блокировка с двойной проверкой
    - параллельный шаблон проектирования, сначало проверяется флаг (true/false) блокирован или нет, а только потом делается ПОПЫТКА синхронизации
    - На некоторых языках и/или на некоторых машинах невозможно безопасно реализовать данный шаблон. Поэтому иногда его называют анти-паттерном. Такие особенности привели к появлению отношения строгого порядка «happens before» в Java Memory Model и C++ Memory Model.

volatile - переменные которые могут быть изменены одновременно несколькими потоками, используются для неблокирующей синхронизации. В Java каждый поток имеет свою копию переменной и синхронизирует ее с основной время от времени, volatile делает так, что переменная одна на все потоки.

atomic - синхронизированные переменные. Не подвержены race condition. Основана на CPU инструкции compare-and-swap, которая быстрее чем операция lock.

Закон Амдала
	«В случае, когда задача разделяется на несколько частей, суммарное время её выполнения на параллельной системе не может быть меньше времени выполнения самого медленного фрагмента
	При этом начиная с некоторого момента дальнейшее распоралеливание наоборт замедляет вычисление, т.к. на передачу между параллельными потоками тоже тратятся ресурсы
****************************************************
Как работают регулярки: 
****************************************************
Сложность алгоритмов:
    асимптотическим поведением - при анализе скорости отбрасывается лишнее, учитывается только значимое (учитывается только количество циклов). Т.е. f(6n + 8) == n
    
Оценка с точки зрения здравого смысла:
	Можно оценить порядок многих базовых алгоритмов с точки зрения здравого смысла.

	• Простые циклы. Если простой цикл выполняется от 1 до n, то алгоритм, скорее всего, является O(n) – время находится в линейной зависимости от n. Примерами этого являются исчерпывающий поиск, поиск максимального элемента в массиве и генерация контрольной суммы.

	• Вложенные циклы. Если вы помещаете один цикл в другой, то ваш алгоритм становится O(m*n), где m и n – пределы этих двух циклов. Обычно это свойственно простым алгоритмам сортировки, типа пузырьковой сортировки, где внешний цикл поочередно просматривает каждый элемент массива, а внутренний цикл определяет местонахождение этого элемента в результирующем массиве. Подобные алгоритмы сортировки чаще всего стремятся к O(n^2).

	•  Алгоритм двоичного поиска. Если алгоритм делит пополам набор элементов, который он рассматривает всякий раз в цикле, то скорее всего он логарифмический O(lg(n)). Двоичный поиск в упорядоченном списке, обход двоичного дерева и поиск первого установленного бита в машинном слове могут быть O(lg(n)).
        - КАЖДАЯ ПОЛОВИНА ПРОСМАТРИВАЕТСЯ ОТДЕЛЬНО, если речь о двоичных алгоритмах поиска и подобных

	• Разделяй и властвуй. Алгоритмы, разбивающие входные данные на разделы, работающие независимо с двумя половинами и затем комбинирующие конечный результат, могут представлять собой O(nlg(n)). Классическим примером является алгоритм быстрой сортировки, который делит входной массив пополам и затем проводит рекурсивную сортировку в каждой из половин. Хотя технически он и является O(n^2), поскольку его поведение ухудшается при обработке упорядоченных данных, но среднее время быстрой сортировки составляет O(nlg(n)).
        - Пример: сортировка слиянием, поиск как при бинарном поиске O(log n), но повторяется для каждой половины n раз, общая скорость O(n*log n)

	• Комбинаторика. При использовании алгоритмов в решении любых задач, связанных с перестановкой, время их выполнения может выйти из-под контроля.
	Это происходит потому, что задачи о перестановке включают вычисления факториалов (существует 5! = 5*4*3*2*1 = 120 перестановок цифр от 1 до 5). Возьмем за основу время выполнения комбинаторного алгоритма для пяти элементов; для шести элементов времени потребуется в шесть раз больше, а для семи – в 42. Примерами этого являются алгоритмы решения многих известных сложных задач – о коммивояжере, об оптимальной упаковке предметов в контейнер, о разделении набора чисел таким образом, что сумма каждого отдельного набора одинакова и т. д. Во многих случаях для сокращения времени выполнения алгоритмов данного типа в определенных прикладных областях используются эвристические подходы.
	
	O(1) - лучшее время (без циклов)
	O(sqrt(n)) - почти как O(log n), но хуже. Но такая оценка схемах встречается реже.
	O(e^x) - экспоненциальное время, тоже встречается реже.
	
	n			log n	n*log n		n^2
	1			0		0			1
	16			4		64			256
	256			8		2,048		65,536
	4,096		12		49,152		16,777,216
	65,536		16		1,048,565	4,294,967,296
	1,048,576	20		20,969,520	1,099,301,922,576
	16,775,616	24		402,614,784	281,421,292,179,456
	
Класс сложности:
    Это множество задач распознавания, для решения которых существуют алгоритмы, схожие по вычислительной сложности. Два важных представителя:

	Класс P вмещает все те проблемы, решение которых считается «быстрым», то есть время решения которых полиномиально зависит от размера входа. Сюда относится сортировка, поиск в массиве, выяснение связности графов и многие другие.
	
	Класс NP содержит задачи, которые недетерминированная машина Тьюринга в состоянии решить за полиномиальное количество шагов от размера входных данных. Их решение может быть проверено детерминированной машиной Тьюринга за полиномиальное количество шагов. Следует заметить, что недетерминированная машина Тьюринга является лишь абстрактной моделью, в то время как современные компьютеры соответствуют детерминированной машине Тьюринга с ограниченной памятью. Поскольку детерминированная машина Тьюринга может рассматриваться как специальный случай недетерминированной машины Тьюринга, класс NP включает в себя класс P, а также некоторые проблемы, для решения которых известны лишь алгоритмы, экспоненциально зависящие от размера входа (то есть неэффективные для больших входов). В класс NP входят многие знаменитые проблемы, такие как задача коммивояжёра, задача выполнимости булевых формул, факторизация и др.

Вообще функций для оценки времени много, а выше только основные, табл тут:
    https://en.wikipedia.org/wiki/Time_complexity#Table_of_common_time_complexities
****************************************************
Сортировки:
	Пузырек
	слиянием - легко параллелиться
	qsort
	timsort - самая крутая, несколько алгоритмов сортировки использование которых зависит от условий
****************************************************
массив - коллекция похожих (однотипных) объектов или данных примитивных типов (int, float, char, ...)
динамический массив - массив длинна которого увеличивается автоматически при добавлении элементов, и сокращается при удалении

дерево, список и т.д. - по сути класс который содержит указатель на себя же (или массив указателей), так что можно построить цепочку таких классов.

Словарь, карта, map, ассоциативный массив, свойства, properties - синонимы для названия класса который содержит пары ключ-значение, т.е. по названию можно получить объект
    get("myObj"), set("myObj", new MyObj())
часто ключи это строки, но не всегда. Map часто реализуется с помощью хэш-таблицы.
	
картежи, пары (не из Java)
	Коротко: просто аналог enum в который можно помещать объекты разных типов, а не одного
https://medium.com/@frontman/%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6%D0%B8-%D0%B2-javascript-af280e716ebc
	
О каких структурах данных надо помнить:
	стэк (stack) LIFO (Last In First Out)
	
	очередь (queue) FIFO (First In First Out)
	
	Куча (heap) - двоичное дерево реализованное через обычный массив. Сами элементы в массиве расположены просто по порядку как если бы узлы дерева читались сверху внизу, слева на право. Высота log n и время работы тоже O(log n) (т.е. алгоритм экономный). “сортировка кучей” имеет сложность O(nlogn)
        - Есть min-heap и max-heap - отсортированные по min или max значениям.
	
	список (list) - каждый элемент содержит ссылку на такой же
	
	динамический массив - который сам меняет длинную при удалении/добавлении в него
	
	множество, Set - все элементы уникальны, есть операции над множествами
	
	Хеш-таблица (Map, Dictionary) - использует хэш в качестве ключей, с начало поиск объекта идет по хэшу, если хэш совпадает, то сравнивается содержимое объекта. Хэши двух разных объектов могут совпадать, потому что они реализованы упрощенно, чтобы облегчить их создание и поиск (это тот тип уникальных хэшей, которые используются для сравнения файлов). Коллизия - термин означает совпадение хэша двух разных объектов. В случае если хэш совпал, но объект не тот, то поиск по хэшу продолжается.
		- реализация Map, где для поиска используется хэш ключей (содержит массив хэшей - для каждой пары ключ-значение свой хэш)
		- DHT (distributed hash table) - распределённая хеш-таблица класс децентрализованных распределённых систем поискового сервиса, работающего подобно хеш-таблице. (на нём основаны торенты и прочее)
	
	Таблица поиска (lookup table) - данные заранее вычисляются и помещаются в Map, потом вместо их вычисления в коде просто достаются готовые, чтобы было быстрее
	
	Rope (веревка) — структура данных для хранения строки, представляющая из себя двоичное сбалансированное дерево и позволяющая делать операции вставки, удаления и конкатенации с эффективностью O(log n).
        - подстроки всей строки хранятся в листьях деревьев, а значение узлов деревьев это индекс начала подстрок. Чтобы взять подстроку нужно просто пойти в лист нужным индексом.
	
	Skip List (Список с пропусками) - ОПИСАТЬ
        - эффективность O(log n), как у двоичного дерева
	
	Структуры типа дерево:
		Дерево - нецеклический граф
			- рекурсивное (неупорядоченное) - просто структура, где порядок расположения неважен
			- упорядоченное - где ребрам назначаются числа (веса), или листьям?
		Двоичное дерево, бинарное дерево
			- в которой каждый узел имеет не более двух потомков (детей). На его основе строятся несколько полезных типов деревьев.
			Варианты:
				двоичная куча - где у узла только два потомка,
		Красно-чёрное дерево (Red-Black-Tree, RB-Tree)
			— это одно из самобалансирующихся двоичных деревьев поиска, гарантирующих логарифмический рост высоты дерева от числа узлов и быстро выполняющее основные операции. Используется для хранения сравнимых данных (фрагментов текста, чисел).
		Куча, max-кучами (Heap, max heap)
			- если B является узлом-потомком узла A, то ключ(A) ≥ ключ(B). Из этого следует, что элемент с наибольшим ключом всегда является корневым узлом кучи
		B-дерево (B-tree), балансное дерево
			- корни имеют не две ветки, а много
			Сбалансированность означает, что длина любых двух путей от корня до листьев совпадает.
		Двоичное дерево поиска, бинарное дерево поиска (BST)
			- у всех узлов левого поддерева произвольного узла X значения ключей данных меньше, нежели значение ключа данных самого узла X
		АВЛ-дерево
			— сбалансированное по высоте двоичное дерево поиска: для каждой его вершины высота её двух поддеревьев различается не более чем на 1. АВЛ-дерева балансировкой вершины называется операция, которая в случае разницы высот левого и правого поддеревьев = 2, изменяет связи предок-потомок в поддереве данной вершины так, что разница становится <= 1
        B+дерево - самый нижний уровень это узлы с индексами и значениями, узлы выше просто содержат условия с индексами вида >50, <20, >10 и т.д. Верхние узлы как в бинарном поиске указывают в какую часть дерева пойти чтобы найти нужный узел в нижнем уровне. Все узлы нижнего уровня связаны как List, если нужно взять промежуток, то идем по списку от текущего и далее в связанные.
        
        parse tree - дерево синтаксиса языка, дерево граматики языка для компилятра, которая потом будет преобразована в AST
        AST (abstract syntax tree) - используется в парсерах, листья это операторы (кого-то языка) или операнды. AST потом преобразуется в структуру данных для, которая используется в компиляторе.
****************************************************
Граф

Циклические
Нецеклические
ориентированные ребра - одно направленные
неориентированные ребра - двух направленные
взвешенные ребра

Степень вершины
    - Входящая степень вершины v это количество ребер вида (i, v), то есть количество ребер которые «входят» в v.
    - Исходящая степень вершины v это количество ребер вида (v , i), то есть количество ребер которые «выходят» из v.
    
Путь в графе - конечная последовательность вершин соединенных друг с другом

Путь в сам себя
    - называется "циклом" в ориентированных
    - называется "контур" в неориентированных (в коде аналог это deadlock)
    
Поиск в ширину (breadth-first search, BFS)
    - проверяет все узлы на уровне, если значение не найдено, проверяет все узлы на следующем уровне
    - можно реализовать рекурсивно или стек+цикл

Поиск в глубину (Depth-first search, DFS)
    - выбирается вершина, если она не конец и значение не найдено, то идем в любую вершину на следующем за ней уровне, потом возвращаемся на предыдущий уровень и выбираем другую (бывает рекурсивный и нерекурсивный)
    - можно реализовать рекурсивно или очередь+цикл
	
Матрица смежности - способ представления графа в виде матрицы, где элементы матрицы 0 или 1 означают перейти в нужную вершину или нет (переход из вершины с номером строки в вершину с номером столбца).
    - в некоторых вариациях вместо 0 и 1 веса ребер (длину/сложность или др. циферку стоящую над ребром); существуют и др. вариации
    - эффективен, если количество переходов (плотность) высокая, иначе память расходуется на 0ки впустую. И если количество вершин примерно равно количеству ребер.

Список смежности - способ представления графа, используется где ребер мало (разреженный). Это массив каждый элемент которого указатель на список. Сами списки хранят переходы из одной вершины в другу (т.е. признаки есть переход или нет, скорее всего представленные в виде указателей)
    - Прим. при этом способе переходы (ребра) хранятся только для вершин для которых они есть, а не всех как в матрице смежности. Экономия.
****************************************************
Поиск путей

Алгоритмы:
A*
Дейкстры
****************************************************
буфер - обычно используется для операций в оперативной памяти вместо жесткого диска, чтобы было быстрее. А как только накапливается определенное количество данных они записываются на диск. 
    - Во многих языках можно принудительно сделать flush() и сохранить буфер на диск (или куда-то еще) до того как это сделает встроенный алгоритм.
****************************************************
идентификатор - имя переменной, начинается с букв, _ и $, может содержать цифры
	(c JDK 8 не рекомендуется использовать САМ? знак подчеркивание _ )
	нельзя использовать true, false и null
	
литералы - 'x', "hello", 100, используются для постоянных значений
	int x = 07; - восьмиричный
			0xA или 0Xa - шеснадцатиричные (регистр не значит)
****************************************************
Классы

класс - это шаблон, тип данных, определение типа
объект класса - экзепляр, занимает конкретную область физической памяти

при создании массивов объектов вызывается конструктор по умолчанию, поэтому лучше всегда иметь в классе конструктор без параметров (пусть и пустой)
Box b1 = null; // разрываем связь с объектом

конструктор копирования - используется во многих языках программирования, принимает объект своего же типа и копирует значение переменных переданного ОБЪЕКТА себе во время своего создания. Инициализировать поля лучше в конструкторе, а не присвоением значений переменным класса, потому что в наследниках способы инициализации можно переопределить (ВРОДЕ БЫ)

метод сравнения - метод который принимает ссылку на объект того же класса, сравнивает его переменные с своими и возвращает true/false

цепочка вызовов - это когда метод возвращает ссылку на себя же return this, так что следующий вызов можно провести прямо на этой функции
doSmth().doSmth2().doSmth3();

перегрузка - При перегрузке методов выбор происходит по имени метода, типу и количеству его аргументов

переопределение - замена метода из класса предка в методом в классе наследнике (часто метод-наследник вызывает метод-предок в себе первой строкой, а потом делает что-то дополнительно, тоже касается конструкторов)

inline методы (в разных языках ведут себя по разному) - встраиваются точку вызова, а не вызываются по ссылке. Чуть быстрее, но занимают больше места на диске.

хэш код класса - может использоваться для сравнения объектов в структурах данных (типа Map, Set). Хэши у разных объектов могут совпадать (коллизия), тогда сравнение идет по переменным объекта и в случае неудачи поиск по хэшу для других объектов продолжается. Как правило реализуется в виде метода класса, который генерирует хэш на основе переменных членов класса.
****************************************************
перевод из 2-ой системы в 10-ую: 01101001 = 2^0 + 2^3 + 2^5 + 2^6 (степени)
перевод из 10-ой системы в 2-ую: делим число на 2 и записываем остатки от деления справа на лево (остатки будут 1 или 0). Эти остатки и есть число.

перевод из 10ой в 16ую: делить на 16, записать 10ный остаток в виде 16го числа, повторять пока остаток не станет 0, записать 16ые числа справа на лево
перевод из 16ой в 10ую: заменить числа на десятичные и каждый порядок умножить на 16 в степени равной прядку: E7A916 = 14×16^3+7×16^2+10×16^1+9×16^0

общая формула перевода в систему счисления, где an - первая цифра, a0 - последняя:
    C = an * M^n + an-1 * M^(n-1) + ... + a1 * M^1 + a0 * M^0
****************************************************
Битовые операции

&
|
^ - xor (сложение по модулю 2) часто применяется в симметричном шифровании, где число с которым делается xor это это ключ
<<
>>
>>> - сдвиг вправо с заполнением нулями
~

Запомнить в какую сторону плывет головастик
-~1 == 2 //аналог ++1
~-1 == 0 //аналог --1

старший разряд - знак числа во многих языках

Инвертировать число
~42 + 1 = -42 //инвертировать биты и прибавить 1

старший разряд - знак числа (часто, но не всегда, есть беззнаковые типы и др.)

<< - на 1 позицию аналогично умножению на 2
>> - деления на 2

||/&& (условные) - false/true если первый операнд false/true (не вычисляя второй)
	наз. условные операции
	
для |/& (поразрядные) всегда выполняются оба условия - (c > d & c++) //c++ выполняется всегда
****************************************************
Сеть

Аутентификация - это проверка соответствия субъекта и того, за кого он пытается себя выдать, с помощью некой уникальной информации (отпечатки пальцев, цвет радужки, голос и тд.), в простейшем случае - с помощью имени входа и пароля.

Авторизация - это проверка и определение полномочий на выполнение некоторых действий (например, чтение файла /var/mail/eltsin) в соответствии с ранее выполненной аутентификацией,

Хеш-алгоритмы являются односторонними функциями. Они превращают любое количество данных в «дактилоскопический отпечаток» фиксированной длины, который не может быть обратим.
	bcrypt - спец. алгоритм хэшированию сделанный так, что его трудно распораллелить, чтобы замедлить вычисления

XSS - это когда вставленный в ссылку или текстовое поле javascript встраивается в страницу и может выполнится от лица пользователя (кликнувшего по ссылке со скриптом или зашедшего на страницу если скрипт добавлен сообщением и весит там постоянно)

HttpOnly - параметр куков, если установлен, то кука не может быть прочитана скриптом. Всегда установлен для сессии (тоже по сути куки с идентификатором). Так никто не угонит сессию, потому что она уникальна и вычисляется при каждом входе заново.

CSP - запрещает внедрять в страницу inline скрипты, использовать eval(), разрешать запросы для js со страницы только к выбранным доменам.
    - существуют различные методы обхода, например берем часть страницы скриптом, вставляем в тег <img src="!here!"> и в запросе GET к враждебному домену будет кусок страницы.
    - можно проделывать тоже с атрибутами CSS запрашивающими данными через src свойство.

CSRF/XSRF (Cross-site request forgery) token - token отправляется одним из параметров запроса, у каждого пользователя свой используется чтобы проверить можно обрабатывать запрос на сервер (если token верный) или нет. Угроза: если CSRF token не будет, то любой сможет отсылать value для input на сервер (и др. данные)
    - CSRF token может быть полем форму, частью http referer, содержаться в спец. http header
    - CSRF token не передают в адресе, а только в теле запроса. Следовательно используют только для методов которые изменяют данные на сервере (POST, PUT, DELETE). Методы GET, HEAD не изменяют данные и не имеют тела запроса, для них не нужен token.
****************************************************
Соль:
    Источник: http://www.internet-technologies.ru/articles/article_1807.html
    
Соль - когда перед хэшированием к каждому паролю добавляется постоянная строка (число и т.д.). В результате на выходе хэширования - нестандартный хэш. Так труднее раз хэшировать украденные пароли.
С солью длинна пароля искуственно удленняется. Так хэш не страдает от коротких паролей.
	обычно ее сохраняют в базе данных пользовательских аккаунтов вместе с хеш-кодом, или как часть самой строки хеш-кода. (т.е. у каждого пароля будет своя соль, даже у одинаковых)
	
	придумывать разные хэш алгоритмы самому - плохо
	
	Соль не обязательно держать в секрете. Просто при использовании случайной величины для построения хеш-кода таблицы поиска, обратные таблицы поиска и радужные таблицы становятся неэффективными. Злоумышленник не узнает заранее, какая будет соль, поэтому он не может предварительно вычислить таблицу поиска или радужную таблицу.
	
	примеры чокнутых хеш-функций:
		md5(sha1(пароль))
		md5(md5(соль) + md5(пароль))
		sha1(sha1(пароль))
		sha1(str_rot13(пароль + соль))
		md5(sha1(md5(md5(пароль) + sha1(пароль)) + md5(пароль)))
		Не используйте ни одну из них. 

	Атаки по словарю - Самый простой способ взломать хеш-код – это попробовать угадать пароль, вычисляя хеш-код для каждого предположения и проверяя, совпадает ли этот хеш-код со взламываемым.
	(использует самые популярные фразу)

	Атака полным перебором - пробует все возможные комбинации символов до заданной длины. Эти атаки требуют очень больших вычислительных затрат,

	Таблицы поиска – это крайне эффективный метод для очень быстрого взлома большого количества хеш-кодов одного типа. Основная идея заключается в том, чтобы заранее вычислить хеш-коды паролей из словаря паролей, а затем сохранить хеш-коды и соответствующие им пароли в структуру данных типа таблица поиска.

	Радужные таблицы – это техника, являющаяся компромиссом между временем поиска и занимаемой памятью. Они похожи на таблицы поиска, за исключением того, что они жертвуют скоростью взлома хеш-кодов, чтобы сделать таблицы поиска меньше.
****************************************************
Как выглядит Http протокол:

пулл соединений

кэширование

15. URI и его подмножество URL и URN

индеподентный запрос - от клиента, который не приводит к изменению данных на сервере (в основном GET)

Протокол IP содержи TCP и UDP
IP резервирует первые 1024 порта для протоколов

****************************************************
чтобы два пользователя не могли залогиниться под одним логином одновременно нужно сохранить их имя-номер сессии в базе или синглтоне и проверять нет ли такого уже (обычно сервер позволяет создать глобальную переменную через конфиги)
Map<String, String> - имя-номер сессии
только если синглтон нужно подумать о способе очистки устаревших сессий из Map (то есть кэш)
в Spring есть конфиг для такого называется примерно - SessionConcurency
в Tomcat в конфиге xml можно создать класс синглтон один на всё приложение?
****************************************************
Project Management Methodologies

Первое что нужно знать это то, что на собеседованиях к этому относятся серьезно.
Второе это то, что определений и методов управления проектами очень много и все не выучишь.
Полный список методологий:
    https://www.tutorialspoint.com/management_concepts/project_management_methodologies.htm

Agile (Agile Software Development) - философия разработки продукта. Принципы: «Люди и взаимодействие важнее процессов и инструментов. Работающий продукт важнее исчерпывающей документации. Сотрудничество с заказчиком важнее согласования условий контракта. Готовность к изменениям важнее следования первоначальному плану».

Виды реализаций Agile (популярные):
    1. Scrum - это «подход структуры»
    2. Extreme Programming (XP)
    3. Kanban - это «подход баланса»

Waterfall - старая модель разработки. Делится на:
    1. Plan (планирование ВСЕГО проекта)
    2. Build (разработка)
    3. Test
    4. Review
    5. Deploying
    
Недостатки Waterfall:
    1. планирование должно быть закончено до того как начнется работа
    2. планирование сделано до того как проект будет понят
    3. по ходу разработки проекта проблемы с Build, Test, Review и Deploying вызывают постоянные изменения в Plan
    
Scrum
    1. Ключевые роли:
        1. Product Owner - объявляет фичи, которые нужны на проекте
        2. Scrum Master - защищает продукт и проект, поддерживает цикл разработки
        3. Development Team - тестеры, разработчики и всех остальных
    2. Цикл разработки, процесс, sprint:
        1. Plan - начальный план с минимальными фичами (КУСОК проекта)
        2. Build - только этот начальный набор функций
        3. Test $ Review - получаем маленький ГОТОВЫЙ продукт, ПОТЕНЦИАЛЬНО УЖЕ можно в релиз
    3. Типы документации (artefacts):
        1. Product Backlog - задачи, описание фич которые должны быть реализованы и их приоритеты
        2. User stories - описание фич пользователями. Пользователи как бы говорят: As a ... , I need ... , So that ...
        3. Spring backlog - список User stories с высоким приоритетом (т.е. то что должно быть сделано раньше). Каждая добавленная фича оценивается
        4. Burndown chart - график завершенности задач из Spring backlog, когда все закончено == 0
    4. Типы meetings (ceremonies, discussions):
        1. Spring Planning - Product Owner, Scrum Master и Development Team обсуждают User stories и оценивают их
        2. Daily Scrum - обсуждение того что сделали с предыдущего митинга, и какая помощь нужна
        3. Sprint Review (and retrospective) - обсуждение в конце Sprint, демонстрация работы и обсуждение
        4. Sprint Retrospective - то же что и Sprint Review, только обсуждение что улучшить в САМОМ процессе работы
        
Плюсы Scrum: в конце каждого цикла получаем готовый продукт, процесс разработки легко адаптируется.
    
Sprint или Sprint Cycles (от 1 до N) - единица цикла в Scrum. Обычно длится 1-3 недели. Sprints повторяются пока продукт не будет готов.

Kanban - Его задача – сбалансировать разных специалистов внутри команды и избежать ситуации, когда дизайнеры работают сутками, а разработчики жалуются на отсутствие новых задач.
Для визуализации agile-подходов используют доски: физические и электронные.
Главный показатель эффективности в kanban – это среднее время прохождения задачи по доске. Задача прошла быстро – команда работала продуктивно и слаженно. Задача затянулась – надо думать, на каком этапе и почему возникли задержки и чью работу надо оптимизировать.
Скорости работы команды нету - считается только скорость реализации задачи.
Вверху столбца - самая приоритетная задача.

Правила Kanban: 
    1. есть Plan, его приоритет или он сам может быть изменен
    2. Количество задач стоящих перед разработчиками ограничено

Столбцы на доске Kanban (по которым продвигаются листочки задач):
    Цели (goals)
    Очередь задач (story queue)
    Проработка архитектуры (Elaboration acceptance)
    Разработка (development)
    Тестирование (Test)
    Реализация (Release)
    Закончено (Done)
    
Цифра под столбцами доски Kanban - число задач могущих быть одновременно в столбце.
Рекомендуется ограничивать WIP (work in progress), число одновременных задач.

Expedite - место на доске для срочных задач, отдельная очередь. Выполняется всей командой. Может быть ОДНА такая задача.

Extreme Programming (XP) - легкая методология для маленьких или средних команд, которые сталкиваются с неясными быстро меняющимися задачами.

Принципы Extreme Programming:
    Feedback: TDD, The planning game, on-site customer, Pair Programming
    Continual Process: Continuous Integration, Code Refactoring, Small Releases
    Code understanding: Simple Design, Collective Code Ownership, System Metaphor, Coding Standards
    Work conditions: 40 h week
    
Принципы Extreme Programming коротко:
    Все работают на кодом, тестированием планированием вместе, плотно общаются с заказчиком.
    Релизы короткие, commits частые, рефакторинг постоянный.
    Из-за частых commits система fully integrated (целостна), это результат Continuous Integration (непрерывного объединения кода в единый проект).
    
Ко всем методологиям можно добавить определения:
    Continuous Integration - авто билд и тест приложения когда новый код запушен в ветку

    Continuous Delivery - Continuous Integration + Deploy приложения по клику на кнопку (релиз в прод частый, но по требованию).

    Continuous Deployment - Continuous Delivery, но автоматический (релизы деплоятся на лету).

    Пример программы для непрерывной интеграции: TeamCity, Jenkins - сервера непрерывной интеграции.
            
    СI / CD - сокращение для Continuous Integration и Continuous Delivery

****************************************************
Ковариантность — это сохранение иерархии наследования исходных типов в производных типах в том же порядке.

Контравариантность — это обращение иерархии исходных типов на противоположную в производных типах.

Инвариантность — отсутствие наследования между производными типами.

Массивы в Java ковариантны. Тип S[] является подтипом T[], если S — подтип T.
****************************************************
