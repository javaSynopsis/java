Масштабирование

Вертикальное — это когда добавляют больше оперативки, дисков и т.д. на уже существующий сервер,
а горизонтальное — это когда ставят больше серверов в дата-центры, и сервера там уже как-то взаимодействуют.
****************************************************
Project Management Methodologies

Первое что нужно знать это то, что на собеседованиях к этому относятся серьезно.
Второе это то, что определений и методов управления проектами очень много и все не выучишь.
Полный список методологий:
    https://www.tutorialspoint.com/management_concepts/project_management_methodologies.htm

Agile (Agile Software Development) - философия разработки продукта. Принципы: «Люди и взаимодействие важнее процессов и инструментов. Работающий продукт важнее исчерпывающей документации. Сотрудничество с заказчиком важнее согласования условий контракта. Готовность к изменениям важнее следования первоначальному плану».

Виды реализаций Agile (популярные):
    1. Scrum - это «подход структуры»
    2. Extreme Programming (XP)
    3. Kanban - это «подход баланса»

Waterfall - старая модель разработки. Делится на:
    1. Plan (планирование ВСЕГО проекта)
    2. Build (разработка)
    3. Test
    4. Review
    5. Deploying
    
Недостатки Waterfall:
    1. планирование должно быть закончено до того как начнется работа
    2. планирование сделано до того как проект будет понят
    3. по ходу разработки проекта проблемы с Build, Test, Review и Deploying вызывают постоянные изменения в Plan
    
Scrum
    1. Ключевые роли:
        1. Product Owner - объявляет фичи, которые нужны на проекте
        2. Scrum Master - защищает продукт и проект, поддерживает цикл разработки
        3. Development Team - тестеры, разработчики и всех остальных
    2. Цикл разработки, процесс, sprint:
        1. Plan - начальный план с минимальными фичами (КУСОК проекта)
        2. Build - только этот начальный набор функций
        3. Test $ Review - получаем маленький ГОТОВЫЙ продукт, ПОТЕНЦИАЛЬНО УЖЕ можно в релиз
    3. Типы документации (artefacts):
        1. Product Backlog - задачи, описание фич которые должны быть реализованы и их приоритеты
        2. User stories - описание фич пользователями. Пользователи как бы говорят: As a ... , I need ... , So that ...
        3. Spring backlog - список User stories с высоким приоритетом (т.е. то что должно быть сделано раньше). Каждая добавленная фича оценивается
        4. Burndown chart - график завершенности задач из Spring backlog, когда все закончено == 0
    4. Типы meetings (ceremonies, discussions):
        1. Spring Planning - Product Owner, Scrum Master и Development Team обсуждают User stories и оценивают их
        2. Daily Scrum - обсуждение того что сделали с предыдущего митинга, и какая помощь нужна
        3. Sprint Review (and retrospective) - обсуждение в конце Sprint, демонстрация работы и обсуждение
        4. Sprint Retrospective - то же что и Sprint Review, только обсуждение что улучшить в САМОМ процессе работы
        
Плюсы Scrum: в конце каждого цикла получаем готовый продукт, процесс разработки легко адаптируется.
    
Sprint или Sprint Cycles (от 1 до N) - единица цикла в Scrum. Обычно длится 1-3 недели. Sprints повторяются пока продукт не будет готов.

Kanban - Его задача – сбалансировать разных специалистов внутри команды и избежать ситуации, когда дизайнеры работают сутками, а разработчики жалуются на отсутствие новых задач.
Для визуализации agile-подходов используют доски: физические и электронные.
Главный показатель эффективности в kanban – это среднее время прохождения задачи по доске. Задача прошла быстро – команда работала продуктивно и слаженно. Задача затянулась – надо думать, на каком этапе и почему возникли задержки и чью работу надо оптимизировать.
Скорости работы команды нету - считается только скорость реализации задачи.
Вверху столбца - самая приоритетная задача.

Правила Kanban: 
    1. есть Plan, его приоритет или он сам может быть изменен
    2. Количество задач стоящих перед разработчиками ограничено

Столбцы на доске Kanban (по которым продвигаются листочки задач):
    Цели (goals)
    Очередь задач (story queue)
    Проработка архитектуры (Elaboration acceptance)
    Разработка (development)
    Тестирование (Test)
    Реализация (Release)
    Закончено (Done)
    
Цифра под столбцами доски Kanban - число задач могущих быть одновременно в столбце.
Рекомендуется ограничивать WIP (work in progress), число одновременных задач.

Expedite - место на доске для срочных задач, отдельная очередь. Выполняется всей командой. Может быть ОДНА такая задача.

Extreme Programming (XP) - легкая методология для маленьких или средних команд, которые сталкиваются с неясными быстро меняющимися задачами.

Принципы Extreme Programming:
    Feedback: TDD, The planning game, on-site customer, Pair Programming
    Continual Process: Continuous Integration, Code Refactoring, Small Releases
    Code understanding: Simple Design, Collective Code Ownership, System Metaphor, Coding Standards
    Work conditions: 40 h week
    
Принципы Extreme Programming коротко:
    Все работают на кодом, тестированием планированием вместе, плотно общаются с заказчиком.
    Релизы короткие, commits частые, рефакторинг постоянный.
    Из-за частых commits система fully integrated (целостна), это результат Continuous Integration (непрерывного объединения кода в единый проект).
    
Ко всем методологиям можно добавить определения:
    Continuous Integration - авто билд и тест приложения когда новый код запушен в ветку

    Continuous Delivery - Continuous Integration + Deploy приложения по клику на кнопку (релиз в прод частый, но по требованию).

    Continuous Deployment - Continuous Delivery, но автоматический (релизы деплоятся на лету).

    Пример программы для непрерывной интеграции: TeamCity, Jenkins - сервера непрерывной интеграции.
            
    СI / CD - сокращение для Continuous Integration и Continuous Delivery

****************************************************
CSRF/XSRF (Cross-site request forgery) token - token отправляется одним из параметров запроса, у каждого пользователя свой используется чтобы проверить можно обрабатывать запрос на сервер (если token верный) или нет. Угроза: если CSRF token не будет, то любой сможет отсылать value для input на сервер (и др. данные)
    - CSRF token может быть полем форму, частью http referer, содержаться в спец. http header
    - CSRF token не передают в адресе, а только в теле запроса. Следовательно используют только для методов которые изменяют данные на сервере (POST, PUT, DELETE). Методы GET, HEAD не изменяют данные и не имеют тела запроса, для них не нужен token.
    
CSP - запрещает внедрять в страницу inline скрипты, использовать eval(), разрешать запросы для js со страницы только к выбранным доменам.
****************************************************
- BFS можно реализовать рекурсивно или стек+цикл
- DFS можно реализовать рекурсивно или очередь+цикл
****************************************************
Factorial

 static int factorial(int n){    
  if (n == 0)    
    return 1;    
  else    
    return(n * factorial(n-1));    
 }
****************************************************
Fibonacci Series

 static int n1=0,n2=1,n3=0;    
 static void printFibonacci(int count){    
    if(count>0){    
         n3 = n1 + n2;    
         n1 = n2;    
         n2 = n3;    
         System.out.print(" "+n3);   
         printFibonacci(count-1);    
     }    
 }    
 0 1 1 2 3 5 8 13 21 34
 ****************************************************
 Сортировка пузырьком
 
 Массив проходится N-1 раз.
 За каждый проход попарно сраниваются элементы и меняются местами, если один больше другого.
 
 timsort - самая крутая, несколько алгоритмов сортировки использование которых зависит от условий
****************************************************
Поиск зацикленности в списке

есть классический алгоритм, когда по списку пускаем 2 указателя, один за шаг переходит на 1 элемент вперед, 2-й - на 2 элемента вперед.
При проходе 2-м проверяем, если он указывает на тот-же объект, что и первый - значит цикл есть.
****************************************************
Временная сложность алгоритма поиска в дереве поиска

****************************************************
перевод из 2-ой системы в 10-ую: 01101001 = 2^0 + 2^3 + 2^5 + 2^6 (степени)
перевод из 10-ой системы в 2-ую: делим число на 2 и записываем остатки от деления справа на лево (остатки будут 1 или 0). Эти остатки и есть число.

перевод из 10ой в 16ую: делить на 16, записать 10ный остаток в виде 16го числа, повторять пока остаток не станет 0, записать 16ые числа справа на лево
перевод из 16ой в 10ую: заменить числа на десятичные и каждый порядок умножить на 16 в степени равной прядку: E7A916 = 14×16^3+7×16^2+10×16^1+9×16^0

общая формула перевода в систему счисления, где an - первая цифра, a0 - последняя:
    C = an * M^n + an-1 * M^(n-1) + ... + a1 * M^1 + a0 * M^0
****************************************************
1. простой цикл выполняется от O(n)
    Примерами этого являются исчерпывающий поиск, поиск максимального элемента в массиве и генерация контрольной суммы.
3. Алгоритм двоичного поиска O(lg(n))
    КАЖДАЯ ПОЛОВИНА ПРОСМАТРИВАЕТСЯ ОТДЕЛЬНО, если речь о двоичных алгоритмах поиска и подобных
4. Алгоритмы, разбивающие входные данные на разделы, работающие независимо с двумя половинами O(nlg(n))
    Пример: сортировка слиянием, поиск как при бинарном поиске O(log n), но повторяется для каждой половины n раз, общая скорость O(n*log n)
5. Вложенные циклы. O(m*n) - квадратичное время
    пример: пузырьковой сортировки
6. Комбинаторика n! или n^n и больше?
        задача о коммивояжере, об оптимальной упаковке предметов в контейнер, о разделении набора чисел таким образом, что сумма каждого отдельного набора одинакова и т. д
        
O(1) - лучшее время (без циклов)
O(sqrt(n)) - почти как O(log n)
O(e^x) - экспоненциальное время
****************************************************
Корректность (Consistency)
    Говорит о том, что система всегда выдаёт только логически непротиворечивые ответы. То есть не бывает такого, что вы добавили в корзину товар, а после рефреша страницы его там не видите.
	
Доступность (Availability)
    Означает, что сервис отвечает на запросы, а не выдаёт ошибки о том, что он недоступен.
	
Устойчивость к сбоям сети (Partition tolerance)
	Означает, что распределённая по кластеру система работает в расчёте на случаи произвольной потери пакетов внутри сети.

+Availability +Consistency -Parition tolerance
	- система из одного узла, не распределенная и доступная всегда
+Consistency +Partition tolerance -Availability
	- распределенная, чтение доступно всегда, а запись только если транзакции уже завершились (не в процессе)
	- т.е. досткпность блокируется на время транзакции
+Availability +Partition tolerance -Consistency
	- распределенная, всегда доступна, но данные по кластеру распостраняются не сразу и какое-то время после записи возвращаются старые данные
	- зато система доступна всегда
	
Availability часто важна, т.к. из-за простоя теряются деньги
****************************************************
ACID - это 4е свойства которыми характеризуется транзакция.

1. Atomicity - берет набор операция и оборачивает их в unit of work, они успешны тогда и только тогда когда успешны все операции. transaction может хранить state change (если она не read only). transaction всегда должна оставлять систему в consistent состоянии, не смотря на то сколько transaction выполняются одновременно.
2. Consistency (Согласованность) - каждая успешная транзакция по определению фиксирует только допустимые результаты (Keys, Data types, Checks and Trigger). Если database состоит из нескольких node, то тут выполняется C из CAP и это не тоже C что в ACID. И означает это С, что изменения распространяется на все nodes (это называется multi-master replication). Например, при переводе денег между счетами, сумма денег на счетах не должна измениться.
3. Isolation - Прячет uncommitted state changes (данные которые транзакция еще не сохранила и они в процессе обработки) от других транзакций, достигается через pessimistic or optimistic locking. Но locks плохо влияют на параллельное выполнение. Некоторые DB реализуют MVCC.
4. Durability - в случае поломок система после запуска продолжит работу с места где начала, достигается через запись операций в transaction log и восстановления их оттуда в случае поломок (для некоторых режимов, например read only может отключаться transaction log для повышения скорости работы). Для JMS транзакции не обязательны, хотя и применяются по необходимости. Для файловых систем транзакции обычно не применяются, но если нужно транзакционно обмениваться файлами можно использовать утилиты такие как XADisk.

Atomicity - обязательный атрибут транзакций (т.е. оно должно выполняться для любой транзакции), остальные свойства можно обменять на масштабируемость (scalability) или производительность (performance). Т.е. отключить их выполнение или понизить количество их срабатываний и следовательно дополнительные операции, которые они выполняют.

Настроить durability (отключить или понизить точность) имеет смысл для highly performing clustered databases, если система не требует транзакций которые durability, в остальных случаях ее лучше не трогать.

Isolation (I из ACID) можно обменять целостность данных на производительность.

Транзакция - это коллекция read/write операций, успешных только если все операции в коллекции успешно завершены. Или еще называют процессом переноса данных (состояния) - data state transition. Поэтому транзакции должны быть выполнены последовательно (serial) даже если они выполняются параллельно (concurrently executed).
Транзакция должна собрать параллельные requests (от клиента), т.к. serialization влияет на scalability (видимо имеется ввиду чтобы оптимизировать процесс серийного выполнения параллельных транзакций их нужно с начало собрать и уже потом оптимизировать).

multi-master replication - техника записи изменений на другие ноды и решения конфликтов такой записи. Если запись в slaves (зависимые) nodes (узлы, копии DB или независимые части этой DB) выполнится asynchronously, то сломается consistency. И система становится eventually consistent.

В SQL каждая команда выполняется внутри transaction, даже если transaction не запущена явно. Это называется autocommit.

При этом система должна работать как буд-то последовательно не смотря на параллельность транзакций (in a serial form) это называют serializability. (прим. возможно serializable isolation level это означает выстраивание операций в серию?). На этот процесс влияет Закон Амдала

Современные нагруженные системы проектируются из предположения, что ситуации конфликта параллельных транзакций (phenomena) происходят всегда и даже самые простые системы могут обрабатывать 1000 TPS.

В большинстве DBs Isolation достигается через lock, но lock увеличивает количество кусков кода которые будут выполнены последовательно (serializable) и следовательно влияет на параллелизм программ. Некоторые DBs используют MVCC (видимо тут имеется ввиду, что вместо lock могут использоваться более новые механизмы вроде MVCC)
****************************************************
гексагональная архитектура
****************************************************
Конечный автомат (машина состояний, state mashine) - это компьютерная программа, которая имеет характерные черты:

    В основе лежит модель поведения
    Модель поведения имеет несколько последовательных состояний
    Состояния связаны между собой в виде цепочки переходов, которая может иметь линейную или ветвистую структуру (обычно представляют в виде графов)
    Переходы между состояниями порождают действия
    Цепочка состояний имеет одно начальное состояние, ветвление осуществляется за счет условий переходов
    Условия переходов должны быть описаны таким образом, чтобы из каждого конкретного состояния модель имела лишь одно следующее состояние

Пример:
Множества состояний (START, BOTTOM_FIXED, TOP_FIXED, UNFIXED, FINISH)
Множества событий (каждое событие состоит из набора условий, например, “панель влезает в экран и пересекла точку старта”)
Описания переходов (Событие + Некоторое состояние => Новое состояние)
Действия для каждого состояния (например, “зафиксировать панель сверху” при переходе в состояние TOP_FIXED)
Начального состояния (в нашем случае START)

Самый простой конечный автомат
class Switcher {
    public Boolean state = false; //true - is on, false - is off
    public void next() {
        if (this.state) {
            this.state = false;
        } else {
            this.state = true;
        }
    }
}

****************************************************
refreshtoken
hash table
B-tree
красно черное дерево
Поиск пути дейкстры
Поиск пути A*
элементы дискретной математики