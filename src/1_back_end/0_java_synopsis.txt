Новое:
    class в int: int.class
    один ли объект class у всех одинаковых объектов?

    ? практика с простыми sql запросами (количество пользователей с определенным количеством записей той же табл)
    уровни изоляции с примерами перевода денег (какой бы выбрали кроме serializable), случаи для применения уровней изоляций
    ? точно thread local storage используется для propagation levels???
    ? default методы следствия ввода лямбд чтобы можно было использовать их в уже реализованных коллекциях???
    + private static поля доступны static вложенным классам? - да
    
#### Заметки о Java
***
О том, из чего состоят объекты Java. (лучше глянуть статью, статья про Java 6 в новой может быть по другому!)
Также там хорошо описано сколько места занимают коллекции и их эффективность!

Если коротко: разница между простым типом и классом в том, что в классе кроме значения
хранится и мето информация: имя класса, флаги состояния, указатель синхронизирован или нет, хэши, размер (в случае массива).
В итоге размер класса в 4 раза больше чем размер простого типа.
(если тип массив, то указатель например на int[])

В 64битной версии потребление памяти увеличивается, сильно. Но засчет сжатия указателей обычных объектов
что-то удается сэкономить (опция -Xcompressedrefs)

Пример для int, Integer, int[]:
	Просто тип int: значение (32 бит)
	Класс Integer: указатель на class, флаги, блокировки, значение (224 бит)
	Массив int[]: указатель на class, флаги, блокировки, значение, размер (228 бит)
http://www.ibm.com/developerworks/ru/library/j-codetoheap/
****************************************************
идентификатор - имя переменной, начинается с букв, _ и $, может содержать цифры
	(c JDK 8 не рекомендуется использовать САМ? знак подчеркивание _ )
	нельзя использовать true, false и null
	
литералы - 'x', "hello", 100, используются для постоянных значений
	int x = 07; - восьмиричный
			0xA или 0Xa - шеснадцатиричные (регистр не значит)

целочисленные литералы по умолчанию int,
можно явно указать long (L или l) 0xfffffffffL

можно присваивать long литералы и меньшим типам,
но только если они укладываются в их диапазон
char ch = 88L;

(с JDK 7) можно использовать двоичные литералы
int x = 0b1001; (B или b)

(с JDK 7) при компиляции подчеркивания игнорируются (любое количество)
их нельзя ставить вначале или конце
int x = 123_345___123; float x = 12_2.3_34F;

литерал с плавающей точкой по умолчанию double (можно излишне указать D или d)
double x = 1.6E+10; (E или e)
float x = 1.5F (F или f) - float указывается явно

16 ричные литералы с плавающей точкой обозначаются p вместо e
0x12.2P4 == 0x12.2 * (2 * 2 * 2 * 2);
(4 - "двоичные порядок" - степень числа 2 (2^4) на которое умножается число 0x12.2)

new Double(1/0.).isInfinite(); //true
new Double(0/0.).isNaN(); //true
****************************************************
Типы
примитивные типы не наследуются от Object
целые (целых чисел без знака нету,
		если нужно изменить состояние старшего бита, то "сдвиг вправо без знака")
			длинна обозначает не объем занимаемой памяти, а поведение
	(8 штук)
	byte	8		-128..127
	short	16		-32768..32767
	int		32
	long	64
с плавающей точкой
	float	32		1.4e-045..3.4e+038
	double	64
символы (тоже целочисленный)
	char	16		положительные значения
логические
	boolean 1bit (true/false не преобразуются в 1/0)
	
короткие типы всёравно расширяется до int в выражениях,
поэтому часто int эффективнее short или byte

в char хранятся символы Unicode,
ASCII символы 0..127
ISO-Latin-1 - 0..255
отрицательных значений в char нету

можно делать так char ch = 88; - код символа,
можно использовать в арифмитических операциях

Символьные литералы char
\uxxxx - шеснадцатиричный код символа
\ddd - восьмиричный код символа
\' и \" - кавычка
\\ - косая черта
\t - tab
\n
\b - возврат на 1 позицию
\r - возврат каретки
\f - подача страницы

Символьные литералы String
String s = "dffvdcv\nsdsa";
String строка должна начинаться и заканчиваться на одной строке
(переноса строк нету)

//сравнение дробных чисел
System.out.println("|f3-f4|<1e-6: "+( Math.abs(f3-f4) < 1e-6 ));
1e-6 == 1 / (10)*(-6); //аналогичная запись

****************************************************
Преобразование типов

числовые типы в том числе с плавающей точкой АВТОМАТИЧЕСКИ
приводятся друг в друга, ЕСЛИ целевой тип БОЛЬШЕ
int i;
boolean b;
i = b;//правильно
b = i;//ошибка

АВТОприводимости В char или boolean не существует
но ИЗ char есть
char ch = 88;
int i = 2 + ch;

принудительное приведение
byte b;
int i;
b = (byte) i; // b = i % sizeof(byte) если i>byte иначе b = i
если i больше типа byte, то b будет == i % byte (остатку от деления на размер типа)

при приведении дробного типа к целому отбросится дробная часть

продвижение типов при автопреобразовании
byte > short/char > int > long > float > double
****************************************************
При создании массива int a[] = new int[10];
он будет автоматически проинициализирован
численные - нулями
бул - false
ссылочные (объекты) - null

<<<описать instanceof>>>

Все массивы реализованы, как объекты - т.е. это ОБЪЕКТЫ
все они имеют переменную length.
a.length - длинна массива

массив ссылок, кот. ещё надо про инициализировать:
int a[] = new int[3];

массив с резервированием памяти по столбцы и их задание позже
int a[][] = new int[2][];
int a[1] = new int[3];
int a[2] = new int[5];

new int[] {1, 2, 4}; анонимный массив

new int[3]; //ошибка, если массив ничему не приравнен (или не в функции), для массивов объектов также
int arr = new int[3]; //правильно

В Java можно создать пустой массив.
И если нужно вернуть пустой массив, не нужно создавать объект каждый раз, а просто - return EMPTY_ARRAY;
private static final String[] EMPTY_ARRAY = new String[0]; //EMPTY_ARRAY.length == 0
int i[] = {}; //тоже пустой массив
Можно вернуть пустой List, в отличии от new List<>() в этот List ничего НЕЛЬЗЯ добавить (immutable)
Collections.emptyList()

System.arraycopy(source, 0, destination, 2, source.length); - копирование содержимого массива в другой массив, работает быстро

Увеличиваем длину, а затем вставляем элемент используя java.util.Arrays.copyOf:
    arr = Arrays.copyOf(arr, N + 1);
    arr[N] = element;
	
Arrays.toString(arr) // prints "[1, 2, 3]"
****************************************************
В циклах java не дает использовать long (почему???)

for (long i = 0; i < arr.length; i++) {} //ошибка
for (int i = 0; i < arr.length; i++) {} //правильно

Вот так можно использовать long
	for (Long value : values) { ... }
	
Ответ: т.к. переменная long слишком большая???
--------------
В index массивов тоже нельзя использовать long

Long arr = new Long[12];
long index = 0;
long tmp = arr[index]; // ошибка доступа по long

Java не может работать с массивами больше чем 2^31−1 (== 2 147 483 647) элементов (примерно 32 Gb).
То есть int не помещается также как и long. Это касается стандартных jvm. На самом деле int помещается, просто часть размера int уходит на служебные данные.
Максимальный размер массива:
    int[] x = new int[Integer.MAX_VALUE]; // error

    // Integer.MAX_VALUE - 8 == 2 147 483 639, зависит от JVM, отнимаем 8 потому что "Some VMs reserve some header words in an array"
    int[] x = new int[Integer.MAX_VALUE - 8]; // правильно

https://stackoverflow.com/a/27333948
****************************************************
операции

составные операции +=, /= и т.д. в Java быстрее обычных.

поразрядные операции можно применять только над целыми числами.
~ - не (инвертирует биты)
^ - xor (сложение по модулю 2)
& - и
| - или
>>
<<
>>> - сдвиг вправо с заполнением нулями

~42 + 1 == -42 //инвертировать биты и прибавить 1

(запомнить в какую сторону плывет головастик
-~1 == 2 //аналог ++1
~-1 == 0 //аналог --1

старший разряд - знак числа

при сдвиге << типов byte и short они расширяются до int:
    b << 2// 2 - int
это приводит к неожиданностям, а знак старшего бита "знаковый бит"
поэтому разряды будут заполняться единицами?
чтобы сдвинуть byte нужно превести его опять к byte
byte a = 64;
byte b = (byte) (a << 2); //1000_0000 стало 0000_0000

сдвиг << за 31(int) или 63(long) позицию единичного бита
делает число отрицательным (единичка становится в "знаковый" бит)

>> - сохраняет знак числа (самый левый бит, он заполняется прошлым содержимым)
1111_1000 >> 1 == 1111_1100

<< - на 1 позицию аналогично умножению на 2
>> - деления на 2

>>> - всегда вставляет 0 на позицию слева вне зависимости от знака (без знаковый сдвиг)

При выполнении >>> происходит расширения до int и перенос знакового бита
в 31 позицию. ОТ этого при таком сдвиге будут неожиданности.
byte d = (byte) 0xf1;
byte b = (byte) (d >>> 4); //преобразование в byte т.к. результат int

||/&& (условные) - false/true если первый операнд false/true (не вычисляя второй)
	наз. условные операции
	
для |/& (поразрядные) всегда выполняются оба условия - (c > d & c++) //c++ выполняется всегда

ratio  =  denom  ==  0 ? 0  :  num / denom;
в ratio заносится вычесленое значение
Тип значения выражений должен быть одинаков или совместный (приводимый?)
	и не может быть void

вывод числа в двоичном виде:
Integer.toBinaryString(124) - вывод числа в двоичном виде
или Integer.toString(100,2) //1100100
Integer.toString(100,8) - для восмиричной
Integer.toString(100,16) - шеснадцатиричной

****************************************************
switch при многих значениях эффективнее if
в case допустимы byte, short, int, char, enum
	начиная с jdk7 и String (но он медленнее обычных)
	одинаковых значений в case быть не может,
		и там не могут стоять выражения, только готовые значения

так можно:
while(a-- < b--);
for(int a, b; a < b; a++, b++){}

Object[][] objArr = new Object[3][5];
for (Object ob[] : objArr)
	for (Object elem : ob)

В цикле for( : ) { тут }
некоторые Exception могут подавляться, так как ошибки как в обычных циклах быть не может.
для таких случаев try не нужен и при компилции попросят его убрать

continue, break, return - операторы перехода
continue m1; break m1; - переход к метке
	(можно только если метка в этом же или внешнем? блоке)
return - передача вызвавшему объекту

if, switch (в блоке case), try (включая finally и catch)
	блоки со своей областью видимости
при этом созданные в этих блоках переменные с таким же именем, как переменные во внешнем блоке перекрывают внешние
int i = 3;
if (true) int i = 5;// i == 5

внешние блоки для методов - переменные класса
	в том числе static переменные
class A {
 int i = 5;
 static int j = 7;
 public void f1() {//i == 5; j == 7} 
}

return; без параметра можно применять только в ф-ях возвращающих void
void f1() { return; } //правильно
int f1() {return;} //ошибка

//НЕ ПРАВИЛЬНО, должны быть фигурные скобки (хз почему)
for(boolean i = false; !i; i = true)	int i = 0; 

В JDK8 можно явно передавать ссылку на this явно. Ранее он передавался только неявно.
Такое объявление не меняет сигнатуру метода.
(применяется только для анотирования таких параметров?)
class A {
	void f1(A this, int i){}
}

****************************************************
Классы

класс - это шаблон, тип данных, определение типа
объект класса - экзепляр, занимает конкретную область физической памяти

при создании массивов объектов вызывается конструктор по умолчанию в C++, но в Java это массив ссылок
Box b1 = null; // разрываем связь с объектом

тип возвращаемого конструктором значения - по умолчанию тип класса

метод класса
protected void finalize() - вызывается перед удалением объекта.
	не известно когда будет и будет ли вообще выполняться

class Stack {
	int stck [ J  new int [ lO ] ;
	int tos ;

	Stack ( ) {
		tos = -1 ;
	}
	void push ( int item) {
		if ( tos==9 )
			System. out . println ( "Cтeк заполнен . " ) ;
		else
			stck [ ++tos ]  item;
	}
	int рор ( ) {
		if ( tos < 0 ) {
			System. out .println ( "Cтeк не загружен . " ) ;
			return О ;
		}
		else
			return stck [ tos-- ] ;
	}
}

При перегрузке методов выбор происходит по имени метода, типу и количеству его аргументов
Если не обнаружено полного соответствия типу аргумента и типы совместимы выполнится авто преобразование
	(напр. int в double или Integer)
	иначе вызовется метод с точно с тем же типом, что передан, если такой метод существует
Это правило действует также для оболочек типов (напр. int для Integer)
class A {
	void f1(int i){}
	void f1(Integer i){}
}
new A().f1(1); //вызов void f1(int i){}
new A().f1(new Integer(1)); //вызов void f1(Integer i){}, а если f1(int) нету, то и в первом случае этот

Если разница только в ВОЗВРОЩАЕМОМ типе, то будет ошибка
void f1();
int f1(); //ошибка, метод уже есть
	
При перегрузке методов типы-параметры авто расширяются, но не сужаются
public void test(int i);
test(1L)//ошибка, тип больше int

Если в классе есть хотя бы 1 конструктор, то конструктор по умолчанию не вызвается
(при создании массивов этих объектов тоже)
class MyObj {
	MyObj(int i) {
	}
}
MyObj m = new MyObj(); //ошибка если конструктор без параметров не описан

При создании массива объектов НЕ вызывается конструктор по умолчанию. Создаётся массив ССЫЛОК.
MyObj arr[] = new MyObj[2];

Можно создать анонимный объект типа интерфейса
НО статические методы так не переопределить (они ДОЛЖНЫ работать всегда и их вообще нельзя сделать абстрактными)
(при СОЗДАНИИ АНОНИМНЫХ объектов типа интерфесов нужно САМОМУ писать слово public)
interface A {
  public void hello();
}
public class HelloWorld {
  public static void main(String[] args) {
    new A() {
      public void hello() {
        System.out.println("Hello1");
    }.hello();
  }
}
также с абстрактными классами
abstract class B {
  public void hello() {
    System.out.println("Hello2");
  }
}
public class HelloWorld {
  public static void main(String[] args) { 
    new B(){}.hello();
  }
}

в интерфейсах могут быть статические методы
interface B extends A {
  public static void hello() {
  	System.out.println("Hello");
  }
}

Если имена "методов по умолчанию" у интерфейсов СОВПАДАЮТ,
то ПРИ implements A1, A2 - будет ошибка
interface A1 { //и A2 такой же
  default void hello() {
  	System.out.println("HelloA1_D");
  }
}
НО если этот метод переопределен (реализован) в классе, то ошибки НЕ будет:
class C implements A1, A2 {
  public void hello() {
    System.out.println("HelloC");
  }
}

Конструкторы вызываются в порядке наследования (неявный вызов super() в конструкторе, он как бы идет первым оператором в каждом конструкторе, просто не показывается):
class A {}
class B extends A {}
//сначало A, потом B (родитель > потомок)


ИМЕНА переменных методов в родителе и наследнике могут отличаться - будет работать:
interface A {
	void f1(String aaa);
}
class B implements A {
	public void f1(String bbb){}
}
При реализации интерфейса слово public НУЖНО писать самому (см. пример выше) Иначе ошибка.

Доступ через this и имя класса
class C {
  int i = 5;
  void f1() {
	//(про похожий доступ во вложенных классах и простых иерфейсах ниже)
    //C.this.i == 5 работает ТОЛЬКО ВНУТРИ СВОЕГО класса
    //this.i == 5
    
}

В Java все методы виртуальные.
при переопределении использовать @Override. Она предназначена для компилятора, а не используется во время выполнения. Чтобы компилятор дополнительно следил - ты переопределил специально или хотел новый метод создать, а у базового класса такой уже есть?

this() - вызов конструктора в классе ВНУТРИ ДРУГОГО КОНСТРУКТОРА (НЕ МЕТОДА!). Служит для вызова ВНУТРИ ДРУГОГО КОНСТРУКТОРА класса.
	ОН ДОЛЖЕН быть первым оператором конструктора, как и super()
A (int t) {
	this();
}
такой вызов конечно НЕМНОГО МЕДЛЕННЕЕ, потому что происходит вызов разных методов и возвраты.
!!! В одном конструкторе нельзя одновременно использовать this() и super(). Т.к. они оба могут быть только первыми операторами конструкторов. При это использовать их в try{} тоже нельзя, т.к. try будет считаться первым оператором в конструкторе.
При таком вызове НЕЛЬЗЯ использовать переменные экземпляра класса этого конструктора!???

****************************************************
Приведение типов

Можно привести только больший тип к меньшему: наследника к предку. Или предка к наследнику, если предок уже указывает на наследника (производится проверка его осмысленности).
Ошибки приведения типов вылазят не при компиляции, а при выполнении!

class A {}
class B extends A {}
class C extends B {}

B b2 = (B) c; //правильно
b2 = (B) a;  //ошибка

НО приведение предку к наследнику работает! Если предок УКАЗЫВАЕТ на наследника.
class A{}
class B extends A{}
class C extends B{}

A o1 = new A();
B b1 = (B) o1; //ошибка, предка к наследнику нельзя

A o2 = new B();
B b2 = (B) o2; //можно, если по ссылке уже выделена память наследнику

A o3 = new C();
B b3 = (B) o3; //можно, если выделенной памяти больше и наследник входит в её подмножество

Преобразования ссылок на массивы разрешены лишь тогда, когда разрешены преобразования их базовых типов, а также нет конфликтов размерности (одинаковое количество элементов?).

Приведение типов обобщений
(Gen<Integer>) iOb //правильно, так как iOb уже Integer
(Gen<Long>) iOb //ошибка (видимо потому что предок которому не выделено памяти наследника)

Пример ф-ции для преобразования в указанный тип на основе класса.
1.
public static <T> T cast(Object o, Class<T> clazz) {
    return clazz.isInstance(o) ? clazz.cast(o) : null;
}
2.
public <T> ModelBin<T> getModelBin(Class<T> type) {
    return (ModelBin<T>) entities.get(type); // это работает потому что T не известен на этапе компиляции и поэтому нет ошибки
}
****************************************************
Модификаторы классов и полей по умолчанию:

class field/method/nested class - package local, non-final, non-static

enum and nested enum - package local, final and static

interface field - public static final

interface method - public abstract

nested class in an interface - public static, non-final

Note. Хотя enum в классе неявно static само слово static можно всеравно написать явно перед enum, но хотя оно еще и final само слово final написать явно нельзя.

При это единственное место где нужно использовать static с enum это при import static
	 import static my.embedded.EnumType.SOME_VALUE;
****************************************************
Заметки про уровни доступа. Протестированные случаи

Если пакет импортировать, то классы (и интерфейсы, перечисления и т.д.) которые НЕ public всёравно не будут видны - (нужно объявить public)
Если пакет импортировать и класс public, НО конструктор protected или package, то класс всёравно нельзя будет создать.
package m1;
public class A {
	protected A(){} // даже импортировав пакет класс нельзя создать вне пакета, конструктор не виден
}

Если метод/конструктор public, а сам КЛАСС НЕ public, то импортировать такой класс всёравно НЕЛЬЗЯ
class A {
	public A(){}
}

в файле должен быть только один класс или интерфейс - public
		если их будет два, то компилятор будет по очереди просить назвать файл, как public класс

Файл должен иметь ИМЯ такое, как и единственный public класс в этом файле, ЕСЛИ в файле есть public класс
Если в файле НЕТУ public методов, то файл может иметь любое имя.

В файле может не быть ни одного public класса (доступ по умолчанию package). В этом случаи их могут использовать только классы ВНУТРИ ПАКЕТА. При этом, если использовавший их класс - public, то он виден при импорте пакета и всё ОК.

Если имена классов совпадают можно указать пакет и класс напрямую
myPackage.List a = new myPackage.List();

-----------
Пример:
//файл 1
package m1;
class A {}
//файл 2
package m1;
class B extends A {}
//файл 3
package m1;
public class C extends B {}

package m2;
import m1;
class A {
	public static void main(String []args){
		C c = new C(); //правильно, виден public
		B b = new B(); //ошибка, не виден не public
	}
}
-----------

КЛАСС (НЕ метод) с main методом может не быть public (не знаю правильный ли это СТИЛЬ или нет, наверное нет)
	потому что класс из которого берется main можно выбирать командой запуска (myPackage.Main)

методов
public static void main(String []args)
может быть несколько, но так как при запуске программы указывается КОНКРЕТНЫЙ "главный" КЛАСС (НЕ файл) из которого и запускается этот метод, то проблем нету.
То есть в программе может быть несколько main методов в разных классах. При этом запустится тот метод main который указан в команде на запуск.
(и не важно public метод main или нет, а может и ВАЖНО - пробовал онлайн компилером)
package m1;
class A {
public static void main(String []args) {}
}
class B {
public static void main(String []args) {}
}
//создастся ДВА ФАЙЛА A.class и B.class
java m1.B //запустится метод main из B
java m1.A //запустится метод main из A

Файлов типа .class всегда создаётся по одному на КАЖДЫЙ класс. ДАЖЕ если в одном файле несколько классов и при этом один из них public

Пакет package можно объявить только 1 в файле и только в начале файла.

Импорт. Делается ПОСЛЕ объявления пакета. static импорт позволяет использовать static члены без названия класса
package m2;
import static m1.B.f1;
B.f1(); //было можно так при - import m1.B;
f1(); //стало так

НО если в классе уже есть метод с именем f1(), то он перекрывает импортируемый метод и через имя класса к нему доступ тоже не получить.
B.f1(); //ошибка, импортирован не класс, а только метод, но доступ к нему перекрыт (обратиться через имя класса нельзя)
import static m1.B.*; //импорт всех статических членов КЛАССА

В пакете могут быть только УНИКАЛЬНЫЕ имена для каждого класса. В том числе, если эти класс расположены В РАЗНЫХ файлах. (касается и НЕ public классов)
//файл 1.java
package m1;
public class B extends A {}
class A {}
//файл 2.java
package m1;
class A {} //ошибка, класс A уже есть в этом же пакете

****************************************************
static - это глобальные методы и переменные

методы:
могут вызывать только static методы
могут обращаться только к static переменным
не могут использовать this и super

вложенный static класс:
может иметь доступ только к static членам

Метод не может быть одновременно abstract и static
	- потому что он ОДИН на весь класс и всех его наследников

static переменные инициализируются в static блоке
в таком порядке выполняется:
class A {
	static int i = 4; // выполнится сначало 1
	static {
		i = 5; // выполнится потом 2
	}
}

Доступ к static переменной можно получить и через new и через имя класса
class C {
	public static int i = 6;
}
class A {
	public static void main(String []args) {
		System.out.println("Hello" + new C().i); //к static через new (работает как и через имя класса)
		System.out.println("Hello" + C.i); //к static через имя класса
		System.out.println("Hello" + C.this.i); //к static по имени и this
	}
}

К static члену можно получить доступ через this: this.i == 6; (изнутри класса??)
  а можно и по имени класса C.i == 6
  а можно и так: C.this.i == 6
  new C().i == 6

static методы в интерфейсе (до JDK8 их не было), описаны в разделе "интерфейсы"
В интерфейсах static методы обязаны быть реализованы и могут быть вызваны по имени интерфейса A.f1();
	НО они НЕ НАСЛЕДУЮТСЯ классами реализующими интерфейсы

****************************************************
abstract

Метод не может быть одновременно abstract и:
	private (потому что они не учавствуют в наследовании),
	synchronized (потому что синхронизированы методы класса на нём самом, т.е. на его this),
	native, static, final


НО можно синхронизировать abstract метод так, или через блок синхронизации:
public synchronized final void foo() {
    doFoo();
}
protected abstract void doFoo();	

Интерфейс может быть abstract, но это можно не указывать потому что он и так abstract
abstract interface A {
	static void f1(){System.out.println("hello");}
	void f2();
}


****************************************************
final

Если final ссылка на объект, то сам объект можно менять. Ссылку нельзя.
final MyObj myObj = new MyObj();
myObj.setSmth("test str"); //правильно, меняется содержимое объекта
myObj = new MyObj(); // ошибка, ссылка final

final class A {} //класс нельзя наследовать
	делает все методы класса неявно тоже final
	нельзя объявить класс одновременно final и abstract

class A {
	final int i = 5; // ЛИБО заполнить значение этой переменной в конструкторе
	final int j;
	void f1(final Object ob) { // в параметре
		final int m = 3; // локально
		j = 6; //так можно устанавливать final!
	}
}

методы final нельзя переопределить
	final методы могут встраиваться в точки вызова и вызывать на этапах компиляции, что приводит к ускорению программы (аналог inline методов в C++?)
	
Существуют переменные так называемы "ведущие себя как final".
То есть эти переменные могут быть использованы в некоторых функциях, где нужны final переменные,
но только если их значение не менять. (то есть это final без слова "final" перед ними и только)
Например: в повторном выбросе throw из catch могут быть такие.

final поля cчитаются именнованными константами, их можно использовать в switch (для int) или в if (для boolean)
final static int YES = true; - можно использовать в if??? (может boolean?)

final поля можно использовать в анонимных классах (см вложенные классы.)

****************************************************
Если есть final, то переменная уже не изменится. И для экономии компилятор может втиснуть переменную в меньший тип (например byte). То есть переменная становится byte неявно. И поэтому работает присваивание.
Предположение: Для типа long ошибка. Т.к. Java оперирует byte кодом размером 32 бит. И операции с long для нее дороги, поэтому она не втискивает его автоматически.

// error
short s1 = 1;
byte b1 = s1;

// error
final short s3 = 1;
char c1 = s3;

// compiled
final short s2 = 1;
byte b1 = s2;

// compiled
final int s1 = 1;
byte b1 = s1;

// error
final long s1 = 1;
byte b1 = s1;
****************************************************
inner (nested) классы и интерфйсы (вложенные и внутренние)

вложенные классы это closure (замыкания) т.к. они содержат ссылку на внешний контекст (this родительского класса)

Вложенный класс имеет доступ ко всем членам внешнего (в том числе private)
Внешний доступа к членам внутреннего не имеет.
class A {
	class B {}
}

Термины inner и nested имеют одинаковое значение. non-static nested классы иногда называют inner классами
Вложенны класс может быть: static и non-static.
	Тогда он НЕ МОЖЕТ получить доступ к НЕ static членам внешнего.
		(static классы применяются редко)
		
Для чего используются:
    static nested - можно использовать как helper используемый в связке с внешним классом, но независимый от него
        например: Calc.Operation.PLUS
    non-static nested - используется как Adapter, создаем inner класс, который имеет доступ к переменным внешнего класса, но при этом другая сущность
        например: Set.Iterator; Map's keySet, entrySet

Вложенны класс можно объявить внутри любого блока (метода, цикла, условия)
class A {
	class D {} //класс
	void f1() {
		class B {} //метод
		for(;;){ class C {} } //цикл
	}
}
Вложенный в БЛОК или МЕТОД класс может получить доступ только к final переменным или ведущим себя, как final. (о JDK8 см. ниже)
Вложенные в БЛОКИ и МЕТОДЫ классы НЕ МОГУТ быть static

Перекрытие переменных
Доступ к НЕ static членам внешнего класса из вложенного можно получить через имя класса (как для default метода в интерфейсе):
	A.this.x
При этом для САМОГО СЕБЯ static вложенный класс может использовать ссылку this
class A {
	int x = 1;
	class B {
		int x = 24;
		
		//x = 5 - параметр
		void f1(int x) {
			//this.x == 24
			//x == 5
			//A.this.x == 1
		}
	}
}

(static)
//к вложенному static доступ через имя
OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();

(non-static) - при создании inner класс имеет доступ к переменным внешнего класса, поэтому внешний класс нужно создать до создания внутреннего
class OuterClass {
    class InnerClass {}
}
OuterClass outerObject = new OuterClass();
//но ССЫЛКУ создать можно и без new
OuterClass.InnerClass innerObject = outerObject.new InnerClass();

private класс не виден снаружи и не удастся создать даже ссылку
class A {
	private class B {}
}
A.B b; //ошибка, private не виден

<<<Описать наследование обычным клссом вложенного класса (и static вложенного)>>>

Наследование вложенного класса:
	Проблема: вложенный класс имеет ссылку this на внешний. А класс который extends вложенный класс - уже нет.
	Решение: использовать конструктор классе-наследнике в который передать ссылку на внешний класс.
		В книге написано, что без такого конструктора программа НЕ СКОМПИЛИРУЕТСЯ!
class A { class A2{} }
public class B extends A.A2 {
	B(A a){ // конструктор с ссылкой на внешний класс
		a.super(); // необходимо потому что конструктор по умолчанию не подходит?
	}
}
new B(new A()); //создание

Вложенные интерфейсы
class A {
	public interface B {}
}
class C implements A.B {} //использование

Вложенный интерфейс может быть static
<<<описать для чего нужен вложенный static интерфейс и в чем отличия>>>
Вложенный интерфейс может содержать вложенные классы, в том числе static. Может содержать вложенные интерфейсы.
Вложенный интерфейс НЕ может быть вложен в метод, цикл или условие,
	если вложенный класс внутри цикла, а интерфейс в этом классе, то так тоже нельзя (интерфейсы могут быть вложены ТОЛЬКО во внешние классы)
	class A {
		interface B{ interface B2{} } //правильно
		void f1() {
			interface B{} //ошибка
			class C {interface D{}  } //тоже ошибка
		}
	}

Вложенный класс нельзя сериализовать ОТДЕЛЬНО от внешнего
	(потому что он может обратится к членам внешнего, которых не будет)
Вложенный класс НЕ может иметь static члены, КОТОРЫЕ НЕ final
	но это не касается МЕТОДОВ, static методы быть не могут
Вложенный класс может иметь static члены, если он сам static
Вложенный static КЛАСС может иметь доступ только к static членам внешнего (методам и переменным)
class A {
	int i = 5; //внешняя переменная
	static int g = 5; //внешняя static переменная
	class B {
		int j = i; //правильно, доступ к внешним переменным
		static int v = 4; //ошибка, не static класс не может иметь static без final
		final static int x = 5; //правильно
		final static void f1(){} //ошибка, не static класс не может иметь static метод даже если он final
	}
	static class C {
		int x = 5; //правильно, обычные переменные может иметь
		static int v = 4; //правильно, может иметь static
		static int b = g; //может иметь доступ к внешней static ЧЛЕНАМ
		int a = i; //ошибка, из static КЛАССА к НЕ static ЧЛЕНАМ внешнего доступа нет
		static void f1(){} //правильно, static метод
		void f1(){} //правильно, обычный метод
		int j = i; //ошибка, доступа к внешним переменным НЕ static - нет
	}
}

При компиляции вложенных КЛАССОВ и ИНТЕРФЕЙСОВ они компилятся в файлы вида A$B.class (A - предок)
	(без разницы static они вложенные или нет)

Метод main может находится во вложенном классе
	Запуск: java p1.A$B (по сути A$B это имя скомпиленного .class файла)
	(ПРИЧЕМ классы могут НЕ быть public - всёравно найдет)
package p1;
class A {
	static class B {
		public static void main(String []args) {
			System.out.println("Hello");
		}
	}
}


Начиная с Java 8:
	вложенные классы в блоках могут получить доступ к переменным внешнего БЛОКА
		объявленным НЕ ТОЛЬКО как final, а теперь И К РАБОТАЮЩИМИ КАК final (effectively final,
			обычным переменным не меняющим своего значения)
	вложенные в методы классы могут получить доступ к параметрам МЕТОДАМ (метода в который они вложены?)
		объявленным НЕ ТОЛЬКО как final, а теперь И К РАБОТАЮЩИМИ КАК final (effectively final,
			обычным переменным не меняющим своего значения)

Чтобы словить ошибку нужно ещё подгодать случай в котором переменная изменяется - не final
class D {
	void f1() {
		java.util.Random r = new java.util.Random();
		int j = r.nextInt(5);
		if(j > 0) {
			j = r.nextInt(5);
		}
		class B {
			int i = j; //ошибка, j не final или не ведет себя как final
		}
	}
}

Можно наследовать static класс non-static классом.
class A {
    static abstract class B{}
    class C extends B{}
}

<<<Вложенные классы наследуются? - да>>>

non static definition class недоступен из static метода
public class Main {
    class A {}
    public static void main(String args[]) { A a = new A(); } // ошибка, доступа к A нет, т.к. мы в static методе и объект нельзя создать
}
public class Main {
    static class A {}
    public static void main(String args[]) { A a = new A(); } // правильно, доступ к static class есть
}

в java после определения внутренних можно поставить точку с запятой, но стилистически это не правильно, по крайней мере в правилах стиля ide Idea
public class Main {
    static class A {}; // точка с запятой, правильно, но лучше не ставить для соблюдения стиля кода
}

в java inner enums это static по умолчанию
public class Test {
    public enum Enum1 { A, B }			// неявно static 
    public static enum Enum2 { C, D }	// static
}
****************************************************
Аргументы переменной длинны
Работает с JDK5

переменная переменной длинны должна БЫТЬ В КОНЦЕ
может быть ТОЛЬКО ОДИН ПАРАМЕТР ПЕРМЕННОЙ ДЛИННЫ
static void f1(String s, float f, int ... arr){ //arr - массив
	for (int i : arr) {}
}
f1("", 1.2, 2,4,5,5,6);

можно не использовать этот параметр вообще, а функция всеравно сработает
void f1(String s, int ... arr);
f1("abc", 3, 5, 6); // можно так
f1("abc"); // и можно так

перегрузка:
void f1(int x) //вызовется если аргумент 1, но если этого метода нету, то с одним аргументом вызовется и второй
void f1(int ... x) //вызовется если аргументов > 1

ошибка при перезгрузке:
void f1(int ... arr)
void f1(boolean ... b)
f1(); - ошибка при вызове, и то, и то может работаеть без параметров

void f1(int i, int ... arr)
void f1(int ... b)
f1(1) // тоже ошибка, компилятор не знает что вызвать

Если в аргумент переменной длинны не поставлены параметры, то он как пустой массив int i[] = {};


****************************************************
super

есть две формы
super() - для вызова конструктора предка, его вызов ДОЛЖЕН БЫТЬ ПЕРВЫМ В КОНСТРУКТОРЕ подкласса
	При это использовать их в try{} тоже нельзя, т.к. он будет считаться первым оператором в конструкторе.
И super() может находиться ТОЛЬКО В КОНСТРУКТОРЕ
В одном конструкторе НЕ МОГУТ быть одновременно this() и super()! Т.к. они оба должны быть первыми операторами.
class A {
	A() {
		super();
	}
}

вызывается неявно первым оператором конструктора подкласса
ПО УМОЛЧАНИЮ вызывается конструктор предка БЕЗ ПАРАМЕТРОВ
class A {
	A() {
		//здесь как буд-то super();
	}
}

class A {
	A (int i, double d) {}
}
class B extends A {
	B (int i, double d) {
		//по умолчанию super()
		super(i, d); // поэтому так
	}
}


class A {
    A(){}
    A(int i, int d){}
}
class B extends A {
    B() {
        super();
        super(2, 3); //ошибка, два super нельзя, потому что он должен быть ПЕРВЫМ оператором в конструкторе
        System.out.println("123");
    }
}


Вторая форма super работает, как this и вызывать в методах можно
используется когда имя члена подкласса перекрывает член супекласса
class A {
    private int i = 1;
    int j = 2;
}
class B extends A {
    int i = 3;
    
    B() {
        System.out.println(super.i); //Доступа к private НЕТУ
        System.out.println(super.j);
        System.out.println(i);
        f1();
    }
    
    void f1() {
        System.out.println(super.i);
    }
}

****************************************************
String

int charAt(i) - i-ый char
boolean equals(str)
int length()

String(new String("qwe"));

new String("qw").length() - длинна строки (с единицы)

byte - можно хранить символ в кодировке ASCII 8bit
char - юникод 16 бит
int - расширенный юникод 32bit

String(new char[]{'a', 'b'}, int индекс_начало, int индекс_конец);
String(byte[]{65, 66, 67}, int индекс_начало, int индекс_конец);
String(int[]{65, 66, 67}, int индекс_начало, int индекс_конец);

При создании String из массива он копируется. И при изменении String сам массив не меняется.
Содержимое String не может быть изменено. Но может поменяться сама ссылка на строку.

CharSequence (интерфейс)
	реализуют:
		String() - final нельзя преопределить
		StringBuilder - final нельзя преопределить
		StringBuffer - final нельзя преопределить

String(StringBuilder)
String(StringBuffer)

Содержимое String не может быть изменено. Но может поменяться сама ссылка на строку.
Для изменения или создают новую String или используют StringBuffer или StringBuilder

static String.valueOf(примитивный_тип) - для примитивных типов строку из них
					- для объектов результат toString()
					- для массивов строку описывающую тип массива
static String valueOf(char[] arr, int индекс_начала, int количество_символов)
- для массива char[] строку из всех символов
					
					
s.charAt(i) - один char

void getChars(int начало_источника, int конец_источника, char[] адресат, int начало_адресата);
	- много char
	- конец_источника -- номер символа после последнего
void getBytes(...)

char[] toCharArray() - в массив char[]

boolean equals() и equalsIgnoreCase() - сравнение строк
s.equals(s2);

boolean regionMatches(boolean игнорировать_регистр, int индекс_начала, String строка2, int индекс_начала_строки2, int количество_символов);
	- как equals только сравнение кусков строки
s.regionMatches(true, 0, s2, 0, 3);

startsWith() - совпадает ли начало строки со сравниваемой
"Foobar".startWith("Foo"); //true
endsWith() - тоже только для конца
boolean startsWith(строка, int индекс_начала)
"Foobar".startsWith("Foobar", 3) //true

int compareTo(String str) - сравнение строк с чётом регистра
-1 - меньше
0 - равно
1 - больше
этот метод реализованный Comparable<T> используется в сортировках
int compareToIgnoreCase(String str) - сравнение без учета регистра

int indexOf() - индекс первого вхождения символа или подстроки
int lastIndexOf() - последнее вхождение символа или подстроки
-1 - если не найдено совпадение
"abc".indexOf('b') //== 2
int indexOf(String str, int индекс_начало_поиска_включительно)
int indexOf(int ch, int индекс_начало_поиска_включительно)
int indexOf(char ch, int индекс_начало_поиска_включительно)
	- начинает поиск с указанного индекса

String substring(int начальный_индекс, int конечный_индекс)
	- возвращает кусок строки
	- конечный_индекс - индекс символа после последнего???
	
String concat(String str) - соединяет строки

String replace(char что, char чем)
String replace(CharSequence что, CharSequence чем)
	- замена всех символов или строк другими
"Hello".replace('l', 'v') //== Hevvo

String trim() - удаляет пробелы вначале и конце строки
"  sds  ".trim() == "sds"

//есть они же но с выбором Locale параметра для типа локализации от которого что-то зависит
String toLowerCase()
String toUpperCase()

//метод String.intern()
new String("Hello") == new String("Hello") //== false
new String("Hello").intern() == new String("Hello").intern() //== true ЕСЛИ s1.equals(s2) == true
	Все строки-константы, которые встречаются В КЛАССЕ (поля класса) автоматически интернированы.
	Их НЕ НУЖНО intern()
(Зачем: при интернировании строк можно получить преимущество в использовании памяти, т.к. вы храните в ней лишь один экземпляр)

С JDK8:
1.
static String join(CharSequence разделитель, CharSequence ... строки)
str = String.join(", ", "Alpha", "Beta");
//Alpha, Beta
2.
вторая форма join() соединяет строки из объекта реализующего Iterable

boolean contains(CharSequence str) - true если вызывающая строка содержится в объекте
"abc".contains("c") //true

String[] elements = { "one", "two", null, "four" };
// Call skipNulls.
String result = Joiner.on('+').skipNulls().join(elements);

isEmpty() - проверка на пустоту

String relaceFirst(String regexp, String str)
	- первое совпадение с регуляркой заменяется
Strign relaceAll(String regexp, String str)
	- тоже только для всех
	
String[] split(String regexp)
	- разбивает на массив 
String[] split(String regexp, int максимум)
	- максимум - максимальное количество частей
	
CharSequence subSequence(int начало, int конец)
	- возвращает подстроку

	
--StringBuffer
Если размер буфера не указан, то резервируется 16 символов, чтобы не перераспределять память. Чтобы снизить фрагментацию.
	(то есть 16 символов для всех кроме варианта с указанным размером буфера)
StringBuffer()
StringBuffer(int размер_буфера)
StringBuffer(CharSequence строка)
StringBuffer(String строка)
	
new StringBuffer("Hello")
	//размер буфера 5 + 16 = 21
	

int length() - количество символов
int capacity() - объем памяти

ensureCapacity(int минимальная_ёмкость) - задание размера буфера после создания объекта, нужно если будет вставка большого количеством мелких символов
	(буфер меньше минимального_размера может быть всёравно выделен если это эффективно)
	
setLength(int длина) - если длина строки меньше текущей, то невместившиеся символы обрезаются.
	если длина увеличивается до вконец ставятся пустые символы

void setCharAt(int индекс_куда, char ch)
	- вставка символа на место
append(String) - склеивает строку
append(int) - для примитивных типов
append(Object)

insert(int позиция_куда, String) - вставляет строку на заданное место
также работает для Object и примитивных типов

reverse() - обращает символы

delete(int индекс_начала, int индекс_конца) - удаляет заданный кусок
	- индекс_конца -- символ после последнего удаляемого

deleteCharAt(int индекс_начала) - удаляет с позиции и до конца
sb.deleteCharAt(0)

StringBuffer replace(int нач_индекс, int конечный_инекс, String str)
	- замена заданной строки
	- конечный_инекс -- символ после последнего

trimToSize() - обрезает буфер чтобы он по размеру был ближе к текущему количеству символов	

StringBuilder появился в JDK5
	такой же как StringBufer но не синхронизирован

****************************************************
Object - предок всех объектов в Java, в том числе массивов (т.к. это тоже объект)

методы:
Object clone() throws CloneNotSupportedException - создаёт клон
boolean equals(Object object) - сравниваем объект
protected void finalize() - вызывается перед удалением объекта
final Class<?> getClass() - класс объекта во время выполнения
int hashCode() - хэш объекта; адрес объекта в памяти, если метод не реализован. Используется в разных структурах на основе хэшей (HashMap, HashSet etc)
String toString() - возвращает строку при выводе в поток
					при выводе в поток берется он вызывается автоматически, строка из этого метода - System.out.println(myObj);

final void notify() - возобновляет работу потока синхронизированного на объекте (или любого одного, если остановленных много)
final void notifyAll() - тоже для всех потоков
final void wait() - останавливает поток на объекте
final void wait(long милисек.) - останавливается, максимальное время остановки
final void wait(long милисек., int наносек)

****************************************************
Пакеты и интерфейсы

Все файлы могут располагаться в любом месте. При компиляции будет создана структура каталогов, как описаны пакеты в файлах .java

package m1; //должна быть первой строчкой в .java

Если пакет не указан, то используется пакет по умолчанию, он не удобен.
Поэтому в Java обычно создают корневой пакет package by.my;

package m1.m2.m6; // иерархия пакетов

программа может найти пакет (в них файлы .class):
	в переменной среды CLASSPATH
	по путям указанным командой -classpath
	
Глубина вложенности пакетов не ограничена (только файловой системой)

Все стандартные классы Java находятся в - package java;
Компилятор неявно импортирует во все программы import java.lang.*;


Импорт

	package m1; //import идет после package
	import m1.m2.*; //импорт всех классов
	import m1.m2.m3.A; //импорт одного класса
	import static m1.PI // импорт статического ЧЛЕНА класса

	new m1.A(); //создание класса без импорта, прямым указанием пакета
	class D extends java.util.Date {} //или при наследовании

Если при импорте совпадут имена классов из разных импортируемых пакетов
	(если класс не создавать ошибка не проявит себя)
	НО если совпавший класс не использован, то ошибку не покажет
import m1.A;
import m2.A;
то ошибка проявится только при создании этого класса
new A(); //ошибка
new m2.A(); //правильно


//пакеты могут иметь аннотации
/**
* documentation comments...
*/
@Annotation1(...)
package sample;

<<<Описать package-info.java>>>

****************************************************
интерфейсы

ИНТЕРФЕЙСЫ не связаны с иерархией КЛАССОВ,
	классы не связанные друг с другом могут реализовывать один интерфейс
т.к. в Java один класс может наследовать ТОЛЬКО один класс, то таких классов становится всё больше
это изолирует программу от того, ЧТОБЫ МЕТОДЫ И ДАННЫЕ НЕ БЫЛИ ДОСТУПНЫ ОГРОМНОМУ ЧИСЛУ ПОДКЛАССОВ

public interface A {
	//неявно public final static и ДОЛЖНА быть инициализированна
	public final static int MY_MY = 3; //в подклассе static переменная с таким же именем ПЕРЕКРОЕТ эту???
	//неявно public
	public void f1();
}

class C implements A, B {} //можно реализовывать больше одного интерфейса
реализованные методы интерфейса в классе ДОЛЖНЫ быть public


Если методы в интерфейсах A и B совпадают
interface A {void f1(int i);}
interface B {void f1(int n);}
То этот метод могут использовать по ОБЕИМ ссылкам
A a = new C(); B b = new C();
a.f1(); b.f1();

interface A {}
interface B extends A {} //наследуем интерфейс

Начиная с JDK8:
1) появились методы по умолчанию
Зачем нужно: не нарушает старый код, потому что реализовывать новые методы не обязательно
				становится не нужно реализовывать пустые методы, которые не используются
				по прежнему нельзя создавать объекты типа интерфейса и объявлять не static переменные ("сохранять состояние")
interface A {
	default void f1() {System.out.println("не реализован");} //не обязательно реализовывать в наследнике
															//часто используется исключение UnsupportedOperationException
}
interface B extends A {
	default void f1() { System.out.println("HelloB"); } //переопределяет метод на свой
}
new B(){}.f1(); //HelloB

Пример
interface A {
	default void f1() { System.out.println("HelloA"); }
}
interface B extends A {
	void f1(); //перекроет default метод из A и его НУЖНО переопределить в классе (как без default)
}

Если один метод по умолчанию перекрывет другой метод,
	то его можно вызвать через super и в классе, и в интерфейсе по имени интерфейса + super
		Так A.super.f1();
interface A {
	default void f1() { System.out.println("HelloA"); }
}
interface C extends A {
	default void f1() { A.super.f1(); } //вызов f1() из A
}
class B implements A {
	public void f1() { A.super.f1(); } //вызов f1() из A
}

2) static методы в интерфейсе (до JDK8 их не было)
Эти методы НЕ НАСЛЕДУЮТСЯ ни классами, ни интерфейсами!!!
	Соотв. метод не может быть default static одновременно
Такой метод ОБЯЗАН быть реализован, нельзя оставлять пустым.
interface A {
	static void f1() { System.out.println("HelloA"); }
}
A.f1(); //вызов

****************************************************
Интерфейсы-маркеры
	Это так же паттерн
	Это интерфейсы без методов. Используются как методанные.
	
То есть это просто метка.
Для определения есть ли интерфейс используется instanceof
До аннотаций вероятно они использовались как методанные.

Работа с интерфейсами-маркерами часто быстрее чем рефлексия.

Причем интерфейс-маркер может быть ещё и ссылкой. Видимо память объекта от этого не уменьшается и его можно использовать?
writeObject(Serializable s)

java.lang.Cloneable
java.io.Serializable
java.util.RandomAccess
java.rmi.Remote

****************************************************
уровни доступа

для членов:
public - доступны везде
	может понадобится импорт пакета, если в пакете
	или полное имя new m1.Date()
package - только в пакете, но всем в нём
protected - всем в пакете и наследникам
private - только текущему класс
			но в том числе к членам ДРУГИХ объектов этого же класса
			
Для классов:
package - виден только внутри пакета
			сколько угодно классов в файле,
public - виден всем
			может быть только один такой класс на файл и имя файла должно совпадать с именем класса
			
При наследовании уровни доступа можно только РАСШИРЯТЬ, сужать - ошибка
class A {
	public void f1(){}
	void f2(){}
}
class B extends A {
	protected void f1(){} //ошибка, сужение доступа
	protected void f2(){} //ОК, protected шире чем package
}
			
Если класс public, а конструктор не виден наследнику (private, package),
	то создать наследник в другом месте (откуда нет доступа к конструктору предка) - НЕЛЬЗЯ
	но если НЕ ПИСАТЬ конструктор совсем (кнструктор по умолчанию) - то всё ОК (работает, как public)
package p1;
public class A {
	A(){} //конструктор виден тольо в пакете
}
package p2;
class B extends A {} //ошибка, конструктор package из A не виден в др. пакете

//с консткторами по умолчанию - всё ОК
package p1;
public class A {}
package p2;
class B extends A {}

Класс может иметь доступ к private членам внутри себя других объектов ЕГО ЖЕ САМОГО
class A {
	private int i = 2;
	A(A a) {
		new A().i; //i == 2 - правильно
	}
}


****************************************************
Исключения

типы:
1) Не перехватываемые. Генерятся при ошибках в Java или ограничения в JVM (зависит от её реализации)
2) Генерятся кодом программ

Есть: checked и unchecked исключения

void f1()
	throws Exception {
	
	new throw Exception(){}; //выкиниться из метода во внешний блок
	
	try(OutputStream os = new OutputStream(); //try с ресурсами
		OutputStream os2 = new OutputStream()
	) {
		new throw ArithmeticException(){}; //попадет в блок catch
		return; //эта строка не выполнится, т.к. пойдет выполнение в catch
	} catch (Exception e) {} //сюда попадет и ArithmeticException т.к. ссылка родителя может указывать и на наследника
	catch (Exception e) {} //сюда не дощло, обработано в catch выше
	finally {} //выполнитя всегда, даже после return в try
}
исключения через throws могут выбрасывать методы и конструкторы.

try позволяет обрабатывать ошибки не завершая программу.
Пустой try{}catch{} - объявить можно
В try должен быть ХОТЯБЫ ОДИН catch ИЛИ ЖЕ finally: try{}finally{} - тоже правильно
finally {} всегда должен стоять ВКОНЦЕ try (после catch)
finally может быть ТОЛЬКО ОДИН на try

Если идет несколько блоков catch, то тип исключений сравнивается с каждым в нем. Если тип совпал остальные catch после него пропускаются.

Иерархия исключений:
	Throwable //корень (сам переопределяет Object?)
		Exception //пользовательские, от него наследовать при создании своих исключений
			RuntimeException //(непроверяемое) деление на ноль, выход за границы массива ...
		Error //(непроверяемое) ошибки среды, не перехватываются как правило
Не обработанные исключения попадают в обработчик по умолнию. Он прерывает работу программы! Который выводит его описание и трассировку стека.

Исключения встроеннные в java находятся в java.lang;
Небольшой список:
ArithmeticException - деление на нуль
ArrayindexOutOfBoundsException - выход за границы массива
NullPointerException - нулевой указатель
throw new IllegalArgumentException("Illegal rate: " + rate); - если нужно показать ошибку в аргументах
см. полный список в Шилдте

Пользовтаельские исключения правильно наследовать от Exception. Не обязательно реализовывать что-то в подклассах, достаточно имени и описания.
Метод String toStrring() тоже можно переопределить, например убрать выводимое по умолчанию имя исключения.

В Throwable переопределен метод toString() и в нем описание ошибки
Если создать своё исключение
throw new Exception("описание ошики"); //строка поподает в toString() после имени исключения
class MyExc extends Exception {
	MyExc() {
		super("описание ошики"); //поподает в toString()
	}
}

throws - список типов которые выбрасываются наружу метода, а не обрабатываются в нем
throws НЕ ОБЯЗАТЕЛЬНО ОБЪЯВЛЯТЬ для Error и RuntimeException и их наследников
void f1() throws Exc1, Exc2 {}

throws могут быть и в методах интерфейса
interface A {
	void f1() throws Exception;
}

В throws можно объявлять не только выбрасываемые исключения ТЕХ ЖЕ САМЫХ типов, но и просто совместимые.
	то есть из того же метода можно выбросить любого наследника исключений из throws
	(напр. предки исключений)?
class B {
	void f1()  throws Exception  {
		throw new IOException(); //выбрасываем наследника исключения из throws
	}
}

throws исключения в переопределенных методах могут только сужаться. Исчезнуть совсем или быть наследниками типа исключения выбрасываемого в переопределяемом методе.
class B {
	void f1()  throws Exception, MyException {}
}
class C extends B {
	void f1()  throws IOException {}
}

методы:
final void addSuppressed(Throwable t); //добавить в список подовляемых, обычно для try с ресурсами
Throwable fillInStackTrace(); //возвращает объект содержащий трассировку стека, его можно throw повторно
Throwable getCause(); //возвр. исключение на котором основано текущее, или null если его нету
String getLocalizeMessage() //возвр описане исключения
String getMessage() //возвр описание исключения
StackTraceElement[] getStackTrace() //возвр массив объектов StackTraceElement, каждый элемент содержит описание (часто пути)
									//на вершине стека метод в котором было throw исключени (первый элемент массива)
									//StackTraceElement дает доступ к данным о каждом элементе, напр. имя метода
final Throwable[] getSuppressed() //возвр. массив подавленных исключений
Throwable initCause(Throwable th) //связывает исключения с его исключением-причиной (можно задать самому), возвр. ссылку на него
void printSackTrace() //вывот трассировку стека
void printStackTrace(PrintStream ps) //направляет вывод стека в поток вывода
void printStackTrace(PrintWriter ps) //направляет вывод стека в поток вывода
void setStackTrace(StackTraceElement ste[]) //устанавливает трассировку стека для знных элементов (обычно не исп.)
String toString()

В JDK1.4 добавлены цепочки исключений:
Исключение добавляется в основное исключени. И выводится в описании, как его причина.
	Используются когда настоящая причина исключения другая, но возникает на другом уровне, а вывести хочется на этом.
		Причина может быть установлена ТОЛЬКО ОДИН РАЗ
		(напр. ошибка деления на ноль это следствие ошибки потока ввода-вывода, а выводим обе в одном месте)
		сначало выводится исключение, а потом его исключение-причина
//эти же конструкторы есть в Exception, Error, RuntimeException (можно исрользовать getCause и initCause)
Throwable(String описание, Throwable причина)
Throwable(Throwable причина)

getCause и initCause можно использовать в устаревших классах, где нет таких конструкторов
e.initCause(new ArithmeticException)

В JDK7:
1) try с ресурсами, при этом переменные из try считаются final
	try(FileOutputStream fin = new FileOutputStream("name");
		FileOutputStream fin2 = new FileOutputStream("name")) {
	} catch(Exception e) {}
	Исключения закрытия в этом случае не исчезает, но его не надо обрабатывать так как оно добавлено в список подовляемых (Suppressed).
	НО в некоторых случаях эффективнее обычное закрытие файлов.
2) повторное генерирование исключения, переменные В _НИХ_ (не при обычном catch) НЕЯВНО считаются final (но можно и дописать final вручную)
	ислючение должно БЫТЬ final ИЛИ ИСПОЛЬЗОВАТЬСЯ КАК final (быть НЕЯВНЫМ)
	ИСПОЛЬЗУЕТСЯ например для логирования (в одном catch лог, потом кидается дальше и во втором - перехват)
	Список исключений которые МОЖНО повторно выбросить ограничен теми исключениями, которые выкидываются в его родном try
		Суть в том что в Java 7 компилятор более умным способом вычислят типы ожидаемых checked exception.
	
	void method() throws Exception{ //Задача компилятора узнать какое исключение выкидывает метод,
									//чтобы обязать програмиста указать тип этого checked исключения.
		try{
		  throw new IOException(); //Здесь происходит что-то что выкидывает исключение
		}catch(Exception e){
		  throw e; //Здесь мы ловим что попало, например для логирования. А потом выбрасываем дальше. Это и есть Re-throw.
		}
	}
	---
	try{
		try{
		  throw new Exception(); 
		}catch(Exception e){
		  throw e;  //Вот тут мы вроде как выкидываем общий Exception.
		}
	}catch(IOException e){
	  log(e); //Но в Java 7, мы здесь можем поймать внутрений IOException, так как компилятор выведет его тип, ведь внутренний блок никаких других исключений не кидает
	}
	---
	НЕ РАБОТАЕТ ТАК, повторное исключение вываливается только во внешний блок или из метода throws
	try { throw new Exception("A"); }
		catch(Exception e) { System.out.println(e + " 1"); throw e;}
		catch(Exception e) { System.out.println(e + " 2"); } //ошибка! re-throw исключение в блок ниже не попадает! идет во внешний блок 

3) многократный перехват
	если в catch перехватывается больше одного типа (многократный перехват),
	то исключение final или должно вести себя как final (нельзя менять объект исключения в catch)
		catch(ArithmeticException | ArrayindexOutOfBoundsException e){} //e - final 

Некоторые методы требуют окружения try т.к. они могут выбросить исключения (у них есть throws)

try считается ОДНИМ оператором, то есть тут после while не нужны фигурные скобки {...}
while(cond)
	try {
		System.out.println("before");
		System.out.println("after");
	} catch(InterruptedException e) {
	}

****************************************************
многопоточность

состояния (6 штук):
	готов к выполнению, когда получил время CPU (создание Thread?)
	выполняется (запуск start)
	приостановлен (sleep?)
	возобновлен (notify?)
	ожидает освобождения ресурса, заблокирован (wait?)
	прерван, прерванный поток нельзя восстановить (interrupt? или конец метода run())

переключения контекста:
	поток может уступить ресурсы другому потоку самостоятельно (приостановившись и т.д.)
	может быть приостановлен jvm на основе приоритета - вытесняющая многозадачность
	
Монитор - черный ящик, который может исполнять только 1 поток одновременно.
У каждого объекта Java имеется свой неявный монитор вход в который идет автоматически, когда для объекта вызывается синхронизированный метод.
	Когда один поток находится в теле синхронизированного метода, ни один другой поток не может вызвать ни один другой синхронизированный метод для того же объекта (синхронизированный на том же объекте).
	
Обмен сообщениями потоков - это методы для работы с потоками (notify(), wait() и т.д.) В других языках обмен происходит средствами операционной системы.

В Java класс Thread инкопсулирует поток. И всё общения с потоком происходит через этот класс и объект этого класса.

Главный поток - поток нчинающий работу при запуске программы. Обычно в нём перед завершением программы производятся разные действия, поэтому он должен завершаться последним.
	Если главный поток завершается раньше дочерних, то JVM может зависнуть.
Главный поток по умолчанию имеет имя main. Имя выводится через toString() (в поток, println(thread))
Приоритет главного потока по умолчанию - 5
Группа потоков к которой относится Главный поток тоже называется main

Приоритет потока используется особенно, когда есть потоки которые захватывают весь ЦП, ему пониают приоритет, чтобы дать другим возмость работать.
Приитет от 1 до 10 (MIN_PRIORITY - MAX_PRIORITY)
	приоритет по умолчанию - 5 (NORM_PRIORITY)
	эти переменные из класса Thread и они static final

Методы Thread:
Thread(String name)
Thread(Runnable r, String name)
public static Thread currentThread() - ссылка на текущий поток
final String getName()
final void setName(String name)

final Boolean isAlive() //true - поток рабоает, false - завершен
final void setPriority(int level) //установка приоритета потока
final int getPriority()

static void sleep(long ms) throws InterruptedException
static void sleep(long ms, long nano) throws InterruptedException
public void run()
start()
final void join() throws InterruptedException //вызывающий поток ожидает когда указанный поток "присоеденится к нему" (завершится)
join(ms)

interrupt() //прерывает выполнение потока
isInterrupted() //

статические методы Thread
interrupted() //проверяет на прерванность текущий поток
currentThread() //
activeCount() //возвращает количество потоков текущей группы
yeild() //приостанавливает текущей поток чтобы позволить работать остальным
sleep()

Для создания потока нужно создать объект Thread
	1. реализовать интерфейс Runnable и передать его параметром в конструктор new Thread(r).start()
		реализовать метод public void run() {} - код в этом методе и составляет поток, а сам метод точка входа в поток
			и вызвать метод start(): new Thread(new Runnable(){...}).start();
		Поток завершится, когда run() возвратит управление
		Для запуска в классе нужно создать объект Thread и вложить туда реализованный Runnable
			в месте где создаётся Thread объект фактически начинается выполнение потока
	2. расширить класс Thread
		чтобы создать поток нужно переопределить метод public void run() {} и вызвать в классе метод start()
			new Thread(Thread(){start();...}){...}
			
Для создания потоков исполнения лучше использоват Runnable чтобы избавиться от наследования других классов, т.к. в Java можно наследовать только 1 класс

Никогда не изестно как поведет себя приоритет потоков.

При использовании JVM с вытесняющей многозадачностью возникают разные нюансы.
Лучше использовать потоки, которые добравиольно уступают друг другу ресурсы.	

Синхронизация.
Монитор - используется чтобы кусок кода мог одновременно выполнять только один поток. (взаимоисключающ блокировка)
ВХОД в монитор - запрос потоком блокировки
		другие потоки пытающиеся захватить монитор будут приостановлены, пока ВОШЕДШИЙ в монитор поток не ВЫЙДЕТ из него
			поток ВЛАДЕЮЩИЙ монитором может повторно войти в этот же монитор
			остальные потоки ОЖИДАЮТ МОНИТОР
			
У каждого объекта в Java есть монитор неявно связанный с ним.
	То есть когда что-то синхронизированно на мониторе привязанном к объекту, то поскольку у каждого экземпляра класса свой монитор, то этот монитор уникален (к объекту привязан конкретный монитор, созданный при создании объекта и именно к нему привязана синхронизация).
		Так как synchronized привязано к this: synchronized(this){ ... } то никакой другой поток не может исполнить этот метод ЭКЗЕМПЛЯРА потому что монитор для каждого экземпляра свой и привящан к нему через this.

Когда поток в теле синхронизированного метода, то все другие ПОТОКИ ИЛИ СИНХРОНИЗИРОВАННЫЕ методы не имеют доступа к этому методу КОНКРЕТНОГО ЭКЗЕМПЛЯРА класса.

Один синхронизированный метод может быть вызван из другого синхронизированного метода
	Это называется "re-entrant mutex". Т.е. в Java если поток уже вошел в монитор, то он не обязан ждать освобождения монитора собой же.
	(не отпуская монитор вызываем метод в котором тот же монитор)
//методы разные, монитор тот же
void method1() {
    synchronized (this) {
        method2()
    }
}
void method2() {
    synchronized (this) {
    }
}

synchronized прминима только к методам.

Блок synchronized (this) {...} часто используется когда нету доступа к коду класса, который нужно синхронизировать. Тогда его вызов оборачивают в эти блоки.

Если в потоках используется какой то совместный ресурс, например List<String> list = new List
то доступ к нему должен быть синхронизирован:
	synchronized (this) { list.blabla(); }
	synchronized (list) { list.blabla(); } //правильно???
Вместо синхронизации можно использовать потокобезопасные коллекции
	
Всегда нужно узнать потоко-безопасный класс (строки, потоки, например) или коллекция с которым работаешь или нет.
Коллекции и их потокобезопасные аналоги
HashMap 		ConcurrentHashMap
TreeMap 		ConcurrentSkipListMap
TreeSet 		ConcurrentSkipListSet
Map subtypes 	ConcurrentMap
List subtypes 	CopyOnWriteArrayList
Set subtypes 	CopyOnWriteArraySet
PriorityQueue 	PriorityBlockingQueue
Deque 			BlockingDeque
Queue 			BlockingQueue

Взаимодействие потоков
реализовано final методами notify(), notifyAll(), wait() в Object
	они все могут быть вызваны ТОЛЬКО в synchronized блоке
	(методы wait(), join и sleep должны быть окружены блоками try)
	
	wait() - входим в монитор, останавливаем поток, пока другой поток вошедший в этот монитор не вызовет notify()
		перед возобновление ожидающего потока поток ждем пока поток вызвавший notify() не выйдет из монитора!
		поток вызвавший wait() останавливается в месте её вызова, а после возобновления продолжает выполнения с места остановки в мониторе
	wait(ms) - с макс. временем ожидания
	notify() - возобновляет поток из которого был вызван метод wait()
		если остановленных потоков несколько, то возобновится 1 любой
		но пока находится в мониторе другие потоки синхронизированные на том же мониторе ждут пока он закончит блок
	notifyAll() - тоже только для всех потоков
	
Методы которые есть, но нельзя использовать (depricated):
stop()
suspend()
destroy()
resume()
countStackFrames() - в нем вызываются suspend и destroy
	
В конструкторе метод wait лучше не вызывать? Т.к. объект ещё не создался, а он связан с потоком.
	
Метод wait останавливает поток, но возможен случай ЛОЖНОЙ АКТИВАЦИИ, когда поток начинает работать без вызова notify()
	Поэтому wait вызывается внутри цикла с условием, чтобы в случае возобновления он опять остановился
Реализация start/stop:
	static Object sync = new Object();
	static boolean cond = true;

	static void stop() {
		cond = true;
		synchronized(sync) {
			while(cond)
				try { sync.wait(); }
				catch(InterruptedException e) {}
		}
	}

	static void start() {
		cond = false;
		synchronized(sync) {
				sync.notify();
		}
	}

Поток 1 выполняет:
	static void f1() {
		synchronized(sync) {
			while(cond1)
				try {
					System.out.println("before wait");
					sync.wait(); //засыпает на этом месте
					System.out.println("after wait"); //когда проснется И ПОЛУЧИТ монитор начнет отсюда
				} catch(InterruptedException e) {
				}
		}
	}
Поток 2 выполняет:
	static void f2() {
		synchronized(sync) {
			System.out.println("before notify");
			cond1 = false;
			sync.notify(); //пробудил Поток 1, но мешает ему войти в монитор (сам занимает монитор)
			System.out.println("before notify"); //выполнил эту строку и вышел из монитора, освободил место для Поток 1
		}
	}
Результат: 
	before wait //Поток 1 остановился на wait()
	before notify //Поток 2 запустил Поток 1, но занимает пока монитор сам и Поток 1 ещё ждет освобождения монитора
	before notify //Поток 2 выполняет synchronized блок до конца
	after wait //Поток 1 получил монитор и продолжает с места, где остановился
	
Состояние потока
	Состояние потока может изменить ПОСЛЕ получения статуса, поэтому его нельзя использовать для синхронизации потока.
Thread.State getState(); //State это enum
	BLOCKED - ожидает монитор
	NEW - ещё не запущен
	RUNNABLE - выполняется, или будет выполнятся когда наступит его очередь (по приоритету)
	TERMINATED - завершен
	TIMED_WAITING - поток временно преостановлен с таймером (sleep(222), wait(333), join(2222))
	WAITING - wait и join без таймера
Thread.State ts = t.getState();
boolean state = ts == Thread.State.RUNNABLE;

//синхронизация статического метода
synchronized static void f1() { }
synchronized(MyObj.class) { ... }


<<Также есть встроенный механизм синхронизации concurrency>>

Пример с join
		Runnable r = () -> {
				System.out.println("qwe");
		};
		Thread t = new Thread(r);
		t.start();
		try {
			
			t.join(); //main ожидает пока не завершится поток
		} catch(Exception e){}
		
		
Потоки-демоны в Java (копировано с сайтов)
	//true - Thread поток завершится, когда main Thread завершится
	//false - Thread продолжит работу даже если main Thread завершится
	t.setDaemon(true); //устанавливатеся перед start()
	t.start();

****************************************************
Перечисления - список именнованных констант

Появились в JDK5

перечисления реализованы в виде класса
enum MyEnum {
	A, B, C, D;
}
члены перечисления - константы перечисляемого типа, они public static final
	члены это ОБЪЕКТЫ перечисления
конструктор перечисления - может быть только private или package!

перечисления нельзя создать через new, в остальном ведут себя как обычные классы
MyEnum mE = MyEnum.A;
mE == MyEnum.A; //true
switch(mE) { //тип перечисления ДОЛЖЕН быть один и тот же
	case A: //ДОЛЖЕН указыватся без имени класса
}
System.out.println(Apple.Winesapp);//выведет Winesapp

public static тип_перечисления [] values() //возвращает массив констант перечисления
	MyEnum mE = (MyEnum.values())[0]; // == MyEnum.A
public static тип_перечисления valueOf(String) //возвращает константу перечисления с данным именем

Каждая константа это объект своего класса
	перечисление может реализовывать интерфейсы
enum My implements MyInteface {
	A(0),B(5), C("str");
	
	private int j;
	
	My(int i){ j = i; }
	My(String str){}
	
	void f1(){}
}
My.A.f1(); //вызов из объекта

ОГРАНИЧЕНИЯ.
	Перечисление не может быть суперклассом И не может наследовать другой класс
	НО оно МОЖЕТ реализовывать интерфесы
	
Хотя перечисления не могут наследовать класс пользователя, они наследуют класс Enum c методами
	все вызванные методы должны принадлежать к одному типу перечисления
	
	final int ordinal() //возвращает порядок константы на которой вызван, номерация с 0
	final int compareTo(тип_перечисления enum) //сравнивает порядковые НОМЕРА констант, возвращает -1, 0, 1
	
	equals(Object obj) //возвратит true только если константы совпали,
		хотя можно вызвать для всех объектов true будет только при совпадении констант перечислений
	
	== - можно сравнить ссылки на перечисления

****************************************************
оболочки типов
DouЫe, Float, Long, Integer, Short,
Byte, Character  и  Boolean
все числовые типы наследуются от Number

Оболочки медленнее обычных типов. Но им можно применять в коллекциях.

char charValue() и т.д. используются чтобы достать значение их оболочки

new Boolean("true") //для других строк будет false
new Integer("1001") //можно и строкой

Автоупаковка появилась в JDK5

Упаковка позволяет использовать оболочки в switch

<<<написать про кэши автоупаковки>>>

****************************************************
Анотации
	появились с JDK5
	Используются в кодогенераторах и разработке.
	
С JDK8 можно использовать анотации не только над объявлением типов данных (напр. описание класса или метода)
НО и над использованием. То есть анотации над объектами и ссылками.


интерфейс AnnotatedElement реализуется в классах Method, Feild, Constructor, Class, Package
	методы:
	Annotations[] getDeclaredAnnotations() - возвращает массив аннотаций объявленных только в анотируемом объекте, НО не его наследниках.
	То есть аннотации объявленные в предках как правило наследуются наследниками?
	
Аннотации неявно наследует интерфейс java.lang.annotation.Annotation, но не может наследовать extends другие интерфесы
	переопределяются методы:
		hashCode()
		equals()
		toString()
	добавлен
		Class<?> annotationType() //возвращает вызывающую аннотацию


Уровни удержания?		
//java.lang.annotation.RetentionPolicy
	SOURCE - аннотация видна только в исходнике (напр. для аннотации по которой генерируется документация)
	CLASS (по умолчанию, если не указано) - только во время компиляции в файле .class
	RUNTIME - доступны во время компиляции и после неё в программе (файл .class)
	НО аннотации локальных переменных НЕ ВИДНЫ в .class никогда
	
@Retention(RetentionPolicy.RUNTIME) //встроенная анотация
@interface MyAnnot {
	String str();
	int val();
}

@MyAnnot(str = "test1", val = 3)
public void f1() {}

Одну и ту же аннотацию ПО УМОЛЧАНИЮ НЕЛЬЗЯ использовать над одним объектом, ЕСЛИ она не объявлена повторяемой (т.е. можно ставить несколько одинаковых аннотаций). (см. ниже о повторяющихся)

Методы или поле должен быть public чтобы анотацию можно было получить. ДАЖЕ если рефлексия объекта используется внутри него самого.
	ИНАЧЕ скомпилится, но будет выдавать ошибку. (почему?)
НО класс может быть и НЕ public
@MyAnno
class A {
	@MyAnno
	protected void f1() {
		Class<?> c = new A().getClass(); //правильно
		MyAnno = c.getMethod("f1").getAnnotation(MyAnno.class); //ошибка, методы f1 НЕ public
	}
}
<<<НО взять private как-то можно.>>>
		

Аннотации используются в инструментах разработки. Через рефлексию.
java.lang.reflect
Как получить анотацию:
	Получить final Class<?> getClass() с описание класса
		из Class вызвать методы для получения описания его членов
			getMethod(), getField() и getConstructor()
			Method, Field и Constructor
			Method  qetMethod(Strinq имя, Сlаss<?> ... args) //ТО ЕСТЬ аргументы задаются String.class, int.class
		из Class, Method, Field и Constructor получить объект описывающи анотацию
			<A extends  Annotation> qetAnnotation (Class<A> тип_анотации)
			//ЕСЛИ анотация не найден, ТО вернет null

import java.lang.annotation.*;
import java.lang.reflect.*;
@MyAnnot(str = "test1", val = 3)
class A {
	A a = new A();
	
	@MyAnnot(str = "test2", val = 3)
	void f1() {
		try {
			Class<?> c = a.getClass();
			Method m = c.getMethod("f1");
			MyAnnot myAnnot = m.getAnnotation(MyAnnot.class); //MyAnnot.class - это объект Class с описанием
			System.out.println(" str " + myAnnot.str() ); // str == test2
		} catch (NoSuchMethodException e) {}
	}
}
!!! .class есть у примитивных типов (int.class, long.class, и т.д.), массиво (String[].class), класов, интерфейсов, аннотаций и т.д.
	НО это работает только если известно ИМЯ класса, а когда не известно то getClass()?

Интерфейс AnnotatedElement
	методы
		Annotation[] getAnnotations() //массив аннотаций объекта
		getAnnotation()
		Annotations [] getDeclaredAnnotations () //возвращает аннотации определенные ТОЛЬКО в данном объекте
												//НО не у его предка, то есть нету наследованных от предка аннотаций
		boolean  isAnnotationPresent (Class<? extends Annotation> тип_аннотации) //true если объект имеет данную аннотацию
	методы с JDK8:
		Annotations getDeclaredAnnotation(Class?) //аналог метода выше
		//для повторяющихся (несколько одинаковых над одним элементом) аннотаций берем их по типу
		getAnnotationsByType()
		getDeclaredAnnotationsByType()

		
@interface A {
	String str() default "test";
	int val();
}
@A(val = 1) //str по умолчанию == test
или @A(str = "my", val = 1)

Без параметров анотации можно указывать так:
@A()
@A
без разницы

Аннотация-маркер - анотация без членов
@interface Marker {}

Одночленная аннотация
@interface A {
	int value(); //с именем value - параметр по умолчанию
	String val() default "def";
}
@A(23)
@A(value = 23, val = "my")

Встроенные аннотации
	java.lang.annotation
		@Retention - только для других аннотаций, уровень распостранения
		@Documented - только для других анотаций, сообщает средству разработки, что аннотация должна быть документированна
		@Target(перечисление ElementType) - только для других аннотация, показывает на каких элементах может быть применена аннотация
		@Inherited - маркер, только у другим аннотациям и только к аннотациям применяемым над описанием классов
						если объявление аннотации помечено ей, то эта аннотация доступна в классе-наследнике
		с JDK8:
			@Repeatable - объявление повторяющиеся анотаций
			@Native //для полей доступных из кода зависящего от платформы (операционки, устройства)
	java.lang
		@Override - маркер для методов, чтобы компилятор знал что они должны быть перегружены.
						Если перегрузки нет будет ошибка. Писать не обязательно.
		@Deprecated - обозначает что ОБЪЯВЛЕНИЕ устарело и должно быть заменено новым
							/**
							 * 
							 * @deprecated Do not use this method!
							 */
							 @Deprecated
							 public String getName() {
								 throw new UnsupportedOperationException();
							 }
		@SafeVarargs - маркер для методов и конструкторов. Следует применять для параметров static или final переменной длинны.
							Показывает, что код безопасен, подавляет ненужные предупреждения. Применяется для обобщений и параметризованных массивов.
		@SuppressWarnings - подавляет предупреждения при компиляции. Имена преупреждения указывать в String
								@SuppressWarnings("warning name")
		с JDK8:
			@FunctionalInterface - маркер, пишется над интерфейсами. Обозначает что интерфейс функциональный (т.е. содержит только один абстрактный метод). Для лямбда выражений. Не обязательна.
		
Над какими элементами может быть применена аннотация
@Target({ElementType.FIELD, ElementType.PACKAGE})
@Target(ElementType.METHOD)

Перечисление ElementType:
	ANNOTATION_TYPE - аннотация
	CONSTRUCTOR - конструктор
	FIELD - поле
	LOCAL_VARIABLE - локальная переменная
	METHOD - метод: public @Recoпunended Integer fЗ(String str) {}
	PACKAGE - пакет: @PackageAnno package my;
	PARAMETER - параметры метода
	TYPE - класс, интерфейс или перечисление
	с JDK8:
		TYPE_PARAMETER - параметр типа (параметр обобщения)
			анотированный параметр обобщения
			class TypeAnnoDemo<@What (description  =  "Данные обобщенного типа" ) Т> {
		TYPE_USE - использование типа (анатируется ТИП), анатировать возвращаемый void нельзя
			 public @A Integer fЗ(String str) {} //тип возврата
			 (@A Integer) х; //аннотированное приведение
			 @A TypeAnnoDemo<Integer> оЬ2  = new @A TypeAnnoDemo<Integer> ( ) ; //new
			 class SomeClass extends @TypeAnno TypeAnnoDemo<Boolean> ( } //наследование
			 String @MaxLen(10) [] @NotZeroLen []  w; //анатируемые уровни доступа к массиву?
														(чтобы взять аннотацию нужно получить строку массива?)

-----
Объявления констант могут выглядеть одинаково (после модификатора обе):
	public @A Integer f3(String str) {}
Но если TYPE_USE - то к типу возвращаемого
Если METHOD - то к методу

Так может выглядеть и анатированное field И тип Integer!!!
public @A Integer f3;

Для УСТРАНЕНИЯ НЕОДНОЗНАЧНОСТИ и нужна аннотация @Target
---		 
Типовые аннотации
	Появились в JDK8. Теперь можно ставить анотации везде: тип возвращаемый методом, после throws, приведение типов, уровни доступа к массиву. Можно также перед this, а сам this можно первым параметром метода поставить явно. Эти аннотации позволяют проводить проверки на стадии разработки (спец. инструментами).
	Для использование нужно поставить - @Target(ElementType.TYPE_USE)

void myMeth ( ) throws @TypeAnno NullPointerException {  // . . .
int myMeth ( @TypeAnno SomeClass this, int i , int j ) { // . . .

-------------
@Inherited
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface Inh {} //наследуется

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface UnInh {} //не наследуется

@Inh
class A {}

@UnInh
class B {}

class C extends A {} //@Inh можно взять рефлексией из наследника
class C extends B {} //@UnInh нельзя взять рефлексией
---------------

Когда тип значения массив других аннотаций:
public @interface History {
    Version[] value() default {};
}
@History({ @Version(1) })


Использовать в аннотациях переменные разрешено:
@SomeAnnotation(
        count = (int) Math.PI,
        name = "" + Math.PI
)
Функции можно использовать только в runtime!
@SomeAnnotation(
        count = (int) Math.sin(1),
        name = "Hello!".toUpperCase()
)

-------------------
Повторяющиеся аннотации с JDK8

1. Создать анотацию (с @Repeatable контейнером)
2. создать контейнер для неё
3. Использовать анотацию несколько раз
4.1 Взять анотацию через её контейнер в рефлексии (из неё извлечь обычные аннотации?)
	по отдельности взять такие аннотации нельзя
4.2 С JDK8 можно использовать методы getAnnotationsByType() и getDeclaredAnnotationsByType()
		которые возвращают массив связанных с объектом аннотаци, в том числе вложенных по типу
	Annotation [] annos = method5.getAnnotationsByType(MyAnno.class);

@Retention(RetentionPolicy.RUNTIME)
@Repeatable(AContainer.class)
@interface A {
	int val();
	String str();
}

@Retention(RetentionPolicy.RUNTIME)
@interface AContainer {
	A[] value();
}

@A(val = 3, str = "ttt")
@A(val = 7, str = "ttt2")
void f1() {
	//...
	Annotation anno = m.getAnnotation(AContainer.class); //берём
}

До повторяющихся аннотаций в JDK8 использовали вложенные аннотации
	@Hints({@Hint("hint1"), @Hint("hint2")})
	
---------------

Типы которые могут использоваться в аннотациях:
int, double, String, Class, enum, другие аннотации (наследники Annotation?) и все массивы этих типов

Ограничения:
Аннотации не могут наследовать друг друга.
В их методах не может быть параметров.
Аннотации не могут быть обобщенными.
У методов в аннотацих не может быть throws

****************************************************
Потоки ввода/вывода.

Пакеты: java.io (обычный), java.nio (буферный и канальный ввод/вывод)

1. символьные - иногда эффективнее байтовых, но основаны на байтовых. В Java 1.0 не было.
	Символы в UTF с интернациализацией
2. байтовые

inputStream/OutputStream - верх иерархии

BufferedinputStream			Буферизированный поток ввода
ВUfferedOutputStream		Буферизированный поток вывода
ВyteArrayinputStream		Поток ввода, читающий байты из массива
ВyteArrayOutputStream		Поток вывода, записывающий байты в массив
DatainputStream				Поток ввода, содержащий методы для чтения данных
								стандартных типов, определенных вjava
DataOutputStream			Поток вывода, содержащий методы для записи данных
								стандартных типов, определенных вjava
FileinputStream				Поток ввода, читающий данные из файла
FileOutputStream			Поток вывода, записывающий данные в файл
FilterinputStream			Реализует абстрактный класс InputStream
FilterOutputStream			Реализует абстрактный класс OutputStream
Inpu ts treaш				Абстрактный класс, описывающий поток ввода
OЬjectinputStream			Поток ввода объектов
OЬjectOutputStream			Поток вывода объектов
OutputStream				Абстрактный класс, описывающий поток вывода
PipedinputStream			Канал ввода
PipedOutputStream			Канал вывода
PrintStreaш
	(наследник OutputStream)	Поток вывода, содержащий методы print ()
								и println ()
PushЬackinputStream			Поток ввода, поддерживающий возврат одного байта об­
								ратно в поток ввода
SequenceinputStream			Поток ввода, состоящий из двух и более потоков ввода,
								данные из которых читаются по очереди

Reader/Writer - вершина
								
Buf f eredReader			Буферизированный поток ввода символов
BufferedWriter				Буферизированный поток вывода символов
CharArrayReader				Поток ввода, читающий символы из массива
CharArrayWriter				Поток вывода, записывающий символы в массив
FileReader					Поток ввода, читающий символы из файла
File1friter					Поток вывода, записывающий символы в файл
FilterReader				Фильтрованный поток чтения
FilterWriter				Фильтрованный поток записи
InputStrea.Reade			Поток ввода, преобразующий байты в символы
								(для вкладывания байтовых потоков в символьные)
LineNwlЬerReader			Поток ввода, подсчитывающий строки
OutputStreaJIWrit			Поток вывода, преобразующий символы в байты
PipedReader					Ка нал ввода
Pipedlfriter				Ка нал вывода
PrintWriter					Поток вывода, содержащий методы  print()  и  println  ()
PushЬackReader				Поток ввода, позволяющий возвращать символы обратно
								в поток ввода
Reader						Абстрактный класс, описывающий поток ввода символов
StringReader				Поток ввода, читающий символы из строки
StringW'riter				Поток вывода, записывающий символы в строку
Writer						Абстрактный класс, описывающий поток вывода символов

int read() и write ( ) - абстрактные переопределенные в наследникках

символьные:
BufferedReader br = new BufferedReader(new
	InputStrearnReader(Systern.in));
char c = (char) br.read(); //читаем из потока 1 символ
	while(c != 'q');
	
String s = br.readLine(); //читаем строку
	while(!str.equals("stop");

байтовые:
write(int байт) - зписывает только 8 младших бит int
	int a = 'A';
	System.out.write(a);
	
int read() throws IOException - читает байт (младшие 8 бит int), если конец файла, то -1
	
В реальных программах часто применяют PrintWriter(OutputStream os, boolean очистка)
		очистка - вызывать ли автоматом flush при использовании print()
	- используется и для интернациализации
		
В методах print() для объектов вызывается toString()

FileOutputStream("name") throws FileNotFoundException - часто используется для работы с файлами. Если доступ запрещен правами?, то выкинет SecurityException
После работы с файлом его нужно закрыть close() throws IOException
	или будет утечка памяти
	
C JDK7 можно для закрытия файла использовать try с ресурсами. Для классов реализующих интерфейс java.lang.AutoClosable
	Его реализуют все потоки?
	ПРИ этом всё объявленное в try с ресурсами считается final постоянной
	
работа с файлом:
//обычный
try {
	fin = new FileInputStream("name.io");
	do {
		char c = (char) fin.read();
	} while(i != -1);
} catch (FileNotFoundException e) {
} catch (IOException e) {
} finally {
	try{
		if (fin != null) fin.close();
	} catch (IOException e) {
	}
}
//try с ресурсами
try(FileInputStream fin = new FileInputStream("name.io")) {
	//...
} catch (FileNotFoundException e) {
} catch (IOException e) {
}

****************************************************
System инкопсулирует свойства JVM, можно получить время, параметры системы и т.д.

in, err, out - предопределенные потоки, они final public static
in - консоль - InputStream
out - клавиатура - PrintStream
err - консоль - PrintStream
Эти потоки можно перенаправить на любое устройство

BufferedReader br = new BufferedReader(new
	InputStrearnReader(System.in));
	
PrintWriter(System.out) //вот так используется
	
in - буферезован построчно, пока не нажат Enter при вводе в консоль символы не передаются потоку

****************************************************
transient int i = 1; - модификатор доступа, только для переменных
// при сохранении объекта (например сериализации?) переменная не сохранится (т.е. её значение?)

volatile int a; - модификатор доступа, только для переменных (следует использовать только с базовыми типами или ссылками на Enum)
В обычных переменных каждый поток хранит свою копию переменной. И обновить главную переменную на новое значение может в любой момент, это эффективно. Если нужно чтобы был доступ всегда к самой переменной, то нужно слово volatile. Тогда можно получить истинное значение переменной в текущее время.

volatile может использоваться например при реализации синглтона в многопоточной среде
можно использовать только с простыми типами

--Atomic атомарные операции AtomicInteger и др - аналог volatile для объектов
AtomicReference, AtomicInteger, AtomicLong, AtomicIntegerArray

Для чего: величение и уменьшение, обновление или добавление значения, потокобезопасным способом

описать методы AtomicReference???:
compareAndSet() - сравнивает и устанавливает, видимо чтобы проверить не изменилось ли значение
lazySet()


используются для неблокирующей синхронизации
то есть являются аналогами volatile только для оболочек типов и объектов
	т.к. если объявить ОБЪЕКТ volatile то неблокирующей станет сама ссылка на него, а не сам объект

Есть мнение: что Atomic становятся медленными когда потоков очень много.
	
пример
		AtomicReference<Object> cache = new AtomicReference<Object>();

		Object cachedValue = new Object();
		cache.set(cachedValue);

		//... time passes ...
		Object cachedValueToUpdate = cache.get();
		//... do some work to transform cachedValueToUpdate into a new version
		Object newValue = someFunctionOfOld(cachedValueToUpdate);
		boolean success = cache.compareAndSet(cachedValue,cachedValueToUpdate);
	
java.util.concurrent.atomic - пакет с классами для неблокирующих операций

--(Atomic...FieldUpdater) AtomicIntegerFieldUpdater - для чего????
Атомарные корректоры полей, такие как AtomicIntegerFieldUpdater, AtomicLongFieldUpdater и AtomicReferenceFieldUpdater, по сути, представляют собой оболочку volatile-поля.
Подробнее http://stackoverflow.com/questions/8262982/atomicreferencefieldupdater-methods-set-get-compareandset-semantics
	
****************************************************

ссылка_на_ОБЪЕКТ instanceof ТИП - true, если ссылка на тот же тип или его предка.
foo instanceof Foo
	Или если можно привести к этому типу.
	Или реализует интерфейс Foo.
	Или наследует класс, который реализует интерфейс, который наследует другой интерфейс Foo.
	Это затратный оператор.
class A {}
class B extends A {}
class C extends B {}
class Main {
	public static void main(String args[]) {
		A a = new A();
		B b = new B();
		C c = new C();
		System.out.println(a instanceof B); //false
		System.out.println(b instanceof B); //true
		System.out.println(c instanceof B); //true
		
		//НО если предок указывал на наследника которому уже была выделена нужная память, то можно привести и следовательно будет true?
		A a = new B();
		System.out.println(a instanceof B); //true
	}	
}

Для обобщенных
iOb instanceof Gen<?> - проверка можно ли привести класс к Gen
iOb instanceof Gen<Integer> - ошибка, так нельзя указывать тип, он не известен при выполнении

foo.getClass() == bar.getClass() - можно проверять классы так
Foo.class.isAssignableFrom(Bar.class) - проверка типа через рефлексию?
	Также аналоги: isInstance() (эквивалентно instanceof)
		Class.class.isInstance(SomeRelatedClass.class);
	cast() (преобразует параметр в объект выбранного класса)
	A.class.cast(new B()); //аналог обычного приведения?
****************************************************
	
strictfp - вычисления плавающих чисел будет чуть более строгим, как в старых версиях Java.
			Над классом, интерфейсом, методом. Если над классом, то все методы его методы станут тоже strictfp
			strictfp class A {} 


assert - утверждениие, для проверки в коде обычно только на стадии разработки.
	При ошибке выбросит AssertionError и программа остановится
	если true - то работает, если false - исключение
1. assert n > 1: "c сообщение"; //можно любой тип приобразуемый в String кроме void
2. assert n > 1; //просто прерывет

java -ea p1.MyProgr -разрешив проверку assert в программе
java -da p1.MyProgr - отключить проверку assert в программе
java -ea:myPack1... p1.MyProgr - включение проверки только для одного пакета
java -da:myPack2... p1.MyProgr - отключение проверки только в одном пакете
java -ea:p1.MyProgr - включить проверку только в одном классе
java -ea:com.wombat.fruitbat... -da:com.wombat.fruitbat.Brickbat BatTutor

-enablesystemassertions, or -esa - включаем assert для всех системных? классов
-disablesystemassertions, or -dsa - отключаем assert для всех системных? классов
java -esa -ea:com.wombat.fruitbat...

****************************************************
Компактные профили
	появилась в JDK8
всего 3 штуки
	compact3 включает compact2 включает compact1
Каждый профиль содерж набор классов. При компиляции можно указать профиль и т.к. классы не все, то размер библиотеки будет меньше.
javac -profile профиль программа
javac -profile compact2 Test.java
Если классов не достаточно, то при компилции будет ошибка

Список нужных классов для каждого профиля смотреть в документации
http://www.oracle.com/technetwork/java/embedded/resources/tech/compact-profiles-overview-2157132.html

****************************************************
Платформо ориентиное программирование, JNI - Java Native Interface

Это запуск функций из библиотек на других языках внутри программ на Java

В JDK8 можно подключать статические библиотеки. До этого можно было только динамические.

class Test {
	public static void f1() {
		
	}
	
	public native void test();
	
	static {
		System.loadLibrary("dll_name"); //имя dll файла для Windows
	}
}

(для C)
1. Скомпилить
2. Создать заголовочный файл javah -jni Test
3. Подключить Test.h
4. Реализовать метод в .c файле

****************************************************
Обобщения, Generics (появились в JDK5)
	параметризованные классы

До обобщений использовались ссылки на Object, но это типо-небезопасно.
Обобщения позволяют находить ошибки в типах во время компиляции, а не во время выполнения как псевдо-обобщения с Object.
При компиляции обобщения удаляются и заменяются на несколько обычных реализаций.

Сокращенная запись появилась в JDK7
	Gen<Integer> g1 = new Gen<>(123); до этого писали Gen<Integer> g1 = new Gen<Integer>(123);
	В ссылках на методы <> не пишется:
		LinkedList<>::new //ошибка
		LinkedList::new //правильно

T - параметр типа
параметры могут быть только типами объектов (ссылочными типами), не с примитивными типами
class Gen<T> {
	T ob;
	Gen(T t){ob = t;}
	T f1(){}
}
Gen<Integer> g1 = new Gen<>(123);
Gen<String> g2 = new Gen<>("test");
g1 = g2; //ошибка, разные типы

Типы T и V не обязательно разные.
Gen<T, V> {
	T t;
	V v;
}
Gen<String, String> g = new Gen<>();

При наследовании параметры типов могут только расширяться? Причем в подклассе обобщений может и не быть.
class GenSuper1 {} //нету параметров
class GenSuper2<T> extends GenSuper1 {}
class Gen<T, V> extends GenSuper<T> {} //в наследнике типов больше чем в предке, и он всегда принимает тип предка
class A implements Gen<Integer> {} //правильно, можно задать конкретный тип и тогда можно не делать класс обобщенным

Ограниченные типы.
Методы классов не видны во время выполнения, как у абстрактных методов.
НО можно объявить тип наследником определенного класса. И тогда можно использовать его методы, как по абстрактной ссылке.
	при этом можно использовать только заявленные типы, а не любые.
class<T extends Double> { //можно использовать ТОЛЬКО Integer ИЛИ его наследников, T - предок
	int f1(T t) {
		t.doubleValue(); //теперь компилятор знает о методе
	}
}

Ограничивать можно ОДНИМ классом и несколькими интерфейсами.
	то есть T наследник класса реализующего интерфейсы
class Gen<T extends MyClass & MyInterface1 & MyInterface2 & MyInterface3> { //...
	T[] arr;
}

Метасимвольный аргумент (wildcard) <?>
	Можно подставить типу любой параметр. Метасимвол совпадает только с ДОСТОВЕРНЫМИ типами (зависит от extends?)
	И в метод можно будет передавать разные типы.
class Gen<T extends Number> {
	T t1;
	Gen(T t) {
		t1 = t;
	}
	boolean sameAvg(Gen<?> t2) { //теперь сюда подходят Gen<Double> и Gen<Integer>
		if(avg() == t.avg()) return true;
		return false;
	}
}
//правильно, хотя типы разные.
Gen<Long> g = new Gen<>();
g.sameAvg(new Integer(88));

Ограничение метасимволов (wildcard).
	Это нужно если некоторые типы используются в классе. Но в методе используется их подгруппа, ещё меньшая.
class Gen<T extends Object> {} //ограничиваем в классе
boolean f1(Gen<? extends Number> g) {} //дополнительно ограничиваем в методе

super:
	1. Можно использовать только один из предков Number, НО не сам Number: <? super Number>
	2. НЕЛЬЗЯ использовать <S super T> и подобные для классов и интерфейсов. Для методов тоже НЕЛЬЗЯ!
		Только для метасимволов <?> можно!
			interface B<T super Number>{} //ошибка
			class A<T super Number>{} //ошибка
			<S super T> S[] toArray(S[] a) //ошибка, для обобщенных методов нельзя
			void f1(A<? super Number> a) //правильно, в параметре метода
Помнить: extends - включительно (включая указанный класс), super - включительно тоже
В Шилдте описка, там написано, что super - ИСКЛЮЧАЮЩЕЕ - ЭТО ОШИБКА

Обобщенный метод
	можно делать отдельно обобщенный метод
		<параметры> возвращаемый_тип имя_метода() - общий вид
class Gen {
	static <T extends Comparable<T>, V extends T>
		boolean isIn(T[] x, String str) {//...}
Вызов метода:
	Gen.isIn(new MyClass[] { 1, 2 }, "test"); - в большинстве случаев
	Gen.<MyClass, String>isIn(new MyClass[] { 1, 2 }, "test"); - вызов с явным указанием типов-параметров, нужен иногда
	
Обобщенный конструктор
class A {
	<T>A(T []arr) {
	}
}

Обобщенный интерфейс	
interface Gen<T extends Comporable<T>> {
	T f1();
}

При реализации ОГРАНИЧЕНИЕ (extends и/или super) повторять в интерфейсе не нужно. Причем повторять ограничение и невозможно - ошибка.
interface Gen<T extends Comparable<T>> {}
class A<T extends Comparable<T>> implements Gen<T> {} //правильно
class A<T extends Comparable<T>> implements Gen<T extends Comparable<T>> {} //ошибка

class A implements Gen<T> {} //ошибка, реализующий класс должен быть обобщенным
class A<T> implements Gen<T> {} //правильно

Конкретный тип при РЕАЛИЗАЦИИ обобщенного интерфейса.
<<<можно и в классах?>>>
class A implements Gen<Integer> {} //правильно, можно задать конкретный тип и тогда можно не делать класс обобщенным

Можно писать так (ограничивая типы в подстановке типа):
List<? extends Number> foo3 = new ArrayList<Number>();  // Number "extends" Number (in this context)
List<? extends Number> foo3 = new ArrayList<Integer>(); // Integer extends Number
List<? extends Number> foo3 = new ArrayList<Double>();  // Double extends Number
List<? super Integer> foo3 = new ArrayList<Integer>();  // Integer is a "superclass" of Integer (in this context)
List<? super Integer> foo3 = new ArrayList<Number>();   // Number is a superclass of Integer
List<? super Integer> foo3 = new ArrayList<Object>();   // Object is a superclass of Integer
List<Number> intList = new ArrayList<Integer>(); //ошибка
------
Сырой тип (базовый тип)
	Оставлен как способ переноса старого кода до JDK5. При этом утрачивается типо-безопастисть.
		Используется только когда нужно новый код обобщений сочитать со старым.
	При компиляци таких штук через javac выводится предупреждение.
class Gen<T> {
	T ob;
	Gen(T t){ ob = t; }
	T f1(){ return ob; }
}
Внутри создаётся объект типа Object:
Gen g = new Gen(new Integer(23)); //без указания типа

Gen<String> strOb = new Gen<String>();
strOb = g; //сработает
strOb.f1(); //ошибка во время выполнения

Gen<Integer> iOb = new Gen<Integer>();
iOb = g; //сработает
iOb.f1(); //ошибка во время выполнения

// ошибка, если в generics стоит несколько ОДИНАКОВЫХ типов, копилятор требует чтобы типы были РАЗНЫМИ
class A<Number, Number>{} // ошибка, два Number одинаковые, нужно чтобы типы были разными
------
iOb instanceof Gen<?> - можно ли привести класс к Gen
iOb instanceof Gen<Integer> - ошибка, так нельзя указывать тип, он не известен при выполнении

Приведение типов обобщений
(Gen<Integer>) iOb //правильно, так как iOb уже Integer
(Gen<Long>) iOb //ошибка (видимо потому что предок которому не выделено памяти наследника)

Стирание (очистка?)
Все обобщения удаляются при компиляции и заменяются кодом с приведением типов.
мостовой метод - создаётся при стирании, если метод после стирания в подклассе не совпадает с ним же в супер классе. (то есть добавляется такой же метод с другими типами). Они появляются только на уровне байт-кода.
	Эти методы можно исследовать только через javap - посмотреть в ОБЫЧНОМ Java коде как всё выглядит после компиляции.
	
Обобщенный тип может быть массивом
Set<Object[]> mySet = new Set<>();
	- каждый элемент это ссылка на массив

Неоднозначности (типичные ошибки)
	неоднозначность показывает ошибку проектирования
1.
class A<T, V> {
	void set(T t){}
	void set(V v){}
}
A<String, String> a = new A<>(); - невозможно понять какой из set() вызвать, т.к. типы одинаковы
2.
A<Integer, String> a = new A<>(); - после стирания оба метода становятся set(Object ob) и опять невозможно понять какой вызвать
	void set(Object t){}
	void set(Object v){}
3.
class A<T, V extends Integer>{} - не исправляет ошибку 2. т.к. можно написать:
	A<Integer, Integer> a = new A<>(); - оба метода set() совпадут по сигнатуре
	
Ограничения обобщений
1.
class A<T> {
	A() {
		new T(); //ошибка, создавать по параметру типа нельзя
	}
}
2.
class A<T> {
	static T ob; //ошибка, нельзя параметры типа в static
	static T f1(){} //ошибка, нельзя static метод с параметром типа КЛАССА
	static <V>f2(V v){} //правильно, НО если параметр у функции свой отдельный от класса то можно
}
3.
class A<T> {
	T arr[]; //правильно, массив ссылок на тип можно
	A(T[] tarr) {
		arr = new T[10]; //ошибка, массив параметра типа нельзя создать
	}
}
... main() {
	A<Integer> a[] = new A<>[10]; //ошибка, создать массив обобщенных объектов нельзя
	A<?> a2[] = new A<?>[10]; //правильно, можно создать через метасимвол.
	A a2[] = new A[10]; //можно НО плохо, создание массива через базовый тип, использовалось до JDK5 - не вообще проверок типа
}
Создавать массивы через метасимвол лучше, т.к. в отличии от создания массивов через базовые типы (см. выше), тут есть хоть какие-то проверки типов.
4.
Обобшенный класс не может расширять Throwable
То есть создать обобщенный класс исключения нельзя.

****************************************************
Лямбда выражения
	появились в JDK8
	
Два типа использования (контекста):
	Чтобы использовать НУЖНО присвоить интерфейсу с одним нереализованным методом и так создать объект.
		(хотя ссылка будет типа интерфейса)
	
Лямбда выражения называют замыканиями - анонимный метод (это не точно)

Функциональный интерфейс - содержит только ОДИН абстрактный метод (т.е. у него НЕТУ default метода)
	ещё называют SAM-типом, Single Abstract Method
В нём можно переопределить любой public метод определённый в Object, не воздействуя на функциональный интерфейс.
public методы из Object считаются неявными членами функционального интерфейса, т.к. они автоматически реализуются ЭКЗЕМПЛЯРОМ функционального интерфейса.

interface My {
	double f1(int n, String str); - пример, функциональный интерфейс
}
Интерфейс Runnable с единственным методом run() - тоже функциональный интерфейс

-> называется лямбдо-оператором

<<<если наследовать интерфейсу Serealizeble то лямбда-выражение можно серилиазовать?>>>

---------------
примеры:
//Нельзя выполнять на месте как анонимную функцию.
int n = () -> { return 123.45; }; //ОШИБКА, только присвоив лямбда-выражение интерфейсу его можно выполнить

() -> 123.45; //фактически константа
() -> Math.random() * 100;

(n) -> (n % 2) == 0;

(int n) -> 1234.123; //можно указать тип параметра, но не обязательно, НО иногда это требуется

(int n, String str) -> 123.12; //если нужно указать тип параметра, то это нужно делать для ВСЕХ параметров
(n, String str) -> 12.123; //ошибка, нельзя указать тип только одного параметра

n -> 123.12; //если параметр один то скобки необязательны

//можно приравнивать одну ссылку разным реализациям
//только так можно использовать выражение, присвоив интерфейсу
interface A { int f1(int n, String str); }
A a = (n, str) -> 12;
a.f1(1, "qwe");
a = (n, str) -> 12 + 3;
a.f1(12, "qwe");

//блочное лямбда выражение
() -> {
	int n = 123;
	n += 12;
	return n; //вызывает возврат ИЗ САМОГО СЕБЯ, я не из внешнего к нему метода
};
----------

Присваивание метода интерфесы (создание реализации класса по сути).
	Это создание экземпляра класса.
	1. Присваиваемый метод должен совпадать по количеству параметров и типам (то есть типы должны быть совместимы).
	2. Возвращаемый тип тоже должен быть совместимым.
	3. Исключения в абстрактном методе также должны совпадать с реализацией в лямбда-выражениях.
1.
Создаём ссылку на интерфейс
My m;
2.
Присваиваем ей лямбда-выражение
	//при передаче это как анонимная реализация интерфейса: new A { public double f1(String str) {str.bla();} }
My m = (n, str) -> 123.45; //созданием экземпляра класса из ссылки
int n = m.f1(12, "test"); //вызов реализации

int n2 = m.f1("test1", "test2"); //ошибка, типы параметров не такие
My m2 = (n, str) -> "123.45"; //ошибка, возвращаемый тип не такой

Обобщенный функциональный интерфейс
interface A<T> {
	T f1(T t);
}
A<String> a1 = (str) -> { return str; };
A<Integer> a2 = (i) -> { return i; };
a1.f1("test");
a2.f1(34);

Лямбда-выражения в качестве параметров
	интерфейс должен быть совместимым типом, но не обязательно тот же тип?
interface A {
	double f1(String str);
}
class B {
	void f2(A a) { //тип функционального интерфейса
		a.f1();
	}
}
//при передаче это как анонимная реализация интерфейса: new A { public double f1(String str) {str.bla();} }
new B().f2((str) -> {
	str.bla();
});

аналогично:
A a = (str) -> {
	str.bla();
};
new B().f2(a);

массивы в лямбда-выражениях
	нельзя указывать значёк массива [], т.к. это тоже тип, а он выводится автоматически
interface My { double f1(double [] arr); } //метод с массивом
My m = (arr) -> { //правильно
	return 13.121;
};
My m = (double[] arr) -> 12.31; //НО можно указатьл тип массива прямо

Образует контекст целевого типа??? (то есть неявное создание объекта реализации интерфейса: new MyInterf(){...})
1. инициализация, присваивание и передача аргументов
2. приведение типов
3. тринарная операция ?
4. инициализация массивов
5. return
6. сами лямбда-выражения
<<<описать то что выше!>>>

Исключения
	генерируемое в лямбда-выражениях исключения должно быть совестимого типа с исключениями в throws
interface A {
	double f1(int arr[]) throws Exception;
}

Захват переменных
В лямбда выражениях доступен this внешнего класса (НЕ this реализованного функцианального интерфейса, а просто класса)
и другие внешние переменные, НО ЛОКАЛЬНЫЕ переменные использованные внутри лямбда-ф. становятся неявно final,
	при этом использованные переменные класса не становятся неявно final
	параметр??? this тоже был или становится final???
	у самого лямбда-выражения своего this нету
interface My {
	void f1();
}
class A {
	int i = 4;
	void f1() {
		int n = 8;
		int z = 1;
		My m = () -> {
			int v = n; //правильно
			n = 10; //ошибка, локальная переменная n использованная внутри лямбда-ф. неявно становится final
							(или можно указать явно final)
			this.i = 11; //правильно, нелокальные переменные меняться могут (не final неявно)
		};
		n = 14; //ошибка, после того как локальная перменная использована в лямбда-выражении она стала неявно final
				//ПРИЧЕМ. ошибку покажет не на этой строке, а при первом применении в лямбда-выражении
		z = 23; //правильно, не использовалась в лямбда-ф. и ведёт себя как обычно
	}
}

Ссылки на методы
	появились в JDK8
	СОВМЕСТИМЫЕ по типу параметров и возвращаемого значения методы могут ссылаться на такие же.
		(напр. int и Integer совместимы, как параметры так и возвращаемые)
:: - новый оператор доступа к методам
ссылки на методы преобразуются в экземпляры функциональных интерфейсов

Class::staticMethodName		(s) -> String.valueOf(s)
object::instanceMethodName	() -> object.toString()
Class::instanceMethodName	(s, s2) -> s.toString(s2)
ClassName::new				() -> new String()

super::имя_метода - ссылка на метод предка
this::имя_метода
EnclosingClass.this::method - для внутреннего класса можно так
MyClass::new - ссылка на конструктор, какой именно конструктор зависит от контекста

1. На статические методы по имени класса
class Main {
	public static void main(String args[]) {
		My m = A::f5; //
		System.out.println(m.f1());
	}	
}
interface My {
	Integer f1(); //int и Integer совместимы
}
class A {
	public static int f5() {
		return 5;
	}
}

2. для обычных методов по объекту
class A {
	public int f5() {
		return 5;
	}
}
A a = new A();
My m = a::f5; //

3. Для обычных методов по имени классу
MyClass::method_name (методы не статический)
String::compareToIgnoreCase — это то же самое, что и (x, y) -> x.compareToIgnoreCase(y)
	то есть первый параметр это ссылка на объект того же типа, начиная со второго параметра эти параметры работают как обычно
Это нужно чтобы использовать метод с любым экзепляром данного класса, а не только с указанным объектом

//1.
interface A {
	//B - ссылка на объект из которого будет вызов: String s = b.f1(n);
	String f1(B b, int n); //String s = (b, n) -> b.f1(n);
}
//2.
class B {
	String f2(int n) {
		return n + "_1";
	}
}
//3.
A a = B::f2;
String s = a.f1(new B(), 2); //тоже самое что: String s = new B().f2(2);


4. Ссылка на обобщенные методы
interface A<T> {
	int func(T val);
}
class B {
	static <T> int f1(T val) {
		return String.valueOf(val);
	}
}
A<T> mth = B::<String>f1; //тип после :: относится к методу

5. Ссылки на конструктор
	может быть присвоен любой совместимой ссылке
interface A {
	B f1(int v);
}
class B {
	private int i;
	B(int v){i = v;}
}
A a = B::new;
B b = a.f1(112); //создаём экземпляр класса B

для обобщенного конструктора:
interface A<T> {
	int func(T[] val);
}
class B<T> {
	B(T val) {
		val.bla();
	}
}
A<Integer> cnstr = B<Integer>::new; //тип перед :: относится к классу
B b = cnstr.func(); //вызов конструктора из ссылки на него

ссылка на конструктор массива:
	как правило в конструкторах массива используется один параметр типа int - количество объектов
	//принимает тип массива в качестве шаблона, метод создаёт массив объектов (T == тип + массив )
			то есть получается массив неинизиализированных ссылок указывающих на null
interface MyArrayClassFactory<T> { //ссылка на конструктор массива классов
	T func(int n);
}
MyArrayClassFactory<A[]> mf = A[]::new;
A[] a = mf.func(2);
a[0] = new A();
a[1] = new A();
<<<можно ли применять тип-массив для обычных обобщений? - да?>>>

На практике ссылки на конструкторы применяются в фабриках объектов. Можно использовать один метод на много типов объектов.


Предопределенные функциональные интерфейсы
	в пакете java.util.function
	по сути это уже готовые ссылки на методы - функциональные интерфейсы (ссылки на функции)
	
		java.util.function
		- функциональные интерфейсы, готовые которые используются в Java API
			(т.е. готовые ссылки на методы, чтобы самому не определять)
		- могут иметь методы по умолчанию default и static методы
		
		cunsumer - то что принимает значения (потребляет) и НЕ ВОЗВРАЩАЕТ результат
			DoubleConsumer: void accept(double d)
		function - то что оперирует РАЗНЫМИ (или одним) объектами и даёт результат
			DoubleFunction: R apply(V v, T t)
		operator - опирирует двумя ОДНОТИПНЫМИ объектами и даёт результат
			DoubleOperator: R apply(Double i1, Double i2)
		predicate - принимает разные объекты и ВОЗВРАЩАЕТ boolean
			DoublePredicate: boolean test(V v)
		supplier - НЕ ПРИНИМАЕТ ПАРАМЕТРЫ (объекты), сам что-то делает и возвращает результат
			DoubleSupplier: T get()
			
		Приставки:
			Bi - если принимает 2 аргумента (BiFunction)
			To - если приобразует объект в другой (ToIntBiFunction)
			Unary - если оперирует только одним параметром (UnaryOperator)

****************************************************
пакет java.lang
	импортируется по умолчанию
		оболочки примитивных типов, строки, управление процессами, управление потоками (Runnable, Thread и т.д.)
		интерфейсы итератора, Cloneable, Comparable, AutoClosable и подобные
		
	подпакеты:
		java.lang.annotation - интерфейсы аннотаций
		java.lang.instrument - средства для разных аспектов выполнения программы (Instrumentation, ClassFieldTransformer, ClassDefinition)???
		java.lang.invoke - поддержка динамических языков (CallSite, MethodHandler, MethodType)???
		java.lang.management - управление JVM и исполняющей средой???
		java.lang.ref - гибкое управление сборкой мусора???
		java.lang.reflect - для ревлексии
	
Содержит:
	Оболочки типов
		Number - предок всех чисел
			Double, Float
				константы: BYTES - введена с JDK8, длина типа в байтах
							MAX_VALUE
							NaN - не число
							NEGATIVE_INFINITY - отрицательная бесконечность
							SIZE - размер содержимого оболочки в байтах
							TYPE - объект типа Class
							и д.р.
				метода оболочек:
					типValue() - содержимое оболочки (напр. byteValue(), doubleValue())
					int compareTo(Float f) - сравнивает число с текущим, используется в сортировках
					isInfinite() - бесконечность ли
					isNaN() - если не число то true
					Double.sum(12.3, 1.1) - (c JDK8) сумма 13.4
					String Double.toHexString(12.3) - число в 16ричном формате
					Double.compare(123.2, 12.2) //== +1
					static int reverse(int число) - меняет порядок битов в числе
					signum(int) - знак, отрицательне или положительное число
					Integer.parseInt("123") //==123
						//преобразование чиселв строки вида:
					Integer.toOctalString("123")
					Integer.toHexString("123")
					Integer.toBinaryString("123")
			Character
				начиная с JDK5 есть поддержка символов 32bit
				int в некоторых методах чтобы поместились доп. юникод символы
			MIN_RADIX - минимальное основание системы счисления
			методы:
				char ch = Character.idDigit(3, int основание);
				int ch = Character.idDigit(char ch, int основание);
				Character.isLetter("a")
			Character.Subset - для подмножеств символов юникод
			Character.UnicodeBlock - для блоков юникод
			Boolean

Вложенные в Character классы:
Character.Subset - для подмножеств символов юникод
Character.UnicodeBlock - для блоков юникод
			
Бесконечно и нечисло есть только у классов float и double
Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NaN			

В JDK5:
Теперь символы могут быть 32 бита
Кодовая точка - символ от 0 до 10FFFF (то есть обычный символ только 32 бита)
дополнительный символ - символ выше FFFF
основная многоязыковая плоскость - символы от 0 до FFFF
Два способа работы:
1. Пара char символов чтобы поместились в 32 бита
	используются методы charPointAt()
2. int
int codePoint = Character.codePointAt(new char[] {'a', 'b'}, 2);
//codePoint == 'b'
isHighSurrogate(char) - символ старший суроггат.
	(левая половина символа)
isSupplementaryCodePoint(int) - true если дополнительный символ
char []ch = Character.toChars(int кодовая_точка) - кодовая точка в символ
ch[0] - левая часть
ch[1] - правя часть символа
int codePoint = toCodePoint(char старший сурогат, char младший); 

****************************************************
из java.lang

Void - содержит единственное поле TYPE с объектом Class описывающим void. Создать экземпляр Void невозможно.
(используется только для рефлексии?)
//возвращает ли метод void
Hello.class.getMethod("main", Array.newInstance(String.class, 0).getClass()).getReturnType() == Void.TYPE

Также аналог Class для этого типа - void.class

public final class Void
extends Object

public static final Class<Void> TYPE

****************************************************
из java.lang

--Process
Process - управление запущенным процессом другой программы.
Получение стандартного потока ввода/вывода для программ.
	void destroy() - прерывает процесс
	InputStream gerErrorStream() - поток ввода ошибок процесса err
	InputStream getInputStream() - поток ввода для чтения данных из потока in
	OutputStream getOutputStream() - поток процесса для вывода out
	int waitFor([long время]) - не возвращает значение пока вызванная программа не завершится.
	и др.
	
Пример:
	BufferedReader reader = 
					new BufferedReader(new InputStreamReader(process.getInputStream()));
	StringBuilder builder = new StringBuilder();
	String line = null;
	while ( (line = reader.readLine()) != null) {
	   builder.append(line);
	   builder.append(System.getProperty("line.separator"));
	}
	String result = builder.toString()

--Runtime
Runtime r = Runtime.getRuntime(); - управление JVM.
	Апплеты и и друго недоверенный код не может использовать Runtime.
	Process exec() - запуск программ
	gc() - принудительная сборка мусора, лучше не вызывать.
	halt() - принудительное завершение JVM
	exit() - закрытие вызывающего процесса
	freeMemory() - количество свободных байт доступных Java
	totalMemory() - количество свободных байт доступных программе
	load(String name) - загрузка динамическую dll библиотеку
	runFinalization() - вызывает методы finalize() для неиспользованных, но ещё не возвращенных объектов.
	и др.

//вычисление текущего объема памяти
Runtime r = Runtime.getRuntime();
int m = r.freeMemory() - r.totalMemory();

Выполнение программ
Runtime r = Runtime.getRuntime();
Process p = null;
try {
	p = r.exec("Notepad");
	p.waitFor();
} catch(Exception e) {
}
System.out.prinln(p.exitValue());

--ProcessBuilder
ProcessBuilder - управление процессами, запуск программ, изменить рабочий каталог, поменять параметры окружения???
	более разите средства для управления процессами
ProcessBuilder(List<String> args) - задать программу и аргументы
ProcessBuilder(String... args) - задать аргументы строкой
	args - список аргументы коммандной строки
List<String> command() - возвращает List с именем программы и её аргументами.
						Изменения в списке относятся к вызываюшему объекту.
File directory() - возвращает каталог вызывающего объекта
ProcessBuilder directory(File f) - устнавливает каталог вызывающего объекта
Map<String, String> environment() - возвращает переменные среды вызывающего объекта
Process start() throws IOException
inheritIO() - вызываемый процесс будет использовать те же потоки ввода/вывода что вызывающий

ProcessBuilder.Redirect redirectInput() - возвращает источник стандартного потока ввода в виде объекта ProcessBuilder.Redirect
ProcessBuilder.Redirect redirectInput(ProcessBuilder.Redirect источник)
ProcessBuilder.Redirect redirectInput(File f)
ProcessBuilder.Redirect redirectOutput() - то же для вывода
ProcessBuilder.Redirect - абстрактный класс

--ProcessBuilder.Redirect
static ProcessBuilder.Redirect to(File f) - переадресовка вывода в файл
static ProcessBuilder.Redirect from(File f) - переадресовка ввода из файла
static ProcessBuilder.Redirect appendTo() - присоединить вывод к файлу
File file() - получить файл связанный с потоком

ProcessBuilder.Redirect.Type type() - вы
ProcessBuilder.Redirect.Type - типа enum:
	APPEND, INHERIT, PIPE, READ, WRITE
а в самом классе ProcessBuilder.Redirect есть:
		ProcessBuilder.Redirect.INHERIT и ProcessBuilder.Redirect.PIPE

try {
	ProcessBuilder p = new ProcessBuilder("nodepad.exe", "newfile");
	p.start();
} catch(Exception e){}
****************************************************
из java.lang

--System
	вопросы:
		что за каналы Channel связанные с JVM???
		что такое identityHashCode???

	Содержит статические методы и переменные, стандартные потоки ввода/вывода
	Часто генерируется SecurityException если что-то ограничено диспетчером защиты
	

	static void arraycopy(Object arrSource, int begin, Object dest, int beginDest, int quntity)
		- копирует массив
		
	static String clearProperty(String envvarName)
		- удаляет переменную среды, возвращает её значение
		
	static Console console() - возвращает консоль текущей JVM, или null если консоли нету
	
	static long currentTimeMills() - возвращает время в милисекундах с 1 янв 1970 года
	
	static void exit(int code) - закрывает программу, 0 - ошибок нет
	
	static void gc() - вызов сборщика мусора
	
	static Map<String, String> getenv() - возвращает переменные среды
	
	static String getenv(String name) - возвращает значение переменой среды
	
	static Properties getProperties() - класс Properties связанные с JVM (описывает JVM)
	
	static void getProperties(String name)
	static void setProperties(Properties свойства) - устанавливает свойства JVM
	static void setProperty(String name, String val) - установка только одного свойства
	
	static SecurityManager getSecurityManager() - текущий диспетчер защиты или null если его нет
	static SecurityManager setSecurityManager(SecurityManager sm) - его установка
	
	static int identityHashCode(Object obj)
		- возвращает хэш идентичного объекта
		
	static Channel inheritedChannel() - возвращает канал наследуемый JVM или null если его нет
		throws IOException
	
	static String lineSeparator() - строка символов разделитей строк
	
	static void load(String имя_файла_библиотеки) - загружает динамическую библиотеку
	
	static void loadLibrary(String имя_библиотеки)
	
	static 	void mapLibraryName(String name) - ???
	
	static long nanoTime() - ??? более точное время, начало времени не 1970 год, а любое вообще???
	
	static void runFinalization() - вызов finalize() для неиспользуемых, но ещё утилизированных объектов
	
	меняем стандартные потоки:
	static void setErr(PrintStream err)
	static void setIn(InputStream in)
	static void setOut(PrintStream out)
	
	Примеры:
		0. ждем пока не нажат Enter
			try {
				System.out.println("Press  to continue...");
				System.in.read();
			} catch (Exception e) {
				e.printStackTrace();
			}
		
		1. время работы программы
			int start = currentTimeMills();
			for(int i = 0; i < 1000; i++);
			int end = currentTimeMills();
			int time = start - end; // получаем время работы
			
			//более точный вариант
			int start = nanoTime();
			for(int i = 0; i < 1000; i++);
			int end = nanoTime();
			int time = start - end; // получаем время работы
			
		2. arraycopy()
			byte a[] = {'a', 'b', 'v'};
			byte b[] = {'s', 'd'};
			System.arraycopy(a, 0, b, 2, 3);
			
		3. Берем Property из JVM
			String s = System.getProperty("user.dir");
			
			//читаем свойства, загружаем из файла, устанавливаем сразу группу свойств
			public class PropertiesTest {
				public static void main(String[] args)
					throws Exception {

					// set up new properties object
					// from file "myProperties.txt"
					FileInputStream propFile =
						new FileInputStream( "myProperties.txt");
					Properties p =
						new Properties(System.getProperties());
					p.load(propFile);

					// set the system properties
					System.setProperties(p);
					// display new properties
					System.getProperties().list(System.out);
				}
			}
			
			Таких свойств JVM много: java.class.path, java.home, os.name,
				line.separator и много других
				
				Key					Meaning
				------------------------------------
				java.version	Java Runtime Environment version
				java.vendor	Java Runtime Environment vendor
				java.vendor.url	Java vendor URL
				java.home	Java installation directory
				java.vm.specification.version	Java Virtual Machine specification version
				java.vm.specification.vendor	Java Virtual Machine specification vendor
				java.vm.specification.name	Java Virtual Machine specification name
				java.vm.version	Java Virtual Machine implementation version
				java.vm.vendor	Java Virtual Machine implementation vendor
				java.vm.name	Java Virtual Machine implementation name
				java.specification.version	Java Runtime Environment specification version
				java.specification.vendor	Java Runtime Environment specification vendor
				java.specification.name	Java Runtime Environment specification name
				java.class.version	Java class format version number
				java.class.path	Java class path
				java.library.path	List of paths to search when loading libraries
				java.io.tmpdir	Default temp file path
				java.compiler	Name of JIT compiler to use
				java.ext.dirs	Path of extension directory or directories
				os.name	Operating system name
				os.arch	Operating system architecture
				os.version	Operating system version
				file.separator	File separator ("/" on UNIX)
				path.separator	Path separator (":" on UNIX)
				line.separator	Line separator ("\n" on UNIX)
				user.name	User's account name
				user.home	User's home directory
				user.dir	User's current working directory
			
****************************************************
из java.lang

--Object

	protected Object clone() throws CloneNotSupportedException
	
	boolean equals(Object obj)
	
	protected void finalize() throws Throwable
	
	final Class<?> getClass() - объект типа Class описывающий текущий класс
	
	int hashCode()
	
	final void notify()
	final void notifyAll()
	final void wait()
		throws InterruptedException
	final void wait(long ms)
		throws InterruptedException
	final void wait(long ms, long nano)
		throws InterruptedException
		
	String toString()
	

clone() - клонировать можно только объекты реализующие Cloneable
				это интерфейс-маркер без методов и переменных
				Потенциально опасное действие, т.к. могут меняться переменные на которые ссылаются оба объекта
				при клонировании КОНСТРУКТОР НЕ ВЫЗЫВАЕТСЯ
				
		protected Object clone(); - метод PROTECTED
		метод clone() можно переопределить как public и вызывать не только внутри класса-ннаследника или пакета
		
		class Test implements Cloneable {
			Test f1() { return (Test) super.clone(); }
		}
		
		class Test2 implements Cloneable {
			public Test2 clone() { return Test2 super.clone(); }
		}
		Test2 t2 = new Test2().clone();
	
****************************************************
из java.lang

--Class
	инкапсулирует RTTI класса или интерфейса.
	его объекты создаются автоматически при загрузке класса, объявлять явно их нельзя
	для получения его объекта Class<?> clazz = new Object().getClass();
	
	static Class<?> forName(String name)
		throws ClassNotFoundException		- возвращает класс по его полному имени
	static Class<?> forName(String name, boolean способ, ClassLoader cl)
		throws ClassNotFoundException		- возвращает класс по имени, используя другой загрузчик
											способ - инициализировать (true) или нет (false)
		
	<A extends Annotation>
	A getAnnotation(Class<A> annotation_type)
	
	Annotation[] getAnnotation()
	
	<A extends Annotation>
	A[] getAnnotationByType(Class<A> anno_type) - начиная с JDK8
	
	Class<?>[] getClasses() - массив классов для каждого public члена класса на котором вызывается
	
	ClassLoader getClassLoader() - получаем ClassLoader который загрузил данный класс
	
	методы для рефлексии: взятие аннотаций, методов, полей, конструкторов, реализуемые интерфейсы,
	
	Class<? super T>
	getSuperclass() - наследуемые super классы или null если их нет (только Object)
	
	String getName() - полное имя класса или интерфейса
	
	ProtectionDomain getProtectionDomain() - возвращает домен защиты????
	
	boolean isInterface()
	
	T newInstance()		- создает объект того же типа на котором вызван,
						не сработает если нету стандартного конструктора или класс абстрактный
		throws (исключения)
		
	String toString() - строковое представление типа
	
****************************************************
из java.lang

--ClassLoader
определяет порядок загрузки классов, можно создать свой

****************************************************
из java.lang

--Math
статические методы и константы для математики

Math.PI, Math.cos() - и др.
Math.abs() - округление, нужно потому что одинаковые числа не равны по настоящему, а где-то далеко в двоичной форме не совпадают
ceil() - наименьшее целое которое меньше или равно указанного
floor() - наибольшее целое меньшее или равное указанному
floorMod() - округление остатка
floorDiv() - округление результата
max(x, y)
min(x, y)
random() - случайное от 0 до 1
signum() - знак
toRadians(), toDegrees() - рады в градусы и обратно
и много других

--StrictMath
	аналог Math повышенной точности, работает одинаково во всех реализациях Java
	
****************************************************
из java.lang

--Compiler
создание сред Java в которых код компилируется в исполняемый код, а не интерпретируемый
	обычно не используется

****************************************************
из java.lang

Runnable, Thread, ThreadGroup

--Runnable
Runnable - содержит только void run()

--Thread
Thread()
Thread(Runnable)
Thread(ThreadGroup)
Thread(ThreadGroup группа_потока, Runnable поток)
	Если группа потоков не указана, то запускаемый поток относится к той же группе что и родительский поток
	
Thread.MIN_PRIORITY, Thread.MAX_PRIORITY, Thread.NORM_PRIORITY

устаревшие методы (нельзя использовать):
stop()
suspend()
destroy()
resume()
countStackFrames() - в нем вызываются suspend и destroy

методы:
static void sleep()
void start()
void run()
final void join()
static Thread currentThread()

static int activeCount() - количества потоков текущей группы
static int enumerate(Thread потоки[]) - копирует все потоки из текущей группы в массив потоков
long getID() - id потока
final getName()
final getPriority()
Thread.State getThreadState() - состояние потока
final ThreadGroup getThreadGroup() - текущая группа
static boolean holdsLock(Object obj) - true если вызывающий поток владеет блокировкой obj
static boolean interrupted()
final Boolean isAlive()
final Boolean isDaemon() - демон поток или нет
final void setDaemon(boolean сщстояние) - помечает поток как демон
String toString()
static void yield() - может сделать паузу и позволить другим потокам начать исполнение

--ThreadGroup
ThreadGroup(String)
ThreadGroup(ThreadGroup parrent_group, String name)

методы схожи с методами Thread + дополнительные для группы
tg1.list(); - получить список потоков

Пример
	ThreadGroup tg1 = new ThreadGroup("группа 1");
	Thread t1 = new Thread();
	Thread t2 = new Thread();
	Thread tArr[] = new Thread[tg1.activeCount()];
	tg1.enumerate(tArr); //копируем ссылки потоков в массив
	for(Thread t : tArr)
		t.doSmth();
	
Можно добавить поток в группу так: Thread t1 = new Thread(tg1,new MyRunnable(),"one"); 
	
--ThreadLocal (могут спросить на собеседовании)
для создания локальных переменных потоков, у каждого потока - своя копия переменной

У каждого потока - т.е. экземпляра класса Thread - есть ассоциированная с ним таблица ThreadLocal-переменных. Ключами таблицы являются cсылки на объекты класса ThreadLocal, а значениями - ссылки на объекты, "захваченные" ThreadLocal-переменными.

то есть это коробочка в которую можно положить что-то внутри потока, а потом достать. Внутри других потоков содержимое не видно.
кладем set(obj)
достаем get()
удалем remove()
initialValue() - работает как конструктор, инициализирует

Для чего оно надо: переменная доступна для вытаскивания не только в run() но и в любом методе вызванном в run() без передачи ему ссылки на переменную (во всем текущем потоке).
Это как static переменные, но только не одна на класс, а одна на поток.

пример 1
	static final ThreadLocal userName = new ThreadLocal();

	public static void main(String... args) {
		userName.set("Jane"); //кладем значение
		Runnable run = new Runnable() {
			@Override
			public void run() {
				String threadName = Thread.currentThread().getName();
				String name = userName.get(); //вытаскиваем значение
				System.out.println(threadName +": Welcome "+name);
			}
		};
		run.run();
	}

пример 2 - применение initialValue
	public class ConnectionAccess {
		private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {
			public Connection initialValue() { //автоматически устанавливает значения всем созданным
				return DriverManager.getConnection(DB_URL);
			}
		};

		public static Connection getConnection() {
			return connectionHolder.get(); //вытаскиваем значение
		}
	}

--InheritableThreadLocal
создание локальных переменных потоков которые могут наследоваться
	то есть наследники могут вытащить значение???

	
****************************************************
из java.lang
--Package
содержит инфу о пакетах и набор методов для рефлексии (достование инфы о пакетах и инфы из аннотаций пакета)

Package pkg[];
pkg = Package.getPackages();

for(Package p : pkg) {
	p.getName();
	p.getImplementationTitle()
	p.getImplementationVendor()
	p.getImplementationVersion()
}

****************************************************
из java.lang
--RuntimePermition
относится к механизму защиты Java

****************************************************
из java.lang
--SecurityManager
	его наследуют для создания своих диспетчеров защиты
	System.getSecurityManager() - получаем текущий диспетчер защиты
	
****************************************************
из java.lang
--StackTraceElement - трассировка стэка
	содержит: название класс, метода, файла и номер строки с ошибкой
	массив таких объектов можно получить из класса Throwable
	
если номер строки с ошибкой не известен, то значение будет отрицательным
если номер строки == -2, то код вызвавший ошибку платформо ориентированный

****************************************************
из java.lang
--интерфейс CharSequence - реализующие его классы предаставляют через методы доступ для только чтения к элементам
charAt(int)
chars()
CodePoints()
length()
subSequence(int begin, int end)

****************************************************
из java.lang
--Enum
все перечисления автоматом наследуются от класса Enum
у этого класса нету открытых конструкторов
class Enum<E extends Enum<E>>
	E - перечисляемый тип
	
****************************************************
из java.lang
--ClassValue??? - применяется для связи значения с типом, не используется в обычном программировании
Class ClassValue<T>

****************************************************
из java.lang
--интерфейс Comparable<T> - для сравнения объектов
int compareTo(T obj) - переопределяемый метод
-1
0
1

class My implements Compareble<T>{
	public int compareTo(T ob) {
		if(ob.i == i) return 0;
		if(ob.i > i) return 1;
		else return -1;
	}
}
My m = new My();
m.compareTo(new My2());

****************************************************
из java.lang
--интерфейс Appendable (интерфейс-маркер?) - содержит метод append который реализуют некоторые классы для добавления
Appendable append(CharSequence chrs)
	возвращает ссылку на вызвавший объект, что дает возможно использовать цепочку вызовов
	
****************************************************
из java.lang
--интерфейс Iterable - должен быть реализован всеми классами которые нужно использовать в for each
interface Iterable<T>
	T - тип перебираемого в цикле
	
Iterator<T> iterator()
	возвращает итератор из вызывающего объекта
	
С JDK8:
добавились методы:
	default void forEach(Consumer<? super T> действие)
		- для каждого объекта вызывается метод из функции на которую указывает Consumer
	default Spliterator<T> spliterator()
		- возвращает Spliterator в виде итератора-разделителя
		
****************************************************
из java.lang
--интерфейс Readable - указывает на то, что объект можно использовать в качестве источника символов
int read(CharBuffer buffer) throws IOEception
	- только один метод, читает символы в буфер
	-1 - конец EOF иначе количество символов

****************************************************
из java.lang
--интерфейс AutoCloseable - только реализующие его классы можно использовать в try-с-ресурсами (другое название: авто управление ресурсами (ARM))
void close() throws IOException
	- единственный метод
	
Этот интерфейс реализуется несколькими классами. Включая ВСЕ потоки ввода-вывода, которые могут быть закрыты.

****************************************************
из java.lang
--интерфейс Thread.UncaughtExceptionHandler - реализуется в классах, в которых нужно обработать необрабатываемые исключения (реализован в ThreadGroup)

void uncaughtException(Thread поток, Throwable исключение)
	- единственный метод
	поток - вызвавший ошибку
	исключение - ссылка на исключение

****************************************************
пакет java.util
	Библиотека содержит классы для работы с: псевдослучайными числами, датами, событиями, форматированием данных (Formatter), работа со строками, битовыми массивами, коллекциями

1. Collection Framework (В ОПИСАНИЯХ КОЛЕЕКЦИЙ КОЕ-ГДЕ ПРОПУСТИЛ ОПИСАНИЯ Generics, ЧТОБЫ КОРОЧЕ БЫЛО: <? super T> и подобное)

	До этого каркаса использовались: Vector, Dictionary (аналог Map), Properties, Stack. Но у них нет общего интерфейса и поэтому они неудобны.
	ПОЗЖЕ классы: Vector, Stack, HashTable и др. были переделаны для поддержки коллекций.
	
	1. Он содержит реализации структур данных. И незаконченные реализации, которые потом можно реализовать самому.
	2. Содержит много разных алгоритмов для операции над коллекциями.
		Операции с коллекциями происходят через static методы Collection
	3. Содержит отоброжения (Map) пар ключ-значение. Они не являются коллекциями, но можно получить их "представление коллекции" и работать с ними как с коллекциями. (то есть преобразовать map в list)
	
	У каждой коллекции есть Iterator (это паттерн). Так что получить его методы можно использовать для любых коллекций.
	Начиная с JDK8: появились итераторы-разделители из интерфейса Spliterator и вложенные в него интерфейсы.
		Также появились итераторы для примитивных типов PrimitiveIterator и PrimitiveIterator.OfDouble

	С JDK5: появилась обобщения, автораспаковка-упаковка для коллекций, стили for each
			До обобщений использовался Object - типо-небезопасный
			Примитивные типы автоупаковываются, в коллекциях хранятся ТОЛЬКО ссылки.
			С for each теперь можно не использовать итератор, но итераторы по прежнему иногда нужны
			
	Интерфейсы коллекций:
		Collection - extends Iterable (НЕ Iterator) содержит методы для операция над коллекциями, его наследуют все остальные интерфейсы
		Queue - расширяет Collection, где удалять можно только элемент вначале
		Deque - расширяет Queue, двух сторонняя очередь
		List - расширяет коллекции для управления последовательностями объектов (списками объектов)
		Set - extends Collection, множества содержат только уникальные объекты
		SortedSet - extends Set, все элементы отсартированы
		NavigableSet - extends SortedSet, извлечение элемента по результатам поиска ближайшего совпадения (что это???)
		
		Также используются интерфейсы: Comparator, RandomAccess, Iterator, ListIterator, Spliterator(JDK8)
			Comparator - для сравнения двух объектов
			RandomAccess - эффективный произвольный доступ к объектам
			Iterator, ListIterator, Spliterator - перебирают объекты в коллекции
			Iterable - все кто его реализует можно перебирать в for each и Iterator
		
		Коллекции могут быть: изменяемыми и неизменяемыми. Все встроенные коллекции ИЗМЕНЯЕМЫЕ.
			UnsupportedOperationException - генерируется если коллекция не может быть изменена
			ClassCastException - объекты несовместимы по типу
			NullPointerException - добавление null
			IllegalArgumentException - неверный аргумент
			IllegalStateException - попытка добавления в уже полную коллекцию
		
	--Методы интерфейса Collection (наследуют все коллекции):
	boolean add(E obj)
	boolean addAll(Collection<? extends E> c)
	void clear() - удаляет всё
	boolean contains(Object obj) - содержиться или нет
	boolean containsAll(Collection<? extends E> c)
	boolean equals(Object ob)
	int hashCode()
	boolean isEmpty()
	Iterator<E> iterator()
	boolean remove(Object ob)
	boolean removeAll(Collection<?> c)
	boolean retainAll(Collection<?> c) - удалить все кроме
	int size()
	Object[] toArray() - КОПИИ массива объектов из коллекции, этот метод ХУЖЕ чем следующий (типонебезопасен)
	T[] toArray(T arr[]) - возвращает КОПИИ объектов коллекции массивом
				Если переданный массив меньше, то создаётся новый, если больше - лишние элементы будут null.
				Все элементы должны быть подтипами типа массива. Иначе ArrayStoreException
	С JDK8:
		default Stream<E> parallelStream() - возвращает поток использующий эту коллекцию для ввода-вывода, поддерживает параллельные операции
		default Spliterator<E> spliterator()
		default Stream<E> stream() - возвращает поток использующий эту коллекцию для ввода-вывода
		default removeIf(Predicate<? super E> pred) - удаляет элементы для которых условия в предикате true (фильтр, Predicate - функцианальный интерфейс)
		
	
	--List интерфейс - сохраняет последовательность элементов. Даёт доступ и вставку по индексу.
	Методы List расширяет Collection:
		add(int index, E obj) - вставка на позицию, при вставке элементы сдвигаются
		subList(int begin, int end) - возвращает под List
		ListIterator listIterator() - интератор
		ListIterator listIterator(int begin) - итератор для списка начиная с индекса
		C JDK8:
		default void sort(Comparator<? super E> comp) - сортирует список
						myList.sort(лямбда функция компоратора)
		default void replaceAll(UnaryOperator<E> apToApply) - принимает ссылку на функцию и применяет её ко всем элементам, результатом заменяя их
		
	--Set<E> интерфейс
		add( ) - возвращает false, если пытаются добавить элемент который уже есть в Set (одинаковый)
	
	--SortedSet<E> интерфейс
		first() - получить первый элемент
		last() - последний
		subset(E e, E e2) - подмножество (e - включительно, e2 - исключительно)
			headSet() - подмножество с первого
			tailSet() - с последнего
		Comparator<? super E> comparator() - возвращает компоратор Set, или null для естественного порядка (если не установлен?)
		
	--NavigableSet<E> интерфейс extends SortedSet - определяет поведение коллекции для извлечения элементов на основании наиболее точного совпадения
		C JDK 6
		
		E ceiling(E obj) - поиск наименьшего e по критерию e >= obj
		E floor(E obj) - наибольшего по e <= obj
		E lower(E obj) - наименьшего по e < obj
		E higher(E obj) - наибольшего по e > obj
		
		E poolFirst() - возвращает первый и удаляет его из мн-ва
		E poolLast() - последний
		
		NavigableSet<E> descendingSet() - обратный NavigableSet по отношению к вызвавшему NavigableSet
		Iterator<E> descendingIterator() - для перебора с конца
		
	--Queue<E> - пустой объект и элементы не разрешены
		E element() - вернет первый элемент, если очередь пуста - исключение
		E remove() - возвращает элемент и удаляет его, если очередь пуста - исключение
		boolean offer(E ob) - ПЫТАЕТСЯ ввести в очередь, не получилось - false (для очередей с фиксированным размером)
		
		E peek() - вернет первый элемент, если очередь пуста - null
		E poll() - возвращает первый элемент и удаляет его, если очередь пуста - null

	--Dequeue - двухсторонняя очередь, может работать как очередь или стэк (pop/push)
			(методы по аналогии с Queue)
		addFirst/addLast
		getFirst/getLast
		offerFirst/offerLast
		peekFirst/peekLast
		pollFirst/pollLast
		pop - возвращает из головы и удаляет элемент, если очередь пуста - исключение
		push() - вводит элемент в голову
		E removeFirst/removeLast
		
		boolean removeFirstOccurrence(Object ob)/removeLastOccurrence - удаляет первый встретившийся ob, если такого нет, то - false
		
		Iterator<E> descendingIterator()
		
	----Классы коллекций
		Часть классов - абстрактные.
		Обычно коллекции не синхронизированы, но есть синхронизированные варианты.
		
		AbstractCollection - реализует большую часть методов Collection
		AbstractList - реализует большую часть методов List
		AbstractQueue
		AbstractSequenceList
		LinkedList - связанный список (extends List, Deque, Queue)
		ArrayList - динамический массив
		ArrayDeque - динамическая двухсторонняя очередь
		EnumSet - для работы с enum
		HashSet - для работы множества вместе с хэш-таблицами
		LinkedHashSet - разрешает итерацию с выводом элементов в определенном порядке
		PriorityQueue - поддерживает очереди с приоритетом
		TreeSet - множество хранимое в древовидной структуре
		
	-------ArrayList
		ArrayList()
		ArrayList(Collection)
		ArrayList(int емкость) - автоматически увеличивается
		
		new ArrayList().add(obj);
		remove(obj)
		size()
		ensureCapacity() - ручное увеличение длинны массива
		trimToSize() - уменьшения длинный до размера == текущему количеству элементов
		Integer ir[] = a1.toArray(new Integer[a1.size()]); - преобразование в обычный массив
		
	-------HashSet - хэш-таблица
		Ключ - это хэш объекта. Создание хэша выполняется автоматом при добавлении. В ручную нельзя.
		Хэширование - обеспечивает постоянное время для выполнения add(), remove(), size() даже для больших множеств
		Никаких доп. методов в классе нет. И он НЕ ГАРАНТИРУЕТ упорядоченность элементов.
		
		HashSet(int емкость) - по умолчанию 16
		HashSet(int емкость, коээфициент_заполнения)
			коээфициент_заполнения_или_емкость загрузки - число от 0.0 до 1.0, показывает когда нужно расширять множество при заполнении
				если количество_элементов > емкость * коээфициент_заполнения --- происходить расширение
				коээфициент_заполнения == 0.75 по умолчанию
				
	-------LinkedHashSet
		LinkedHashSet - отличается от HashSet тем, что при переборе через Iterator элементы перебираются в порядке в котором были введены.
		
	-------TreeSet extends NavigableSet
		Сохраняет объекты отсортированными по нарастающей. Для быстрого поиска?
		
		TreeSet()
		TreeSet(Collection)
		TreeSet(SortedSet<E> ss)
		TreeSet(Comparator<? super E> compr) - можно задать свой Comparator по которому множество будет отсортированно
		
	-------PriorityQueue - очередь с приоритетом
		Нельзя перебрать элементы по порядку (какому-то конкретному) через Iterator. Нужно использовать offer() и poll()
		(то есть при добавлении элементов происходит их автоматическая сортировка так что min или max всегда вначале, а дальше по убыванию-возростанию???)
	
		PriorityQueue() - ёмкость по умолчанию == 11
		PriorityQueue(int емкость, Comparator<? super E> comp) - если Comparator не указан, то используется по умолчанию для нужного типа данных 
													(например если нужно сортировать по времени, можно переопределить)
		PriorityQueue(Collection)
		PriorityQueue(PriorityQueue<? extends E>)
		PriorityQueue(SortedSet<? extends E>)
		
		Comparator<? super E> comparator() - получить текущий компаратор или null, если по умолчанию
		
	-------ArrayDeque
		Массив без ограничений по емкости
			(Deque поддерживает реализации с ограничением емкости, но не накладывает ограничений на неё)
			
		ArrayDeque() - емкость по умолчанию 16
		
	-------EnumSet - для создания под-множества enum преминимого с ключами типа enum(???)
		Не имеет конструкторов. Вместо этого - фабричные методы.
		
		class EnumSet<E extends Enum<E>>
		Имеет кучу переопределенных методов .of() - для создания подмпножеств
		
		private enum Color {
			RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255);
		}
		EnumSet<Color> colors = EnumSet.of(Color.RED, Color.GREEN);
		for (Color c : colors) {}
		
	---BitSet???
		BitSet bits1 = new BitSet(16);
		BitSet bits2 = new BitSet(16);
		for(int i=0; i<16; i++) {
			if((i%2) == 0) bits1.set(i);
			if((i%2) == 0) bits2.set(i);
		}
		bits2.and(bits1);
		

	-------Работа с Iterator
		Iterator - для обхода коллекций. Можно извлекать/добавлять
		ListIterator - можно обходить коллекции с обоих концов
		
		МЕТОДЫ Iterator:
			E next()
			void remove()
			boolean hasNext()
		
		С JDK8:
			default void forEachRemaining(Consumer<? super E> действие) - можно передать указатель на функцию, которая по очереди применится к элементам в цикле. Она может изменять эти элементы.
		
		плюс МЕТОДЫ ListIterator:
				(с previous() - тоже только в обратную сторону)
			void add(E ob) - вводит объект, который будет возвращен следующим next()
			boolean hasPrevious()
			E previous()
			int nextIndex() - индекс следующего элемента, если конец списка - то размер списка
			int previousIndex()
			void set(E ob) - присваивает объект ob текущему элементу списка
			
		
		ArrayList<String> a1 = new ArrayList<>();
		//простой Iterator для получения значений
			Iterator<String> it = a1.iterator();
			while(it.hasNext()) {
				String s = it.next();
			}
			
		//изменить объекты
			ListIterator<String> lit = a1.listIterator();
			while(lit.hasNext) {
				String s = lit.next();
				it.set("new string");
			}
			
			//в обратном порядке
			ListIterator<String> lit = a1.listIterator();
			while(lit.hasPrevious) {
				String s = lit.previous();
			}
			
		---Spliterator - итератор-разделитель
			https://habrahabr.ru/post/256905/ - описание
			Тоже перебирает объекты. В основном используют в параллельной обработке коллекций (Stream API).
			В первую очередь служит для разделения потока на две равные половины. Которые потом можно обработать параллельно.
			
			Причем имеет свой СОБСТВЕННЫЙ (не Stream API) метод spltr.forEachRemaining((x) -> {...}):
				Он как бы обрабатывает каждый элемент потока в отдельных потоках одновременно.
			Но при этом можно:
				использовать метод: Stream s = StreamSupport.stream(spliterator);
				чтобы получить stream из spliterator (после разделения stream на две половины) и обработать его в отдельном потоке.
			
			Имеет поля int: DISTINCT, SIZED, STORED, IMMUTABLE, NONNULL, SUBSIZED, ORDERED. Получить характеристику можно с int characteristics(). Обычно это не нужно.
			Имеет вложенный интерфейсы Spliterator.OfDouble, Spliterator.OfInt, Spliterator.OfLong и подчиненный им Spliterator.OfPrimitive
			
			ДОПОЛНИТЕЛЬНО содержит МЕТОДЫ:
				int characteristics() - характеристика итератора (???)
				default boolean hasCharacteristics(int val) - возвращает true если характеристики итератора == val
				
				long estimateSize() - сколько осталось перебрать объектов
				default Comparator<? super T> getComparator() - компаратор используемый в Spliterator или null - если по умолчанию (если не задан - исключение)
				default long getExactSizeIfKnow() - если установлен размер итератора, то вернет количество оставшихся элементов, иначе == -1
				
				boolean tryAdvance(Consumer<? super T> action) - выполняет действие над следующим элементом (next), если следующий элемент существуе то == true
				Spliterator<T> trySplit() - разделяет итератор для разделения перебора, null - если разделить не удалось
				
				Пример:
					ArrayList<Double> a1 = new ArrayList<>();
					Spliterator<Double> spltr = a1.spliterator();
					while(spltr.tryAdvance((n) -> System.out.println(n + 1)); //аналог hasNext() + next() !!!
					spltr.forEachRemaining((n) -> System.out.println(n)) //действие над каждым элементом в отдельном потоке
					
					//преобразуем второй spliterator в Stream который можно обработать отдельно во втором потоке
					Spliterator<?> spltr2 = spltr.trySplit();
					Stream<?> stream2 = StreamSupport.stream(spliterator);
			
				Пример:
					DoubleStream b = DoubleStream.of(1.1,2.2,3.3,4.4,5.5);
					Spliterator.OfDouble o = b.spliterator();
					
		--------RandomAccess
			Маркер, не содержит методов. Показывает что коллекция поддерживает ЭФФЕКТИВНЫЙ ПРОИЗВОЛЬНЫЙ доступ к элементам (ИМЕННО эффективный, не медленный). Проверка производится через instanceof.
			Этот интерфейс реализован в ArrayList и Vector
			
		---Отоброжения (Map, Dictionary) - пары ключ-значение
			НЕ РЕАЛИЗУЕТ Collection, хотя является частью фрэймворка Collection
			НЕ РЕАЛИЗУЮТ Iterable - нельзя использовать Iterator или цикл for each. Но можно преобразовать в коллекцию.
			Ключом может быть любой наследник Object.
			
		Интерфейсы:
			Map
			Map.Entry
			SortedMap - ключи по расположены нарастающей (сортированы)
			NavigableMap - extends SortedMap - аналог NavigableSet, можно получить элемент по ближайшему совпадению
			V get(Object key)
			
		---Map
			МЕТОДЫ:
				void clear() - очищает коллекцию
				boolean containKey(Object ob)/containValue(Object ob) - содержит ли такой ключ/значение
				Set<Map.Entry<K, V>> entrySet() - преобразует Map в Set
				equals(obj) - сравнение двух Map
				int hashCode()
				isEmpty()
				Set<K> keySet() - множество ключей
				V put(K k, V v)
				void putAll(Map<? extends K, ? extends V> m) - добавить элементы из другой Map
				int size()
				Collection<V> values() - вернет Map в виде коллекции
				
			
				С JDK8:
					compute(), computeIfAbsent(), computeIfPresent(), forEach(), merge(), replaceAll()
							- принимает указатель на функцию, которая применяется к значению
					default V getOrDefault(Object key, V val) - объект по ключу, если его нет - по умолчанию вернет val
					default boolean remove(Object k, Object v) - если не найдено - false
					default boolean replace(K k, V prev, V new)
									replace(K k, V v)
					
		---SortedMap
			Comparator comparator() - вернет текущий Comparator или null если использован естественный порядок
			K firstKey() - первый ключ
			K lastKey()
			SortedMap<K, V> headMap(K end) - вернет ключи SortedMap для которых ключи меньшие end
							tailMap(K begin) - больше begin
			SortedMap subMap(K begin, K end) - все элементы (key >= begin && key < end)
			
		---NavigableMap
			методы по аналогии с NavigableSet
			
		---Map.Entry
			вложенный интерфейс в Map
			Для работы с отдельными элементами Map
			
			С JDK8:
				static Comparator comparingByKey()/static Comparator comparingByValue()
					- вернет Comparator для сравнения по ключам, значениям
			
			//вроде как используется для работы с преобразованными Map в Set???
			for (Set<Map.Entry<String, JButton>> entry : listbouton.entrySet()) {
			  String key = entry.getKey();
			  JButton value = entry.getValue();

			  this.add(value);
			}
					
					
		---КЛАССЫ отображений:
			AbstractMap - реализация большей части Map
			EnumMap - extends AbstractMap - для работы с ключами enum
			HashMap - extends AbstractMap - для работы с хэш-таблицами
			TreeMap - extends AbstractMap - для хранения в древовидной структуре
			WeekHashMap - extends AbstractMap - для работы со слабыми ссылками
							позволяет собирать содержащиеся в ней объекты, как мусор когда её ключ больше не используется
			LikedHashMap - extends HashMap - итерация (перебор) элементов в определенном порядке
			IdentityHashMap - extends AbstractMap - использует результат проверки ссылок на равенство при сравнении документов (???)
			
		---HashMap (хэширование автоматическое, хэшируется КЛЮЧ?)
			Для хранения используется хэш табл., что даёт постоянное время выполнения get() и put()
			емкость по умолчанию - 16
			HashMap(Map m)
			HashMap(int емкость, float кэффициент_заполнения)
				кэффициент_заполнения == 0.75
			
			HashMap<String, Double> hw = new HashMap<>();
			hw.put("new", new Double(0));
			hw.get("new");
			Set<Map.Entry<String, Double>> set = hm.entrySet(); //преобразуем Map в Set
			
		---TreeMap extends NavigableMap
			Хранит данные в дереве отсортированному по ключам (нарастанию)
			
			TreeMap(Comporator cmp) - задаем свой Comparator
			TreeMap(Map m)
			
		---LinkedHashMap
			Список в хранит элементы порядке добавления элементов
			
			LinkedHashMap()
			LinkedHashMap(Map m)
			LinkedHashMap(int емкость, float коэффициент_заполнения, boolean порядок)
				емкость == 16
				коэффициент_заполнения == 0.75
				порядок == true - порядок доступа, false - порядок ввода элементов
				
			protected boolean removeEldestEntry(Map.Entry<K, V> e)
				- вызывается из put() и putAll()
				e - самая старая запись
				По умолчанию не делает ничего, только возвращает false
				Но если его переопределить, то можно удалить самую старую запись из LinkedHashMap. Для этого переопределенный метод должен вернуть true
				
		---IdentityHashMap
			Аналог HashMap, но используется сравнения ссылок на равенство (вместо equals???)
			НЕ ИСПОЛЬЗУЕТСЯ в общих случаях.
			
		---EnumMap - enum в качестве ключей
			
			EnumMap(Class<K> type)
			EnumMap(Map m)
			EnumMap(EnumMap em)
			
			enum Importance {
				Low, Medium, High, Critical
			}
			EnumMap<Importance, String> e = new EnumMap<>(Importance.class);
			e.put(Importance.Low, "=Low");
			e.put(Importance.High, "=High");
			String value1 = e.get(Importance.Low);
			Set<Size> set = e.keySet(); // преобразование в Set
			
	
	------Comporator
		Интерфейс. Наследуем и переопределяем в классе способ сравнения.
		Если метод возвращает Comporator, то его можно использовать в цепочки сравнений.
		
		class MyCmp implements Comporator<String> {
			int compareTo(Object ob1, Object ob2) {
				return 0; //равно
				return -1; //меньше
				return 1; //больше
			}
		}
		Collection.sort(list, new MyCmp());
	
		Имеет методы:
			boolean equals(Object ob)
			int compare(T ob1, T ob2)
			
		C JDK8:
			default Comporator<T> reversed() - вернет Comporator с обратным упорядочиванием???
			static default Comporator reversedOrder() - обратный порядок сортировки
			static default Comporator naturalOrder() - естественный порядок сортировки
			
			static Comporator nullsFirst(Comporator comp) - вернет Comporator для которых null == min
								nullsLast() - null == min
			НО если компоратору передаются оба null - то они считаются равными???
			
			default Comparator comparing() - принимает указатель на функцию которую использует для сравнения?
			
			default Comparator thenComparing(Function получить_ключ) - если первое сравнение дало равно, то после него эта функция может провести второе сравнение (другое)
				также есть спец. варианты: thenComparingDouble, thenComparingInt и др.
			
			Пример:
				//простое использование
				Collections.sort(list, new MyComporator());
			
				Collections.sort(playlist1,
					 comparing(p1 -> p1.getTitle())
						 .thenComparing(p1 -> p1.getDuration())
						 .thenComparing(p1 -> p1.getArtist()));
				
				//создаем компоратор на месте
				Comporator<String> mc = (aStr, bStr) -> aStr.compareTo(bStr);
				
				//создание сравнения, которое происходит после того как первое дало равенство
				Comporator<String> mc2 = mc.thenComparing(new MyComp2);
				Collection.sort(arr, mc2); //использование сначало mc, потом mc2
				
				//задаем свой компоратор в TreeSet
				TreeSet<String> ts = new TreeSet<>(
					(aStr, bStr) -> aStr.compareTo(bStr)
				);
		
		
		-----Алгоритмы Collection
			Определены в static методах!
			
			1.
			static checkedCollection(), checkedList(), checkedSet() и т.д. - создатут коллекции которые автоматически проверяют тип объектов при добавлении.
			Collection.checkedCollection();
				- этими методами нужно пользоваться на этапе отладки
				
			2. synchronizedList(), synchronizedSet() - создают 	потоко-безопасные копии коллекций
			
			3. Методы НАЧИНАЮЩИЕСЯ с unmodifiable - возвращают коллекции которые не могут быть изменены.
					Нужны например для только чтения.
					
			4. static переменные EMPTY_SET, EMPTY_LIST, EMPTY_MAP - они неизменяемы
			
			5. Имеет кучу методов типа swap, shuffle(), replace(), min(), max() и др. для работы
			
			static Enumeration<T> enumeration(Collection<T> c) - перечисление элементов коллекции
			
		---Arrays - набор методов для работы с массивами
			static <T> List asList(T... arr) - преобразует массив в List
			
			static int binarySearch(Object arr[], Object val) - поиск значения в массиве, вернет индекс или -1 - если нету.  Для ОТСОРТИРОВАННЫХ массивов?
			static int binarySearch(простой_тип arr[], простой_тип val)
			static <T> int binarySearch(T arr[], T val, Comparator c)
				Если значения НЕЛЬЗЯ сравнивать (напр. Double и StringBuffer), то исключение ClassCastException
			
			static простой_тип[] copyOf(простой_тип[] источник, int длина) - создаст копию массива
			static <T> T[] copyOf(T[] источник, int длина)
			static <T, U> T[] copyOf(U[] источник, int длина, Class<? extends T[]> результирующий_тип)
				ЕСЛИ копия длиннее, то лишние элементы инициализированны по умолчанию
				
			static простой_тип[] copyOfRange(int[] источник, int начало, int конец) - как и copyOf, но можно указать приделы массива
					скопирует массив от начало до конец-1
			//и подобные методы
			
			static equals(arr[], arr2[]) - сравнивает два массива
			//и подобные методы
			
			static deepEquals(arr[], arr2[]) - сравнивает массивы, которые содержат другие массивы
			
			static void fill(тип arr[], тип val) - заполняет весь массив arr значением val
			
			static void sort(тип arr[]) - сортирует массив по возростанию
			static <T> void sort(T arr[], Comporator<? super T> c) - можно задать своё сравнение
				sort(double[] a, int fromIndex, int toIndex) - приделы в которых нужно отсортировать массив
			
			С JDK8:
				static void parallelSort(тип[] arr) - сортирует сначало части массива, а потом целиком. Быстрее.
					(вроде как НЕ связан с парелельным Stream API, а просто быстрая сортировка)
			
				static Spliterator spliterator(int[] arr) - можно перебирать массив через spliterator.
					spliterator(int[] arr, int fromIndex, int toIndex) - можно указать в каких пределах перебирать
				
					Пример: Spliterator.ofDouble spliterator(double arr[]) - для double
					
				static DoubleStream stream(double []arr) - возвращает реализацию Stream, какой-то поток (для Stream API???)
				static IntStream stream(int arr[])
				static LongStream stream(long arr[])
				static <T> Stream  stream(T arr[])
				static <T> Stream  stream(T arr[], int fromIndex, int toIndex) - с пределами
				
				static void setAll(double[] arr, IntToDoubleFunction <? extends T> генератор_значений)
					- присваивает значения всем элементам
				parallelSetAll(...) - тоже самое, только параллеьльная
				
				static void parallelPrefix(double arr[], DoubleBinaryOperator func) - изменяет значения массива так, что следующие вычисляется на основе предыдущих (напр каждый элемент это умноженный на 2 предыдущий и т.д.)
				
				toString()
				hashCode()
				deepToString() - для массивов содержащих вложенные массивы
				deepHashCode() - для массивов содержащих вложенные массивы
				
		---Унаследованные (устаревшие) классы коллекций.
			Хотя они устарели, но они переделаны так, что теперь совместимы с Collection
			До JDK1.2 все они были синхронизированными. А после - НЕТ!
			
			Классы: Dictionary, Hashtable, Properties, Stack, Vector
			Интерфес: Enumeration
			
			--Enumeration - аналог Iterator, не рекумендуется, но иногда используется
				boolean hasMoreElements()
				E nextElement()
				
			--Vector
				Vector()
				Vector(int размер) - по умолчанию 10
				Vector(int размер, int инкремент) - инкремент - сколько элементов резервируются после каждого нового добавления
					(если не указать инкремент размер памяти каждый рах будет удваиваться - медленно)
				Vector(Collection c)
				
				имеет все методы List + свои методы
				
				//МОЖНО ИСПОЛЬЗОВАТЬ Iterator или for ( : )!!!!
				пример:
					Vector<Integer> v = new Vector<>();
					Enumeration<Integer> e = v.elements();
					while(e.hasMoreElements()) {
						e.nextElement().toString();
					}
				
			--Stack - реализация стэка.
				Его по прежнему можно использовать, он рекомендуется.
				НО ЛУЧШЕ использовать ArrayDeque!
			
			--Dictionary (абстрактный) - аналог Map.
				По прежнему может употребляться. Но он просто дублирует Map.
				НЕ ПОДДЕРЖИВАЕТ лямбда выражения.
				
				Enumeration<K> keys()
				
			--Hashtable (реализация Dictionary) - аналог HashMap, НО СИНХРОНИЗИРОВАН
				Не поддерживает Iterator!
			
				Hashtable(int размер, float коэффициент_заполнения)
				- по умолчанию размер == 11, коэффициент_заполнения == 0.75
				
				имеет методы Map + свои
				
				//преобразование в Set
				Set<String> set = new Hashtable<String, Double>().keySet();
				
			--Properties (реализует Hashtable)
				Отличие: ключами являются String
				НЕРЕКОМЕНДОВАННЫЙ МЕТОД: save() заменен на store()
				
				getProperty(String)/getProperty(String, String значение_по_умолчанию) - получить значение свойства
				setProperty(ключ, значение)
				list(PrintStream), list(PrintWriter) - выводит свойства в поток
				load(PrintStream), load(PrintWriter) - загружает из потока
				loadFromXML(InputStream) - загружает свойства из XML
				Enumeration propertyNames()
				store(OutputStream, String описаение), store(Writer, String описаение),storeToXML()
					- выводи строку ОПИСАНИЕ, а потом список свойств
				
				Set<String> stringPropertyNames() - множество свойств
				
				//пример
				Properties p = new Properties();
				p.put("Илинойс", "Спрингфилд");
				Set<?> state = p.keySet();
				
				//загрузка свойств из файла
				Properties p = new Properties();
				p.load(new FileInputStream("phones.dat");
				String s = p.getProperty("Илинойс");
				p.store(new FileOutputStream("phones.dat"), "Телефонная книга");
			
****************************************************
java.util ЧАСТЬ 2 (служебные классы)

--StringTokenizer (extends Enumeration)
	Разделение текста на части (лексемы) по заданному разделителю (или нескольким)

	StringTokenizer s = new StringTokenizer("val=5;val2=6;", "=;");
	while(s.hasMoreTokens()) {
		String key = s.nextToken();
		String val = s.nextToken();
	}

--BitSet
	Для работы с битовыми массивами (которые представлены true или false)
	
	BitSet(int размер)
	//куча методов для работы над битами or, and, xor etc
	
	При toString() показываются номера на которых биты равны 1 (true)
	{0, 3, 4, 6} //== 1001101
	
--(Появился с JDK8) Optional, OptionalDouble, OptionalInt, OptionalLong
	Нужны, Чтобы не возвращать null и не проверять в случае пустых значений на null.
	Лучше не использовать в передаче в качестве аргумента методу.
	
	//Пустой Optional объект
	Optional<Person> optionalPerson = Optional.empty();
		
	//Optional объект с ненулевым значением
	Optional<Person> optionalNonNull = Optional.of(somePerson);
			
	//Optional объект с возможностью нулевого значения
	Optional<Person> optionalNullable = Optional.ofNullable(somePerson);
	
	//две строки одно и тоже
	String streetName = person.flatMap(Person::getAddress)
	//обычная запись
	String streetName =  if(person != null) getAddress(person);
	
	//две строки одно и тоже
	Person personNew = person != null ? person : new Person();
	//запись с Optional<Person>
	Person personNew = person.orElse(new Person());
	
--Date, Calendar и работа с датами, Locale - локаль
	Имеются некоторые методы с JDK8, и для работы с пакетом java.time

Date - инкапсулирует число от 1 янв 1970 года в милисекундах.

Помимо описанных ниже классов существуют: DataFormat, SimpleDataFormat и др.

методы:
	long getTime() - число в милисекундах
	Object clone()
	int compareTo(Date date)
	String toString() - дата в удобном виде
	и др.
	
-Calendar - абстрактный класс описывает методы, которые могут представлять Data в удобном виде или менять её значения
	- имеет методы и константы для работы со временем
	GregorianCalendar - реализация для Грегорианского календаря
	
	Начиная с JDK8:
		появились константы с суфиксом FORMAT и STANDALONE
		final Instant toInstant()
	
	Пример:
	Calendar c = Calendar.getInstance();
	//установить текущее время
	c.set(Calendar.HOUR);
	//установить своё время
	c.set(Calendar.HOUR, 10);
	c.set(Calendar.MINUTE, 29);
	//вывод
	System.out.println(c.get(Calendar.HOUR));
	System.out.println(c.get(Calendar.MINUTE));
	
-GregorianCalendar - реализация Calendar для Грегорианского календаря
	AD и BC - обозначают эры
	
	GregorianCalendar(int год, int месяц, int день, int час, int минута, int секунда)
	GregorianCalendar(TimeZone часовой_пояс, Locale региональные_настройки)
	
	Методы:
		boolean isLeapYear(int год) - високосный год или нет
		В JDK8 появились доп. методы
	
	//по умолчанию текущая дата, региональные настройки и пояс
	GregorianCalendar c = new GregorianCalendar();
	System.out.println(c.get(Calendar.HOUR));
	
-TimeZone
	- операции со временем учитывая пояса, учитывая летнее время
	GMT == UCT - это Гринвич == универсальное скоординированное время
	
	методы:
		static String[] getAvailableIDs() - названия всех часовых поясов
		TimeZone getDefault()
		
-SimpleTimeZone - реализация TimeZone, можно работать с Григорианским календарем
SimpleTimeZone(int смещение_от_Гринвича,
				String имя_пояса,
				
				//0 - начало летнего времени, 1 - окончание летнего времени
				//режим времени определяет как интерпретируется величина времени:
				//описать что такое???
				//STANDART_TIME
				//WALL_TIME - по умолчанию
				//UTC_TIME
				int мес0, int дней_месяца0, int день0, int время0, int режим_времени0,
				int мес1, int дней_месяца1, int день1, int время1, int режим_времени1,
				
				int разница_в_летнее_время
);


--Locale
	Описывает гео. и культурный регион. Для даты, времени, чисел.
		Этот класс использую для интернациализации многие классы.
		
		Locale(String язык, String страна, String вариант)
		
		Locale.CANADA - и подобные обозначают локаль
		
		Методы:
			static void setDefault(Locale l) - установка локали по умолчанию в JVM
						getDefault
			final String getDisplayCountry()
			final String getDisplayLanguage()
			final String getDisplayName()
			
			getScript() - получить сценарий региональных настроек, для BCP 47 и UTS 35
			toLanguageTag() - установка в дискриптора языка
			
		Начиная с JDK7:
			Поддержка стандарт дескрипторов для идентификации языков Internet Engineering Task Force (IETF) BCP 47
			Поддержка стандарт Unicode Technical Standard (UTS) 35 - язык разметки региональных данных (LSML)
			Новый Класс Locale.Builder - для правильного создания Locale с стандартами BCP 47 и UTS 35 (конструктор Locale не обеспечивает их проверку)
			
		Начиная с JDK8:
			методы для фильтрации, обработки исключений, поиска

--Random
	Генератор псевдослучайных чисел
	??? Описать класс SecureRandom для генерации правда случайных чисел???
	
	Random()
	Random(long i)
	
	ЕСЛИ инициализировать разные Random одинаковыми числами - получится ТАКАЯ ЖЕ последовательность. Поэтому надо использовать разные. Для этого можно использовать текущее время.
	
	методы:
		nextInt()
		nextLong()
		nextDouble()
		nextBoolean()
		nextBytes()
		double nextGaussian() - кривая нормального распределния, с отклонением 1.0 от центральной точки 0.0
		setSeed(long i) - установить начальное число
		
	Пример:
		Random r = new Random();
		double n = r.nextGaussian();
		
	Начиная с JDK8:
		DoubleStream doubles(), IntStream ints(), LongStream longs() - методы для работы с API потоковыми данными. Они возвращают сылку на поток содержащий последовательность случайных чисел. Эти потоки бесконечны.
		
--Observable, Observer
	Для создания классов слушателей. Реализация паттерна Слушатель
	
	Чтобы создать наблюдателя нужно реализовать интерфейс Observer с методом update(). Он вызывается когда наблюдатель получает сообщение о изменении Observable.
		void update(Observable obsv, Object arg)
	
	Чтобы реализовать Observer нужно:
		1. Если Observable изменяется, то должен вызвать setChanged()
		2. notifyObsservers() - когда надо известить о изменении Observer
			ЕСЛИ вызвать метод notifyObsservers(arg), то arg передастся ВТОРЫМ параметром в метод update()
			ИНАЧЕ вторым параметром будет null
		НУЖНО ВЫЗЫВАТЬ ОБА МЕТОДА
		
	Методы:
		разные, удаление/добавление слушателя и т.д.

--Timer и TimerTask
	Можно создать поток и запустить по таймеру в будущем (упрощают по сравнению с чистым Thread)
	
	Timer - запуск задания
	TimerTask - описание задания (реализует Runnable())
	
	Timer(String имя_потока, boolean демон_ли)
		демон выполняется пока работает запустившая его программа
	
	методы TimerTask:
		boolean cancel() - прерывает задание
		abstract void run()
		
	методы Timer
		boolean cancel() - прерывает таймер планировщика (задание не запустится?)
		int purge() - удаляет прерванное задание из очереди
		void schedule(TimerTask задание, long ожидание, long повтор)
		void schedule(TimerTask задание, Date заданное_время, long повтор) - время повтора относительно ПОСЛЕДНЕГО запуска
		scheduleAtFixedRate(...) - тоже самое, но время повтора фиксированно относительно САМОГО ПЕРВОГО запуска
		
	class MyTimerTask extends TimerTask {
		public void run() {
			//do smth
		}
	//main
		new Timer().schedule(new MyTimerTask(), 1000, 500);
		
--Currency
	Инкапсулирует сведения о валюте.
	НЕ ИМЕЕТ конструктора.
	
	Currency c = Currency.getInstance(Locale.US)
	c.getSymbol(); //символ $
	c.getDefaultFractionDigits(); //длинна дробной части
	//getCurrencyCode() и много др. методов.

--Formatter
	Аналог printf() в C++
	
	Как работает: сохраняет форматированный текст в буфер, текст доступен программе в любой момент.
	Можно: указать ему свой буфер, использовать буфер по умолчанию, указать выводить содержимое буфера в File
		Если задать буфер пустым, будет использован StringBuffer
		Если не задать регион, будет по умолчанию для JVM
		
	Его ОБЯЗАТЕЛЬНО закрывать close() (если не try-с-ресурсами c JDK7)
	У него есть более удобный аналог: метод printf() из PrintWriter и PrintStream
		
	Formatter()
	Formatter(Appendable buffer, Locale l)
	Formatter(String имя_файла)
	Formatter(String имя_файла, String набор_символов) - набор_символов - используймый набор символов
	Formatter(File файл_вывода)
	Formatter(OutputStream поток_вывода)
	//и др. конструкторы
	
	методы:
		void close()
		void flush() - в основном используется если указан файл
		Formatter format(Locale l, String формат_строки, Object ... args)
		Appendable out() - возвращает адресата для выводимых данных
		и др.
	
	Пример:
	Formatter f = new Formatter();
	f.format("%d %d", i, i);
	String s = f.toString();
	f.close();
	
	--Таблица
		%a %A	- hex дробное
		%b %B	- булевское
		%c		- символ
		%d		- целое
		%h %H	- hashCode() объекта
		%e %E	- экспотенциальное представление числа (умнодить на e в степени)
		%f		- дробное
		%g %G	- выбирает автоматом %e или %f в зависимости от форматируемого значения и заданной точности
			По умолчанию ТОЧНОСТЬ 6 цифр!!!
		%o		- восьмиричное целое
		%n		- знак \n перевода строки
		%s %S	- String
		%t %T	- время и дата
		%x %X	- hex целое
		%%		- знак %
		Прописные буквы в признаках приводят к отображению признаков формата и символов в верхнем регистре:
			ABC, 0X123P9
			
	Примечание: Для вывода числа в двоичном вормате можно использовать Integer.toBinaryString(124)
		
	Общий вид hex чисел с плавающей точкой:
		(неясно - загуглить)
		0x1.sig p exp
			sig - содержит дробную часть мантиссы
			exp - показатель степени
			p - степень показателя степени
			
		fmt.format("%a", 512.0);
		//вывод: 0x1.0p9
			
	Форматирование времени и даты: куча параметров для этого (ПОТОМ можно дописать всю таблицу)
		Пример:
		Calendar c = Calendar.newInstance();
		fmt.forrnat("%tB %tb %trn", cal, cal, cal);
		//вывод: January Jan 01
		<<<В Шилдте есть дополнительная таблица для форматирования даты: типа %d, %f и т.д., но для дат>>>
	
	Указание минимальной ширины поля:
		f2.format("%12f", 10.12345) //вывод: "   10.123450"
		f1.format("%012f", 10.12345) //вывод: "00010.123450" - заполнением нулями (НОЛЬ ПОСЛЕ %!!!)
		
	Указание точности:
		f.format("%.4", 12.12345) - 4 цифры после запятой
		f.format("%5.7s", "mystring") - минимум 5 символов, но не больше 7 символов
		
	Признаки формата (после знака %):
		- - выравнивание по левому краю (%-10.2f)
		# - алтернативный формат преобразования
			применяется с %x, %o, %e, %f: с этим знаком будет вывод: 0xF9, 084, 123.
			(то есть вывод с hex, oct, dec признаками)
		0 - выводимые данные дополняются нулями
		пробел - положительные числа выводятся с предшевствующим пробелом (% в)
			-100
			 100
		+ - положительные числа выводятся с предшествующим плюсом
		, - числовые значения содержат групповые разделения
			fmt.format("%,.2f",4356783497.34); //вывод: 4,356,783,497.34
		( - отрицательные числовые значения заключаются в круглые скобки
		ОНИ ПРЕМЕНЯЮТСЯ НЕ КО ВСЕМ СПЕЦИФИКАТОРАМ
		
	
	Применение с индексами аргумента:
		fmt.format("%3$d %1$d %2$d", 10, 20, 50); //50 10 20
		
		//можно вывести повторно первый аргумент
		fmt.format("%d %1$d, 10) //10 10
		//тоже самое, использовать предшествующий индекс
		fmt.format("%d %<d, 10) //10 10 (напр: можно вывести одну дату в разных форматах)
		
--Scanner
	Для чтения из потока, файла, String или другого объекта который реализует интерфейс Readable или RadableByteChannel.
	(в том числе читает с консоли)
		Входные данные разбиваются регулярками на куски и читаются по очереди методом next()
	1.	
	Scanner тоже НУЖНО ЗАКРЫВАТЬ методом close()
	2.
	СВЯЗАННЫЙ со Scanner поток НЕ НУЖНО закрывать. ОН ЗАКРЫВАЕТСЯ АВТОМАТИЧЕСКИ при закрытии Scanner
	ЕСЛИ связанных объект РЕАЛИЗУЕТ Closeable интерфейс. (Readable внутри закрывается)
		(то есть FileReader закрылся при вызове close() для Scanner, его не нужно закрывать отдельно)
	3.
	Методы nextDouble() - читает и double и int (т.к. его можно преобразовать). За этим НУЖНО СЛЕДИТЬ.
	4.
	Начиная с JDK7 Scanner можно использовать в try с ресурсами (реализует интерфейс AutoCloseable)
		try(new Scanner){}catch(Exception e){}
	5. Разделитель по умолчанию - ПРОБЕЛ
	
	FileReader fr = new FileReader("file.txt"); //FileReader реализует Readable
	Scanner s = new Scanner(fr); //Scanner(Readable)
	s.close(); //закрыли только Scanner
	
	Scanner s = new Scanner(System.in);
	Scanner s = new Scanner("file.txt");
	Scanner s = new Scanner("file.txt", String набор_символов); //набор_символов - кодировка
	canner s = new Scanner(String откуда); //откуда - источник
	
	Пример:
	//чтение с клавы
	Scanner s = new Scanner(System.in);
	while(s.hasNextInt()) {
		i = s.nextInt();
	}
	s.close();
	
	методы:
	hasNextLine() - для чтения String
	hasNext(Pattern шаблон) - true если следующая порция совпала с шаблоном
	hasNext() - для любого типа (до пробела ПО УМОЛЧАНИЮ)
	String next() - для любого типа (если не известна)
	Scanner useDelimiter(Pattern p) - установка разделителей через метод
	String findInLine(Patter p) - поиск совпадения в следующей строке текста, не зависит от разделителя
	String findWithinHorizont(Pattern p, int n) - поиск в n количестве символов (если n==0 - поиск везде)
	skip(Pattern p) - если шаблон найден пропускает его, если не найден - исключение
	useRadix() - установить систему счисления для Scanner
		reset() - сбросить систему счисления по умолчанию
	и куча др. для разных типов
	
--ResourceBundle, ListResourceBundle, PropertyResourceBundle
	Хранят строчки перевода для разных интернализаций и могут быстро переключаться между ними.
	Могут хранить строчки в коде (массивах) или .properties файлах
	
	Ru_ru - значит имяЯзыка_семействоЯзыка
	Можно также задать язык кодом страны RU
	
	ISO 639 - стандарт кодов языка
	ISO 3166 - стандарт кодов стран
	
	1. ResourceBundle НЕ ДОПУСКАЕТ пустые строки в параметрах языка
	2. Начиная с JDK6 появился ResourceBundle.Control для управления загрузкой коплекта ресурсов
	
	Методы:
		Содержит кучу методов для установки группы языков, переключения между ними, получения их списка и сведений о них.
		Set<String> getKeys()
		Locale getLocale()
		setParent(ResourceBundle rb) - устанавливает родительский ресур, если ключ не найден в текущем, то будет поиск в родительском (то есть фактически связывает два ресурса языков)
		
	1. PropertyResourceBundle - читает набор языков из .properties файла
	2. ListResourceBundle имеет abstract метод 
		protected abstract Object[][] getContents() - который возвращает массив языков между которыми можно переключаться
		
	Пример:
		public class MyEn extends ListResourceBundle {
			protected Object[][] getContents() {
				Object[][] resource = new Object[3][2];
				
				resource[0][0] = "title";
				resource[0][1] = "Main progr";
				
				resource[1][0] = "StopText";
				resource[1][1] = "Set";
				
				resource[2][0] = "StartText";
				resource[2][1] = "Unset";
			}
		}	
		
		public class MyEn_us extends ListResourceBundle {
			protected Object[][] getContents() {
				Object[][] resource = new Object[3][2];
				
				resource[0][0] = "title";
				resource[0][1] = "Main progr USA";
				
				resource[1][0] = "StopText";
				resource[1][1] = "Set";
				
				resource[2][0] = "StartText";
				resource[2][1] = "Unset";
			}
		}	
		
		public static void main(String []args) {
			ResourceBundle rb = ResourceBundle.getBundle("MyEn_en");
			System.out.println(rb.getString("title")); //"Main progr"
			
			//загрузить комплект языка США
			//!!! По Locale выбирается class с нужным префиксом _us в названии?
			rb = ResourceBundle.getBundle("MyEn", Locale.USA);
			System.out.println(rb.getString("title")); //"Main progr USA"
		}
		
-- Другие классы пакета java.util
	Base64 - работа с кодировкой base64
	DoubleSummaryStatistics - добавлен в JDK8 для работы с статистикой (данные типа double). Максимальное, минимальное, среднее, итог и т.д.
	IntSummaryStatistics - тоже для int
	EventListenerProxy - расширяет EventListener для доп. параметров (что такое???)
	EventObject - suoer class для всех событий
	FormatableFlags - признаки форматирования для Formatter
	Objects - разные методы для работы с объектами (нужно описать популярные?)
	PropertyPermission - управление правами доступа к свойствам
	ServiceLoader - средства для поиска поставщиков услуг (что такое???)
	UUID - можно работать с уникальными идентификаторами (удобная штука если надо присвоить чему-то id). В том числе случайное.
	
	Интерфейсы:
	EventListener - маркер приемника событий
	Formattable - маркер класса который что-то форматирует
	
--Подпакеты
	java.util.current
	java.util.current.atomic
	java.util.current.locks
		- альтернативные производительные средства синхронизации потоков, а с JDK7 фреймворк для работы с потоками Fork/Join Framework
		
	java.util.function
		- функциональные интерфейсы, готовые которые используются в Java API
			(т.е. готовые ссылки на методы, чтобы самому не определять)
		- могут иметь методы по умолчанию default и static методы
		
		cunsumer - то что принимает значения (потребляет) и НЕ ВОЗВРАЩАЕТ результат
			DoubleConsumer void accept(double d)
		function - то что оперирует РАЗНЫМИ (или одним) объектами и даёт результат
			Double R apply(
		operator - опирирует двумя ОДНОТИПНЫМИ объектами и даёт результат
		predicate - принимает разные объекты и ВОЗВРАЩАЕТ BOOLEAN
		supplier - НЕ ПРИНИМАЕТ ПАРАМЕТРЫ (объекты), сам что-то делает и возвращает результат
			Приставки:
				Bi - если принимает 2 аргумента
				To - если приобразует объект в другой
				Unary - если оперирует только одним параметром
				
	java.util.jar
	java.util.logging - встроенный логер (который никто не использует потому что он плохой)
	java.util.prefs - какие-то глобальные настройки программ (что такое???)
	java.util.regex
	java.util.spi - поставщики услуг (что такое???)
	java.util.stream - начиная с JDK8, интерфейс потокового ввод/вывод
	java.util.zip - для zip/gzip
	
--I/O
java.io пакет

-Интерфейсы-маркеры потоков
	Closeable (JDK5) - можно закрывать поток
	Flushable (JDK5) - буфер может быть принудительно сброшен flush() в поток с которым связан
	AutoCloseable (JDK7, пакет java.lang) - при использовании в try-с-ресурсами поток сам закрывается
		C JDK7 классы реализующий Closeable реализует и AutoCloseable (т.к. Closeable extends AutoCloseable)
	Readable - указывает на то, что объект можно использовать в качестве источника символов

-исключения i/o
	IOException
	FileNotFoundException
	SecurityException
	и др.

-Классы i/o

InputStream - байтовый поток ввода
OutputStream - вывода

Байтовые потоки не могут опереривать символами Unicode непосредственно. Поэтому ввели символьные.
Reader - текстовый поток чтения
Writer - вывода
	потоки ОБЯЗАТЕЛЬНО закрывать close()

Методы:
	void mark(int количество_байт)
	boolean markSupported() - поддерживает поток mark()/reset() или нет (т.к. они есть но не всегда сделаны)
	reset() - сбрасывает указатель на текущую позицию с которой будет чтение к метке установленной mark(). Если mark(int) не вызван, то в начало потока. (чтобы читать одни байты несколько раз)
	int available() - количество байт доступных для чтения
	long skip(long количество_байт) - пропускает заданное количество байт и возвращает их количество
	и др.

Пример:
	FileInputStream fi = new FileInputStream("/file.io");

	//или так
	FileInputStream fi = new FileInputStream(new File("/file.io"));

	fi.available(); //количество байт файла

	//читаем в байтовый массив
	byte[] b  = new byte[n];
	fi.read(b);
	System.out.println(new String(b, 0, b.length)); //преобразуем строку в байты
	
	//чтение через буфер (чтобы случайно не прочитать слишком много и не было переполнения
	FileInputStream fi = new FileInputStream("/file.io");
	byte[] b  = new byte[1024];
	while() {
		fi.read(
	}

	new FileOutputStream(String путь, boolean добавить)
		добавить - добавить к концу файла или перезаписать
		
	//чтение по символам
	while((c = in.read()) != -1 ) {
		System.out.println((char) c);
	}
	
	//вкладываем поток в буфер, чтобы ускорить операции,
	//которые теперь будут сбрасывать результат на диск
	//когда захотят, а все операции будут в памяти
	//также работают mark()/reset()
	new BufferedReader(FileInputStream("file.io");
	
	//установим метку
	in.mark(32); //метка на чтения следующих 32 байт
	
	//интересный прием
	//может принять динамический массив (Vector) имен файлов и работать как с потоком потоков
	class InputStreamEnumerator implements Enumeration<FileInputStream> {
		private Enumeration<String> files;
		public boolean hasMoreElements() {
			return files.hasMoreElements();
		}
		public FileInputStream nextElement() {
			return new FileInputStream(file.nextElement().toString());
		}
	}
	
Список классов:
	
	Байтовые:
	OutputStream/InputStream
	FiltreOutputStream
	ByteArrayInputStream(byte []arr, int begin, int quantity)
	PushbackInputStream
		unread()
	SequenceInputStream - можно соединять несколько потоков InputStream
	PrintStream(OutputStream os, boolean flushable)
	DataOutputStream - ввод/вывод примитивных данных, происходит их преобразование в байты налету
		writeDouble()
		writeInt()
		readInt()
	RandomAccessFile - не реализует InputStream/Output, наследует DataOutput и даёт произвольный доступ к файлу
		r/rw/rws
		seek(long позиция) - установка указателя чтения
		setLength() - устанавливает длинную файла (можно удлиннять или укарачивать файл)
	
	Символьные:
	Reader/Writer
	CharBuffer - поток-буфер
	FileWriter
	CharArrayReader
	BufferedReader (рекомендуется установить буфер 8192 или меньше)
	PushbackReader
	
	Console - служебный, работает через in/out консольные потоки
		Не имеет конструктора
		Console c = System.console();
		String s = c.readLine();
		
		методы:
		printf()
		readLine()
		Reader reader()
		format()
		readPassword()
		PrintWriter writer()
		
--Сериализаци
	Нужна для сохранения объектов в файл и для RMI
	
	Serializable - маркер показывающий что объект может быть сериализован
		transient поля не сохраняются
	Externalizable - управления сериализацией/десериализацией вручную
		Нужно реализовать методы для этого. (реализовать чтение/запись самому)
			void readExternal(ObjectInput is) throws ...
			void writeExternal(ObjectOutput os) throws...
		Нужно напр. для шифрования или сжатия
	
	ObjectOutput/ObjectInput - интерфейс, поток для сохранения объектов
	ObjectOutputStream - реализация
		readObject()/writeObject()
		
	ObjectOutputStream os = new ObjectOutputStream(new FileInputStream("file")).writeObject(new MyObj());
	os.close();

-NIO, New I/O, NIO.2
	Это другой способ работы с вводом/выводом - асинхронный.
	http://tutorials.jenkov.com/java-nio/ - хорошо описано
	
	Как работает:
		1. При вызове функций чтения/записи программа пойдет работать дальше (на следующую строчку), а не будет ждать окончания. (асинхронно)
		2. Чтение происходит в спец. буфер. Нужно создать его и связать с потоком.
		3. Функция может не успеть прочитать данные из потока в буфер. Тогда там будет только часть. Поэтому используется проверка в while(){} на количество прочтенного (до конца или нет)
		4. Всё это нужно, когда есть очень много источников/приемников данных и нужно одновременно с ними работать. (асинхронное чтение)
		5. Также введены дополнительные классы для работы с файлами, путями и т.д. (Files, Path, Paths, ...)
			Особенно много введено с JDK7
	
	Схема: чтение/запись <-> буфер <-> канал(ы)
		1. Каналы – это логические (не физические) порталы, через которые осуществляется ввод/вывод данных, а буферы являются источниками или приёмниками этих переданных данных.
			java.nio.channels
		2. Селекторы - в Java NIO позволяют одному потоку выполнения мониторить несколько каналов ввода.
			(группа каналов?)
			Суть в том, что читать целую группу может и один поток. Так что не надо создавать много Thread
		
	Пример:
	//постоянная проверка на количество прочитанного в while
	ByteBuffer buffer = ByteBuffer.allocate(48);
	int bytesRead = inChannel.read(buffer);
		while(! bufferFull(bytesRead) ) {
		    bytesRead = inChannel.read(buffer);
		}
		
	Классы:
		Paths - работа с путями
		Files - работа с файлами и их атрибутами
		Path - пути
		FileSystem, FileSystems, FileStore - работа с файловыми системами
		
-Пример работы с каналами (Из Шилдта):
	
	0. Новые классы Path, Files, FileSystem, FileSystems, FileStore
		- дают много готовых методов для работы с путями, каталогами, файлами.
		//walkFileTree - получить все файлы каталога и под каталогов
		class MyFileVisitor extends SimpleFileVisitor<Path> {
			public FileVisitResult visitFile(Path path, BasicFileAttribute attribs) {
				return FileVisitResult.CONTINUE;
			}
		}
		Files.walkFileTree(Paths.get("/dir"), new MyFileVisitor());
	1. Создаём объект Path с путём
		static Path get(String path, String path_parts)
	2. Создать из Path канал через класс Files
		//его можно привести к FileChannel, если выбрана файловая система по умолчанию
		static SeekableByteChannel newByteChannel(Path path, OpenOption ... способ) throws
	3. Создать буффер, который будет использован каналом для чтения/записи. Буферы могут быть разные, для работы с разными типами данных (напр. авто преобразуют байты в символы сами и т.д.)
		static ByteBuffer allocate(int емкость)
	4. Связываем канал и буфер методом read()
		int read(ByteBuffer буфер) throws
	5. Читаем методом read(), при каждом его вызове в буфер из файла читается следующа порция данных.
		Возвращает количество прочитанных байтов, если конец файла, то -1
	6. Другой способ прочитать файл: прочитать его в буфер сразу весь методом map()
		Называется сапостовление файла с буфером
	7. Можно получить вместо каналов обычные потоки используя методы newInputStream()/newOutputStream()
		и пользоваться обычным i/o?
		new BufferedInputStream(Files.newInputStream(Paths.get("C:\file.io")))
	8. Чтение до JDK7, не было интерфейса Path. Канал получали из InputStream, а не Path
		new FileInputStream("file.io").getChannel();
	9. Если нужно объединить каналы в группу нужно создать Селектор. (но в Шилдт этого нету)
		http://tutorials.jenkov.com/java-nio/selectors.html
	
	//создаём путь Path
	Paths path = new Paths.get("c:\\file.txt")
	//создаём канал по Path
	try(SeekableByteChannel fChan = Files.newByteChannel(path)) {
		int count;
		do{
			//выделить память под буфер и прочитать в него данные из канала
			ByteBuffer mBuf = ByteBuffer.allocate(128);
			count = fChan.read(mBuf);
			//проверка на конец файла
			if(count != -1) {
				//подготовить БУФЕР для чтения (перемотать указатель БУФЕРА на начало прочитанной порции)
				mBuf.rewind();
				//читать по символам
				for(int i = 0; i < count; i++)
					System.out.println((char)mBuf.get());
			}
		} while(count != -1);
	} catch(IOException e){}
	
	//читаем методом сопоставления файла с буфером
		MapMode.READ_ONLY
		MapMode.READ_WRITE
		MapMode.PRIVATE
	try(FileChannel fChan = (FileChannel) Files.newByteChannel(new Paths.get("c:\\file.txt"))) {
		//длинна файла
		long fSize = fChan.size();
		MappedByteBuffer mBuf = fChan.map(FileChannel.MapMode.READ_ONLY, 0, false);
		for(int i = 0; i < fSize; i++) {
			System.out.println((char)mBuf.get());
		}
	} catch(IOException e){}
	
--Кратко о работе с сетью (В Шилдте)

Сокет - это порт. Порты от 0 до 1024 зарезервированны для разных протоколов

Есть куча классов для работы с сетью:
	InitAddress - работы с хос/IP
	URL - работа с адресами
	ServerSocket, Socket - для сервера и клиенты
	URLConnection - работа с соединением, просмотр свойств ресурса
		getContentType(), getHeaderField(), ...
	HttpURLConnection - для http
	CookieManager, CookieHandler и др. - работа с куками
	DatagramPacket, DatagramSocket - работа с UDP (дейтаграмами)
	
Пример:
	//отправка/чтение
	new Socket("whois.my.net", 43).getInputStream(); //или getOutputStream()
	
	//
	HttpURLConnection uc = (HttpURLConnection) new URL("http://google.com").openConnection();
	uc.getDate();
	uc.getExpiration();
	uc.getLastModified()
	Map<String, List<String>> hm = uc.getHeaderFields();
	for(String k : hm.keySet()) {
	}
	
	<<<в Шилдте описан пример простого клиента и сервер>>>
	
--Fork / Join Framework, Параллельное API

java.util.concurrent
java.util.concurrent.atomic
java.util.concurrent.locks	

java.util.concurrent содержит:
	Синхронизаторы - синхронизация и взаимодействие потоков
		Semaphore - семофор (монитор с счетчиком, который синхронизирует ни один поток, а много)
		CountDownLatch - ждет пока не произойдет определенное количество событий, а потом срабатывает (запускает свой Thread и при заравершении поток уменьшает счетчик внутри себя методом countDown())
		CyclicBarrier - позволяет группе потоков войти в режим ожидания в заданной точке выполнения (работать до определенной точки в main())
		Exchanger - Обмен данными между двумя потоками
		Phaser - синхронизирует потоки проходящие через несколько фаз операции. Как CyclicBarrier только точек много, а потоки изнутри оповещают Phaser о достижении фаз. После приостановки на фазе (точке в коде главного потока) главный поток запускает следуюющую фазу.
	Исполнители - управление запуском и работай потоков, имеет доп. методы для работы с элементами concurrent
		Executor - интерфейс с методом void execute(Runnable r) запускает поток
		ExecutorService - интерфейс расширяет Executor, запускаеть много потоков, останавливать, возвращаеть результат работы потоков и т.д.
		ScheduledExecutorService - планирование запуска потоков
		ScheduledThreadPoolExecutor
		Executors - фабричные методы для получения ExecutorService, ScheduledExecutorService и т.д.
			Executors.newFixedThreadPool(1).execute(new MyThread());
	Callable, Future - для получения результата в главном потоке потом (после того как они появятся)
		1. Реализуем Callable и его метод V call()
		2. В main() делаем ссылку Future<V> f;
		3. запускаем на выполнение поток Callable:
			Future<V> f = Executors.newFixedThreadPool(1).submit(new MyCallable<V>(){...});
                get() - похож на then() из Promise в js
                cancel(), isCancelled(), isDone()
        4. CompletableFuture - класс, наследует Future, работает похоже на Promise в js. Tip. Ему не назначен Executor, поэтому выполнится в специальном ForkJoinPool.commonPool() (если это не поддерживает параллелизм по крайней мере 2го уровня, в этом случае new Thread будет создан, чтобы выполнить каждую задачу). Интерфейс маркер AsynchronousCompletionTask можно использовать для monitoring. Прим. можно вызвать get() или sleep() чтобы подождать выполнения методов описанных ниже.
            supplyAsync(callback) - можно вытащить результат работы callback через get()
            runAsync(callback) - вытащить результат нельзя
            thenAccept() - аналог then() из Promise в js
            thenApply() - в отличии от thenAccept() возвращает результат
            thenApplyAsync() - выполнится не в текущем Thread, а в отдельном
            thenCompose() - можно создать цепочку thenCompose(), результат return попадает в следующий (как для Promise из js)
            thenCombine() - по зовершению 2х задач выполнить 3ю (на самом деле можно комбинировать много задач)
	TimeUnit - enum с методами преобравания единиц времени в другие, используется в concurrent как параметр многих методов
		long t = TimeUnit.convert(long время, TimeUnit.HOURS);
	Параллельные коллекции - синхронизированные аналоги обычных
		ArrayBlockingQueue
		ConcurrentHashMap
		ConcurrentLinkedQueue
		ConcurrentLinkedDeque
		•  ConcurrentSkipListMap
		•  ConcurrentSkipListSet
		•  CopyOnWriteArrayList
		•  CopyOnWri teArraySet
		•  DelayQueue
		•  LinkedBlockingDeque
		•  LinkedBlockingQueue
		•  LinkedTransferQueue
		•  PriorityBlockingQueue
		•  SynchronousQueu
	Блокировки - аналог synchronized блоков, внутри потока вызываются методы: 1. lock() 2. Доступ к общему ресурсы 3. unlock()
		Lock - интерфейс
		ReentrantLocks - позволяет повторную блокировку (синхронизацию) тем же потоком, сколько было повторов столько надо и методов unlock() вызвать
		ReadWriteLock - блокировка доступа потокам только на чтение из общего ресурса
		ReentrantReadWriteLock
		JDK8: появился StampedLock - в книге ничего
	Atomic - классы для доступа к ним разных потоков одновременно (как volatile)
		new AtomicInteger() и др.
		get(), set()
		compareAndSet()
		decrementAndGet()
		getAndSet() - дастает старое и устанавливает новое
		JDK8: 4 класса неблокирующих накопительных операций DoubleAccumulator, DoubleAdder, LongAccumulator, LongAdder
	
	Fork / Join Framework - облегченный тип потоков (классов) по сравнению с Thread. Выполняет задачи меньшим количеством потоков, что эффективнее (видимо от того, что у CPU немного ядер?)
		ForkJoinTask<V> - задачи
		ForkJoinPool (implements Executor, ExecutorService) - потоки выполняющие задачи
		RecursiveAction<V> расширяет ForkJoinTask, для задач не возвращающих значения
		RecursiveTask<V> - тоже для возвращающих
	<<<Описать>>>
	
--Потоковый API (Stream API)
	см. отдельный файл


	
****************************************************
/**
*/ - документрующий коментарий, формирует доку с утилитой javadoc
****************************************************
имя исходного файла должно быть, как у главного класса Example.java
****************************************************
метод переопределен - если имя И ПАРАМЕТРЫ в наследнике совпадает с именем в предке
	иначе это будет перегрузка
****************************************************
public static void main(String args[])
static и public - потому что загрузчик JVM вызывает метод main() ДО создания всех объектов
если метода main() не будет программа скомпилируется, но запуститься не сможет
КЛАСС может быть НЕ public (package)

args содержит символы переданные командой (сразу строка, ни название программы, ничего)
java myProgr mycommand
args.equals("mycommand"); // == true

метод main может быть в интерфейсе (начиная с JDK8, т.к. стало можно static методы в интерфейсах)
Он также может быть во вложенном классе

Класс с main не обязательно public

При запуске фактически указывается имя класса A$B.class в котором находится метод main. Класс может быть не public. (A наследует B)
java package1.A$B

С JDK5 можно объявить main так
public static void main(String... args)

****************************************************
Разрешен ли в методе testAccess доступ к private-методам и полям другого экземпляра того же класса?
Да, разрешен. И к методам, и к полям.
****************************************************
инициализировать поля лучше в конструкторе, потому что в наследниках способы инициализации можно переопределить (ВРОДЕ БЫ)
****************************************************
Инициализация boolean
	private static Boolean useCreditScheme = Boolean.FALSE;

String всегда должны быть инициализированы
	String str; //ошибка
	String str = ""; //правильно
	String str = null; // правильно

Можно подключить jar библиотеку и выполнять JavaScript прямо в Java коде, как в eval функции из js
http://docs.oracle.com/javase/6/docs/technotes/guides/scripting/programmer_guide/index.html

Можно так склеить значение со строкой:
	String str = "str" + (var == null);
****************************************************
позднее связывание - на этапе выполнения
раннее связывание - на этапе компиляции
****************************************************
final метод нельзя переопределить
****************************************************
локальные переменные и параметры хранятся в стеке. При рекурсии нужно писать условие выхода из стека, чтобы не было переполнения.
****************************************************
объект существует пока существует хотя бы одна ссылка на него
****************************************************
Application Server is implementation of Java EE platform
Servlet Container is implementation of Java Servlet API + JSP/JSF

Java Servlet API is a subset of Java EE specification.
****************************************************
чтобы два пользователя не могли залогиниться под одним логином одновременно нужно сохранить их имя-номер сессии в базе или синглтоне и проверять нет ли такого уже (обычно сервер позволяет создать глобальную переменную через конфиги)
Map<String, String> - имя-номер сессии
только если синглтон нужно подумать о способе очистки устаревших сессий из Map (то есть кэш)
в Spring есть конфиг для такого называется примерно - SessionConcurency
в Tomcat в конфиге xml можно создать класс синглтон один на всё приложение?
****************************************************
Ссылки:
	ПЕРЕД реальной работой с деньгами, перечетать статьи по ссылкам!!!
		http://www.javaranch.com/journal/2003/07/MoneyInJava.html
		

Как работать с деньгами в Java (обычные числа не подходят)
	- это НЕ ИЗ книги Java Полное руководство
	
	public class CantAdd {
	   public static void main(String[] args) {
		  float a = 8250325.12f;
		  float b = 4321456.31f;
		  float c = a + b;
		  System.out.println(NumberFormat.getCurrencyInstance().format(c));
	   }
	}
	Должно вывести: $12,571,781.43
	Выведет: $12,571,782.00
	Причина: особенности работы с float числами описанном в стандарте IEEE 754, двоичном представлении каждое число - степень двойки.
	
Варианты решения проблемы:
0. Для типа в котором хранить деньги в Hibernate и других ORM фреймворках
	decimal(19,2) - в SQL

	//orm
	@Entity
	class Item {
		private BigDecimal cost; //преобразуется в decimal(19,2) - в SQL
	}
1. Использовать BigDecimal. При этом для хранения кодов валют можно использовать класс java.util.Currency
	(ВОЗМОЖНО для новых версий Java есть варианты получше!!!)
      BigDecimal a1 = new BigDecimal("2"); //в конструкторе должна быть строка!!!
      BigDecimal b1 = new BigDecimal("3");
      BigDecimal c1 = a1.divide(b1, 9, BigDecimal.ROUND_HALF_UP); //ОКРУГЛЕНИЕ вверх переодические дроби 0.666666667
      System.out.println(c1);
	  
	  Проблема:
			//1. ОШИБКА! В конструкторе BigDecimal нужно использовть строки!!!
	        BigDecimal a1 = new BigDecimal(8250325.12f);
			BigDecimal b1 = new BigDecimal(4321456.31f);
			BigDecimal b1 = new BigDecimal("4321456.31"); //Правильно!
			
			//2. NumberFormat использованный для вывода числа в System.out.println может вывести только значащих 16 чисел.
			//А BigDecimal может содержать БОЛЬШЕ!
			//НО возможно в новых версиях Java это исправили!
			
2. Подключить библиотеку - Money and Currency API (JSR 354), которая возможно будет частью Java 9
	<dependency>
		<groupId>org.javamoney</groupId>
		<artifactId>moneta</artifactId>
		<version>1.0</version>
	</dependency>
	
3. Можно использовать double для работы. Но при этом нужно написать функцию округления (НЕ ПРОВЕРЯЛ на корректность)
	http://vanillajava.blogspot.com.by/2011/08/double-your-money-again.html
	
4. Использовать стороннюю библиотеку Joda Money

****************************************************
---AWT и события
в java.awt много классов, фигуры, окна и т.д.
Верхний левый угол - координаты 0,0

Graphics передаётся в методы update и paint, либо this.getGraphics(); из Component
Graphics2D - доп. методы, чтобы использовать привести к нему:
Graphics g;
Graphics2D g2 = (Graphics2D) g;

class MyFrame extends Frame {
	//если объявить метод в него передасться объект для рисования
	public void paint(Graphics g) {
		g.drawString("Hello", 10, 40);
		g.drawLine(0, 0, 100, 90);
		//установка цвета
		g.setColor(new Color(100, 100, 255));
		super.paint(g);//кое где надо так из-за вызова не зависимых от ОС компоентов
	}
}
drawLine(), fillRect() - рисует линию и т.д.

Иерархия классов окон AWT:
			Component
			|		\
		Container	Canvas
			/	\
	Windows		Panel
		/
	Frame
	
Component - цвет фона, шрифт, события (так как в AWT источник и обработчик событий сам Component) и т.д.
Container - можно вкладывать в него другие Component
Canvas - пустое окно в котором можно рисовать
Panel - есть метод add() для добавления, простое окно без рамки, строк и т.д.
	После добавления в него компонентов их можно менять
		setLocation ( ), setSize ( ), setPreferredSize ( ) или setBounds ( )
Windows - окно верхнего уровня, оно ни где не содержится
Frame - полноценное окно, именного его наследовать чтобы создавать прилржение

//пример awt
class Main {
	public static void main(String[] args) {
		new MyWindow();
	}
}

class MyWindow extends Frame {
	public MyWindow() {
		//установка шрифта
		this.setFont(new Font("Times", Font.PLAIN, 12));
		Dimension dim = new Dimension();
		dim.setSize(400, 400);
		setSize(dim);
		setTitle("KeyCode");
		addWindowListener(new MyWindosAdapter(this));
		addKeyListener(new MyKeyAdapter(this));
		addKeyListener(new MyMouseAdapter(this));
		setVisible(true); //делаем окно видимым
	}
}

class MyWindosAdapter extends WindowAdapter {
	private MyWindow myWindow;
	MyWindosAdapter(MyWindow myWindow) {
		this.myWindow = myWindow;
	}
	public void windowClosing(WindowEvent we) {
		myWindow.setVisible(false);
	}
}

class MyKeyAdapter extends KeyAdapter {
	public void keyPressed(KeyEvent ke) {
		int ki = ke.getKeyCode();
		System.out.println(ki);
	}
}

class MyMouseAdapter extends KeyAdapter {
	public void mouseClicked(MouseEvent ke) {
		//...
	}
}

----
события содержатся в java.util, java.awt и java.event
EventObject - суперкласс событий, в пакете java.util родитель всех событий
	метод getSource() - источник
	toString() - описание события в виде строки
AWTEvent - наследник EventObject, родитель всех событий AWT
	int getID() - код событий
	
2 способа обработки событий:
	1. наследовать интерфейс и реализовать метод в который будет передан объект типа KeyEvent
		class MyFrame extends Frame implements MouseListener {
			Frame() {
				addMouseListener(this);
				addWindowListener(new MyWindosAdapter(this));
			}
			public void mouseClicked(MouseEvent me) {
				//...
			}
		}
	2. класс адаптер
		class MyWindosAdapter extends WindowAdapter {
			private MyWindow myWindow;
			MyWindosAdapter(MyWindow myWindow) {
				this.myWindow = myWindow;
			}
			public void windowClosing(WindowEvent we) {
				myWindow.setVisible(false);
			}
		}
--Swing
JComponent наследует Component, потом JFrame, Jbutton и т.д.
для рисование нужно переопределить protected void paintComponent(Graphics g) - сохроняемых данных,
три метода заменяют собой paint() из AWT, для рисования переопределять только тот что выше и в начале вызвать super.paintComponent();
не сохраняемых - вызов repaint()

методы setLocationRelativeTo - описать
setOpaque(true); - непрозрачность слоя, ставить в false при рисовании

//графика создаётся и обрабатывается в отдельном потоке, поэтому
//invokeLater - для приложений
//invokeAndWait - для аплетов
public class Main {
	public static void main(String[] args) {
		SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				new AnWin();
			}
		});
	}
}

JLayeredPane - многослойная панель, размещать элементы ещё и по оси Z
--------------------------------
JDBC (Java DataBase Connectivity)
	Представляет собой библиотеку Java, которая транслирует JDBC-запросы непосредственно в протокол конкретной базы данных.
	Транслирует JDBC в ODBC и для взаимодействия с базой данных использует драйвер ODBC. Компания Sun включила в состав JDK один такой драйвер - мост JDBC/ODBC. Однако для его использования нужно соответствующим образом установить и конфигурировать ODBC-драйвер.
	
ODBC (Open Database Connectivity) - sun.jdbc.odbc.JdbcOdbcDriver из JDK
	Это API для доступа к DBMS (СУБД) по спецификации Call Level Interface (CLI)
CLI - описывает как программа должна отправлять SQL-запросы к (СУБД) и как именно обрабатывать возвращенный.
DBMS - database management systems
RDBMS - Relational database management system
--------------------------------
JPA - Java Persistence API
	- входит в состав Java SE и Java EE (в Hibernate расширенная реализация)
	- аннотации для маппинга классов к таблицам базы
	- аннотации для транзакций и их конфигурации (над методами и классами)
	
JTA - Java Transaction API - часть JPA
	- набор классов, методов и аннотаций для установки соединения (конфигурация, выбор и настройка пулла соединений) и управления транзакциями через вызов методов
	- реализации JTA есть в некоторых серверах приложений, реализаций нет например в Tomcat (нужно подключать отдельно)
	
JTA vs JDBC - 

JDBC extensions - 
--------------------------------
Bean-Managed Transactions - это когда транзакцию запускают или останавливают вручную вызовом методов begin, commit
Container-Managed Transactions (CMT) - это когда методы помечают аннотациями вроде @Transactional и вызов методов транзакций делает за нас AOP
--------------------------------
JDO (Java Data Objects)
	Спецификация ORM не только для реаляционных БД (для SQL и NoSQL)
	не очень распространен?
--------------------------------
DTO (Data Transfer Object) - другое название Model слоя из MVC
--------------------------------
POJO (Plain Old Java Object) - публичный класс который не зависит от interfaces и frameworks, имеет public get/set

Java Bean это тоже POJO, но не всегда наоборот
--------------------------------
Value Object (VO) - как DTO, только для обмена данными внутри приложенки, а не с БД (как в случае с DTO)
--------------------------------
JAX-RS - API для работы с REST, появился в Java EE 6?

Классы и методы можно аннотировать @Path(/my)
методы @GET, @POST и т.д.
@PathParam - для переданных в запросе параметров и путей

(короче похоже на Spring MVC)
--------------------------------
EJB3

	По сути это бизнес слой (как @Service у Spring MVC). В нём делают запросы к базе и над ним можно объявить анатацию для транзакция (если не делать их вручную через объект EntityManager)
	При этом бывают бины которые после своей работы сохраняют состояние - @Stateful или забывают - @Stateless
		(состояние - это значение переменных class)
			(то есть Singleton или нет: Stateless и Stateful)
	
	1. Создаем EJB (при этом в конфигах нужно объявить PersistenceContext - источник данных, базу-бин)
		@Stateless
		@TransactionManagement(TransactionManagementType.CONTAINER)
		public class UserDetailBean implements UserDetailRemote {
			
		   @PersistenceContext (unitName="persons_dates")
			private EntityManager manager; 

		   @TransactionAttribute(TransactionAttributeType.REQUIRED)
		   public void createUserDetail() {
			  //create user details object
		   }
		}
		
	2. Создаем маппинг с таблицей (объек которыё используется в EJB)
		//аннотации и связи как в Hibernate (JPA)
		@Entity
		@Table(name="user")
		class User {
			@Id
			private long id;
			//...
		}
		
	3. Используем EJB в сервлете
		class Servlet extends HttpServlet {
			@EJB
			UserDetailBean userDetailBean;
			
			doGet(...) {
				userDetailBean.createUserDetail();
				request.setAttribute("result", "some_result"); //устанавливаем в сессию значение
				
				RequestDispatcher rd = request.getRequestDispatcher("index.jsp");
				rd.forward(request, response);
			}
		}
	
	В конфигах можно задавать Security Configuration - назначение пользователям ролей.
	Ограничения ролям доступа к определенным методам EJB:
		@Stateless
		@DeclareRoles({"student" "librarian"})
		public class LibraryBean implements LibraryRemote {

		   @RolesAllowed({"librarian"})
		   public void delete(Book book){
			  //delete book
		   }
		   
		   @PermitAll
		   public void viewBook(Book book){
			  //view book
		   }
		   
		   @DenyAll
		   public void deleteAll(){
			  //delete all books
		   } 
		}
		
	Как подключить БД в которой будет искать список ролей пользователей???
--------------------------------
работа с сокетами и IP-порт (слушать/отправлять запросы)
--------------------------------
web.xml и аналогичные аннотации
--------------------------------
JSP (JSTL, EL)
--------------------------------
CDI - Context and Dependency Injection
общее название для нескольких спецификаций:
--------------------------------
JMS (Java Message Service) - API которое даёт возможность обмениваться АСИНХРОННО сообщениями между клиентом-сервером
https://www.youtube.com/watch?v=fqpCmZe3koQ - хорошая теория

Когда используется: когда обменивающиеся сообщениями не зависят друг от друга.

Имеет две модли:
	Point-to-Point
	Publish and subscribe
	
Durable subscription - это когда JMS соединение устанавливается надежным, вы всегда получите сообщение, даже если сервер которому отсылается сообщение упал, потом поднялся ему перепошлется сообщение (имеет много настроек, таймауты и т.д.)
	Persistat - гарантирована доставка
	Non Persistant - не гарантированна
	
Selectors - можно фильтравать сообщения SQL-like языком

Как делать:
	1. Создаем соединения с брокером
	2. Создаем сессию на основе соединения (транзакционную или нет, много параметров)
	
	1. Создаём класс отправитель и инициализируем его очередью сообщений
	2. Создаём класс получатель и тоже инициализируем очередью
	3. Создаём событие слушателя, которое получатель вешает на прием сообщений
	
Каналы:
	queue - сообщение получит только один, то есть ОДНОВРЕМЕННО один, по очереди можно всем отослать
	topic - сообщения могут принимать много пользователей одновременно
	
MDB (Message Driven Beans) - это слушатель реализующий интерфейс, обрабатывает полученные сообщения
	
--------------------------------
JMX - Java Management Extensions
MBean - Managed Bean
	http://alvinalexander.com/blog/post/java/source-code-java-jmx-hello-world-application
	https://en.wikipedia.org/wiki/Java_Management_Extensions
	
	(потом надо описать?) Различают:
		Standard MBeans
		Dynamic MBeans
		Open MBeans
		Model MBeans
		MXBeans
		
	Как использовать:
	1. Создаем Bean
		class HelloMBean {
			String val;
			//getters, setters here
		}
	2. Регистрируем его в спец. сущности (созданное через фабрику)
		ManagementFactory.getPlatformMBeanServer().registerMBean(
			new HelloMBean(), new ObjectName("FOO:name=HelloBean")
		);
	3. Запускаем нашу программу со спец. командой в jconsole
		java -Dcom.sun.management.jmxremote \
			 -Dcom.sun.management.jmxremote.port=1617 \
			 -Dcom.sun.management.jmxremote.authenticate=false \
			 -Dcom.sun.management.jmxremote.ssl=false \
			 SimpleAgent
	4. Теперь видим значения MBean в специальном веб интерфейсе (и можем менять значения?)
	
	Для чего: для мониторинга программы?
--------------------------------
SOA (Web Services, REST, SOAP)
JAXWS
--------------------------------
EMS, ESB and MOM, JMS
https://stackoverflow.com/questions/6574291/ems-esb-and-mom-jms
https://stackoverflow.com/questions/309374/message-oriented-middleware-mom-vs-enterprise-service-bus-esb

--------------------------------
Service Provider Interface (SPI) - спецификация, которая позволяет реализовать directory service в виде плагинов для frameworks

По сути это интерфейс, который должен быть реализован кодом, который хочет работать как плагин и быть включен в другой код?

Используется в: JNDI и разных классах для доступа к данным (i/o, sound, db etc)
--------------------------------
JNDI (Java Naming and Directory Interface) - это Java API, просто набор интерфейсов для получения данных из БД, properies, xml и т.д.
http://forum.vingrad.ru/articles/topic-157996.html

Сюда входят понятия:
    directory service (or name service) - связывает имя ресурса и адрес по которому он доступен
    Service Provider Interface (SPI) - спецификация, которая позволяет реализовать directory service в виде плагинов для frameworks

Используется для: сервера LDAP, RMI и Java EE использует JNDI для получение объекта по адресу, получение конфигов Java Servlet из web container и т.д.

Пример:
interface Context {
	Object lookup(String jndiName);
}
public class InitialContext {
   public Object lookup(String jndiName){
   
      if(jndiName.equalsIgnoreCase("SERVICE1")){
         System.out.println("Looking up and creating a new Service1 object");
         return new Service1();
      }
      else if (jndiName.equalsIgnoreCase("SERVICE2")){
         System.out.println("Looking up and creating a new Service2 object");
         return new Service2();
      }
      return null;		
   }
}
Context c = new InitialContext();
Service ob = (Service) c.lookup("java:global/CMT_Example/CartBean!com.example.beans.CartBean");
--------------------------------
LDAP (Lightweight Directory Access Protocol) - протокол доступа к БД, файлам и т.д. Сама БД за протоколом LDAP может быть любой.

Directory - термин означающий ключ-значение, связь ресурса и ссылки на него.

Прим. Как я понимаю на практике LDAP используют не с реляционной БД, а с простой БД в виде файла (данные хранят например в структуры данных Дерево). Т.е. это аналог Map класса из Java. Причем Directory в названии означает, что по кускам ссылок можно ходить как по путям URI в каталогах или адресах сайтов (как в, например, REST).
LDAP определяет как общаться с хранилищем. В LDAP часть хранят пользователей, конфиги и подобное (служебные данные).
--------------------------------
пакет java.lang.ref.*
WeakReference, PhantomReference, SoftReference
(лучше читать по ссылкам - понятнее)

http://stackoverflow.com/q/3329691/276994
http://ru.stackoverflow.com/questions/181829/java-%D0%9F%D0%BE%D0%BB%D1%8C%D0%B7%D0%B0-%D0%BE%D1%82-%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BAsoftreference-weakreference-phantomreference
https://habrahabr.ru/post/169883/ - классно написано, также есть пример использования кэширования на SoftReference

SoftReference -- это самая сильная из всех перечисленных ссылок. Если на объект не осталось больше нормальных ссылок, а только SoftReference, объект не будет съеден сборщиком мусора до тех пор, пока реально не возникнет ситуация нехватки памяти.

Хороший пример использования для таких ссылок -- кеш больших картинок в памяти. Если память исчерпалась, картинку выбросит сборщик мусора, и вы сможете перечитать её с диска, когда она снова вам понадобится.

WeakReference слабее: она не увеличивает дополнительно время жизни объекта, на который ссылается, и если на объект есть не более чем слабые ссылки, сборщик мусора может убрать его когда ему вздумается.

Хороший пример использования для таких ссылок -- добавить дополнительную информацию об каком-то объекте. Для этого вы держите в своём контейнере не сам объект, а лишь WeakReference на него, вместе с необходимой информацией, тем самым вы не мешаете объекту умереть вовремя и не меняете свойства остальной части программы.

Имея на руках SoftReference или WeakReference на ещё живой объект, вы можете получить настоящую ("сильную") ссылку, и предотвратить съедение этого объекта сборщиком мусора. Имея сильную ссылку, вы можете работать с объектом как обычно.

PhantomReference ещё слабее. Она не только не предохраняет объект от уборки, она даже не даёт возможности получить сильную ссылку. Вы можете только узнать, что объект собирается умереть, и предпринять какие-то действия по очистке; предотвратить смерть объекта вы не сможете.
Его имеет смысле использовать только с ReferenceQueue для отслеживания момента удаления.


---Пример использования

	Чтобы решить задачу с серийными номерами вы можете воспользоваться классом WeakHashMap, который работает так же, как и HashMap, кроме того, что его ключи (не значения!) ссылаются через слабые ссылки. Если ключ WeakHashMap становится мусором - элемент коллекции удаляется автоматически.

ReferenceQueue queue = new ReferenceQueue(); //очередь ссылок
WeakReference<Thing> weakThing = new WeakReference<Thing>(thing);
//в очереди будут ссылки на объекты ПЕРЕД удалением

SoftReference<Thing> thing = new SoftReference<Thing>(new Thing());
	softBuilder.get() — вернет strong-ссылку на объект StringBuilder в случае если GC не удалил этот объект из памяти. В другом случае вернется null.
	softBuilder.clear() — удалит ссылку на объект StringBuilder (то есть soft-ссылки на этот объект больше нет) 

ReferenceQueue queue = new ReferenceQueue(); //очередь ссылок
PhantomReference<Thing> thing = new PhantomReference<Thing>(new Thing(), queue);
	//в очереди будут ссылки на УЖЕ удаленные объекты
	
	Таким образом в методе finalize() объекта можно создать жесткую ссылку на удаляемый объект тем самым не дав ему умереть. В случае с фантомными ссылками это невозможно

	
List<SoftReference> так и SoftReference<List>. Второй вариант более приемлемый.

--------------------------------
парсеры xml

Читаем тут хорошие примеры тут http://www.tutorialspoint.com/java_xml/java_stax_modify_document.htm

Суть в определении своего обработчика содержимого. Назначении этого обработчика парсеру. И запуск парсера.

При этом перед этим нужно создать коммандой (через утилиту) набор классов из .xml документа. В котором объекты это элементы, значения, аттрибуты.
При разборе парсером создавать эти элементы, брать парсером значения из документа и устнавливать его объектам. Вконце получим заполненные объекты.

1.
dom parser/builder - загружает весь документ и можно методами доставать теги и их значения (как в браузерном js). Также можно делать xslt трансформацию. Используется когда структура документа хорошо известна. Минус - нагрузка на RAM.

    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    factory.setValidating(true);
    factory.setIgnoringElementContentWhitespace(true);
    try {
        DocumentBuilder builder = factory.newDocumentBuilder();
        File file = new File("test.xml");
        Document doc = builder.parse(file);
        // Do something with the document here.
    }
    catch (ParserConfigurationException e) {}
    catch (SAXException e) {}
    catch (IOException e) {}
	
2. SAX Parser - для чтения потока xml, без его запоминания (прочитал - выбросил).
Для чтения наследуется класс парсера DefaultHandler (или др.) с жизненным циклом переопределяются методы startDocument/startElement/endElement/etc для элементов, значений, атрибутов. Метод characters() можно переопределить чтобы накапливать символы тега/атрибута в момент чтения в отдельной переменной.

    SAXParserFactory factory = SAXParserFactory.newInstance();
    factory.setValidating(true);
    try {
        SAXParser saxParser = factory.newSAXParser();
        File file = new File("test.xml");
        saxParser.parse(file, new ElementHandler());    // specify handler
    }
    catch(ParserConfigurationException e1) {}
    catch(SAXException e1) {}
    catch(IOException e) {}
    
    public class SAXPars extends DefaultHandler{
        @Override 
        public void startDocument() throws SAXException { 
            System.out.println("Start parse XML..."); 
        }
        
        @Override 
        public void characters(char[] ch, int start, int length) throws SAXException { 
            if (thisElement.equals("id")) { 
                doc.setId(new Integer(new String(ch, start, length))); 
            } 
        }
    }
	
3. StAx Reader/Writer - работает как SAX. Но ещё позволяет и писать в документ (в том числе изменять на ходу существующий). Вместо переопределения методов есть один главный метод с switch-case для каждой ситуации (начало/конец документа, элемента, значения, атриббута)
(в примере немного другой способ - обход по итератору, а не через switch-case, если )
Read document:
    FileInputStream fis = null;
    try {
        fis = new FileInputStream("test.xml");
        XMLInputFactory xmlInFact = XMLInputFactory.newInstance();
        XMLStreamReader reader = xmlInFact.createXMLStreamReader(fis);
        while(reader.hasNext()) {
            reader.next(); // do something here
        }
    }
    catch(IOException exc) {
    }
    catch(XMLStreamException exc) {
    }
    
Write document:
    FileOutputStream fos = null;
    try {
        fos = new FileOutputStream("test.xml");
        XMLOutputFactory xmlOutFact = XMLOutputFactory.newInstance();
        XMLStreamWriter writer = xmlOutFact.createXMLStreamWriter(fos);
        writer.writeStartDocument();
        writer.writeStartElement("test");
        // write stuff
        writer.writeEndElement();
        writer.flush();
    }
    catch(IOException exc) {
    }
    catch(XMLStreamException exc) {
    }
    finally {
    }

4. JAXB - более новая реализация, начиная с JDK6. Позволяет сереализовать Java объект из xml документа.
Документ читается через класс реализующий интерфейс javax.xml.bind.Unmarshaller
Имеет (или можно создать самому?) классы для элементов из xml анатируя их: @XmlRootElement, @XmlElement, @XmlAttribute
    RootElementClass adr = new RootElementClass();
    FileInputStream adrFile = null;
    try {
        adrFile = new FileInputStream("test.xml");
        JAXBContext ctx = JAXBContext.newInstance(RootElementClass.class);
        Unmarshaller um = ctx.createUnmarshaller();
        adr = (RootElementClass) um.unmarshal(adrFile);
    }
    catch(IOException exc) {
    }
    catch(JAXBException exc) {
    }
    finally {
    }
    
Write document:
    FileOutputStream adrFile = null;
    try {
        adrFile = new FileOutputStream("test.xml");
        JAXBContext ctx = JAXBContext.newInstance(RootElementClass.class); // например JAXBContext.newInstance(User.class);
        ctx.createMarshaller().marshal(new USer(), new File("user.xml"));
        User user = (User) ctx.createUnmarshaller().unmarshal(file);
    }
    catch(IOException exc) {
    }
    catch(JAXBException exc) {
    }
    finally {
    }

// аннотации на события парсинга
Testing:
    public class ProductToXmlTest {
        private Product product;

        @Before
        public void setUp() { ... }

        @After
        public void tearDown() { ... }

        @Test
        public void testObjectToXml() throws JAXBException, FileNotFoundException { ... }
    }
	
5. DOM4J - xml парсер удобный, быстрый. Использует XPath для доступа к элементам, а потом читает массив взятых элементов их в цикле for ( : )
Можно удобно создавать документ. Можно изменять документ..
--------------------------------
репозиторий с Шпаргалками по Java, списком библиотек и др. ОЧЕНЬ полезно (на рус)
Это не просто статья, это ссылки на многие библиотеки и статьи, которые можно выбрать из списка для решения какой-то задачи
https://github.com/Vedenin/useful-java-links/tree/master/link-rus

 HTTP сервер за 15 минут 
https://habrahabr.ru/post/69136/

Про пулл соединение, возможно перенести описание в Общее
http://stackoverflow.com/questions/2360965/what-really-is-connection-pooling

Очень полезная инфа, практически книга по java, читать для сертификации, есть полезные схемки
http://docs.oracle.com/javase/tutorial/extra/certification/

типы ссылок в java, soft, weak etc (лучше чем на русском?) Та статья на русском перевод этой
http://coding-geek.com/java-the-different-reference-types/
--------------------------------
Как хранить формулы в базе данных?
Это нужно чтобы брать из БД только формулу для рассчетов и пользователь мог редактировать ее на ходу из UI

Пока не нашел. Один из вариантов хранить в БД js или каком-то промежуточном виде.

Ссылка на возможное решение
http://stackoverflow.com/questions/7258538/built-in-method-for-evaluating-math-expressions-in-java
--------------------------------
DI(dependency injection) - your component isn't aware of the DI container and dependencies "automagically" appear (e.g. you just declare some setters/ constructor parameters and the DI container fills them for you).
    Помечаем аннотациями или xml куда нужно вставить зависимости и они автоматом подставляются.

DL (dependency lookup) - you have to specifically ask for what you need. What this means in practice is that you have a dependency on the context (in spring the Application context) and retrieve whatever you need from it.
    В компоненте вручную достаем зависимость и используем.
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("/application-context.xml");
        MyBean bean = applicationContext.getBean("myBean")
--------------------------------
FQN - fully qualified name, полное имя класса с путем к его пакету
--------------------------------
