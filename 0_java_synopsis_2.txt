################################################# GC

Garbage Collection
https://www.youtube.com/watch?v=UnaNQgzw4zY
https://www.ibm.com/developerworks/ru/library/j-jtp10283/
https://www.ibm.com/developerworks/ru/library/j-jtp11253/

weak generational hypothesis для большинства Java программ - гипотеза основанная на собранном опыте анализа разных программ:
    1. Большинство аллоцированых (созданных) объектов быстро становятся мусором.
    2. Существует мало связей между объектами, которые были созданы в прошлом и только что аллоцироваными объектами.

live object = reachable (referenced by someone else)
dead object = unreachable (not referenced from anywhere)

Objects расположены в "heap" java memory
static members, class definition (metadata) расположены в "method area". Оно называется Permgen в старой версии java, или Metaspace в новой (java 8)

Garbage Collector - daemon thread, который чистит память.
System.gc() - force вызов GC, гарантий что gc запустится сразу нет

java.lang.OutOfMemoryError - если jvm не может расположить Object в heap. В этом случае нужно искать memory leaks в программе.

Слова:
    contiguous - прилежащий (как defragmented)
    eden - рай
    survivor space from
    survivor space to
    tenured - имеющий контракт
    throughput - пропускная способность

Шаги по очистке в Garbage Collector:
    1. Mark - начинает поиск от application root node (main метод). Идет через object graph, помечает reachable objects как live (живые не для удаления)
    
    2. Delete / sweep - удаляет unreachable objects из heap
    
    3. Compacting - (только для major gc) дефрагментация объектов, которые остались после очистки (lived objects). Этот шаг затратен по времени.
        Как работает: Процедура заключается в перемещении живых объектов к началу “old generation space”, таким образом мусор остается в конце.
            (т.е. мусор сдвигается вконец old space)
    
трассирующий сборщик - это алгоритм проходящий по всем node (дереву объектов). Остальные gc это его вариации.
    Недостаток: паузы
    Плюсы: нету нагрузки на компилятор или мутатор (механизм подсчета ссылок), легко определяет циклические зависимости

Generation collectors

В java Garbage Collectors называют Generation Garbage Collectors. Потому что он зависит от generations объектов. Он зависит от: young objects, old objects, survive objects, количества циклов gc и etc.

Структура heap:
--------------------------------------------
young                   |   old (tenured)
generation              |   generation
--------------------------------------------
eden space              |
-----------------------------------------
survivor    |   survivor|
space from  |   to      |
----------------------------------------

Путь object (работа gc в целом):
    eden (создание) -> survivor (когда eden заполнено, происходит "маленькая" версия gc и перемещает всех выживших сюда) -> old (все кто выжил в течении многих циклов попадают сюда)
    
Пример объекта, который может попасть в old: кэш

young generation - место где создаются объекты

eden space - место где создаются объекты (eden где жизнь была создана)
survivor space from - когда в eden space заканчивается место, вызывается gc. Он чистит eden и все reachable objects перемещает в survivor space from (survived objects). Затем новые objects могут быть созданы в пустом eden.

old (tenured) generation - место куда попадают объекты пережившие многие циклы gc. Объекты попавшие в old очищаются major gc.

minor Garbage Collection - запускается для young generation, например когда eden полон.
Причем eden полон как rechable objects, так и unrechable objects, потому что они не удаляются пока не запуститься minor gc и не перенесет все rechable в survivor space.

major Garbage Collection - чистит объекты во всей heap (все области young и old). В отличии от minor делает все шаги по очистке в Garbage Collector (mark, sweep, compacting)

major Garbage Collection запускается когда old generation заполнено или близко к заполнению.

minor и major Garbage Collector - называются stop the world Garbage Collection. Т.е. minor gc запускается на меньшей области памяти, то он меньше влияет на производительность. major gc жрет больше ресурсов.

Card table - это массив с однобайтной ячейкой, каждая ячейка массива соответствует куску памяти (карте) в “old generation”.
    (для отметки мусор объект или нет)

---
работа minor gc:
-------------------------
young generation        
-------------------------
eden space              |
-------------------------
survivor    |   survivor|
space from  |   to      |
-------------------------

Как работает при запуске minor gc:
1. При очистки eden живые попадают в survivor from
2. При повторной очистки eden от мертвых чистится и survivor from. Живые из eden и  survivor from попадают в survivor to. При этом очищаются (остаются пустыми) и eden, и survivor from.
3. При следующей очистке происходит тоже что и на шаге 2, только объекты перемещаются из eden и survivor to в survivor from.
4. На всех последующих шагах шаги 2 и 3 повторяются. Т.е. живые объекты курсируют между survivor from и survivor to.
5. Для каждого объекта подсчитывается при каком количестве циклов он выжил. Если количество выживаний привысило установленное число, то объект переносится в old generation.

Для чего survivor from и survivor to: чтобы избежать запуска compacting step для minor gc, compacting жрет ресурсы.

За количество после которого объект перемещается из young в old отвечает параметр -XX:MaxTenuringThreshold
---
performance gc

responsiveness / latency - задержка при отклике. Критично например для UI приложений, чтобы не вызывать major gc.

throughput - сколько операций делает одновременно (пропускная способность). Т.е. приложения может делать паузы для gc, но взамен остальное время работает очень эффективно.
---
Типы Garbage Collectors

1. serial collector - basic gc, с самых ранних версий java. В основном используется для heap малого размера. Запускается single thread, вызывает паузы приложения для работы major gc. Т.е. single thread ОДНА И ТА ЖЕ с основным приложением.

2. concurrent collector - gc работает в параллельном потоке одновременно c приложением. НЕ ЖДЕТ когда old space заполнится, а делает очистку когда может. Не останавливает приложение для шагов gc (шаги sweep, compacting происходят в ПАРАЛЛЕЛЬНЫХ потоках). Делает паузу приложения только для: mark и remark шагов (remark видимо увеличивает счетчик, если объект уже выжил хоть раз, перепомечает).

concurrent collector еще называют concurrent mark-sweep (CMS),
    известный как low latency collector

3. parallel collector - использует несколько CPUs (мультипоточная, многоядерная). Но в отличии от concurrent collector не запущен постоянно. Запускается когда old space близко к заполнению (установленному порогу), НО при этом запускается в ОТДЕЛЬНОМ потоке. Позволяет избавиться от пауз или сделать их короче.

4. G1 collector (Garbage First) -  с jdk 7. В нем можно задавать длину пауз при очистке для VM, которые делает gc; меньше фрагментация. Использует смесь concurrent и parallel, как результат лучше работает с heap.
G1 разделяет heap на регионы (со своими eden, survivor from, survivor to, old space). И выполняет для регионов шаги по очистке gc в отдельных потоках (parallel). Если какой-то регион заполнен, то для него запускается gc. Т.е. работает для маленьких кусок памяти он быстрее. Нацелен на маленькое количество пауз; и длину паузы можно настраивать самому.

Когда использовать какой collector:
    serial collector когда:
        нужна маленькая heap
    concurrent collector когда:
        1. много памяти
        2. много CPUs
        3. приложению нужно меньше пауз (нужна low latency)
    parallel collector
        1. мало памяти
        2. меньше CPUs
        3. приложению нужно больше throughput (в обмен на паузы)
        
concurrent collector (CMS) ПРЕДПОЧТИТЕЛЬНЕЕ для большинства web приложений, финансовых и прочем.
---
Настройка:
    -XX:+UseSerialGC
            single thread gc для young и old space
    -XX:+UseParallelGC
            parallel thread gc для young
            single thread gc для old
    -XX:+UseParallelOldGC
            parallel thread gc для young и old space
            Для:
                throughput приложений с большими паузами,
                но взамен и большей производительностью (пропускной способностью)
    -XX:+UseParNewGC
            Multithreaded-gc будет только для young space
            (т.е. многопроцессорность, а не многопоточность как в parallel???)
    -XX:+UseConcMarkSweepGC
        это concurrent gc, он действует только для old space
        Может быть использована в паре с +UseParNewGC,
        тогда для young space будет запущен parallel collector
    -XX:+UseG1GC
    
GC по умолчанию:
    в java 6: parallel
    с java 7: G1
    
Параметры GC:
    -Xmsvalue
        - min размер heap
    -Xmxvalue
        - max размер heap (default: 256m)
    -XX:NewRation=ration (2 means 1/3 Y +2/3 T)
        - отдельно размер для young и old
    -XX:NewSize=size
        - размер eden
    -XX:MaxNewSize=size
        - max размер eden
    -XX:PermSize
        - сколько из heap выделить для metadata (class definition, static objects etc)
    -XX:MaxPermSize
        - (default: 64m)
        
Размер heap по умолчанию в java 8 (в целом зависит от реализации jvm):
    Client:
        max: 1/4 от RAM; min: 1/6 от RAM
    Server:
        max: 
        
java -XX:+PrintFlagsFinal -version - выводит default настройки для jvm.
        
ЕСЛИ приложение имеет много объектов и сохраняет их большое количество времени. Но рекомендуется сделать eden или young space больше.
    
Вывод логов о GC:
    -verbose:gc
    -XX:+PrintGCDetails
    -Xloggc:gc.log
    
Можно сохранять dump для heap в логи.
    
jvisualvm - утилита из jdk для графического просмотра инфы о jvm и GC. Она конектиться к jvm.
    Note: это не правильно, но эта программа может вызывать gc вручную для jvm. И это можно использовать для экстренного восстановления лагающих программ.
    
jhat - утилита от Oracle для анализа heap.
    
Рекомендуется использовать для просмотра логов сторонние инструменты и плагины IDE. Они в том числе показывают предложения по настройке GC.

terracota big memory - утилита для анализа heap и GC.
---
Метод protected void finalize() throws Throwable

Хотя в некоторых источниках рекомендуется использовать finalize() для очистки ресурсов этого делать не надо. Потому что гарантий его выполнения нет.
Тут может быть нужно вызвать System.gc() или Runtime.gc() вручную. Но и тогда нет гарантий.
Рекомендуется: использовать в этом методе только что-то простое вроде логирования.

Заметка:
    Если в finalize() пересоздать объект, то он не будет очищен.
    НО есть contract по которому finalize() может быть вызван только ОДИН раз для объекта. И если он уже был вызван для пересозданного В НЕМ объекта, то при следующей очистке объекта finalize() уже не вызовется.
    
    Пример пересозданием в finalize() {
        this = new BlaBla();
    }
----
Process memory - это область old + perm + misc (1024M)

размер stack задается командой -Xss*N
----
Все сборщики мусора в Java - трасирующие.
Поиск мусора идет по дереву объектов начиная с GC root.
Типы GC root:
    Локальные переменные и параметры методов
    Java Потоки
    Статические переменные
    Ссылки из JNI

################################################# типы данных, переменные, операторы, циклы, массивы

зарезервировано 50 слов; const, goto не используются

типы делятся на ссылочные (классы, интерфейсы, массивы) и примитивные

Автопреобразование всегда выполняется к float или doable если они в выражении,
даже если операция с long.
Преобразование к целому отбрасывает дробную часть.

char инициализируется \u0000

Все значение в Java передаются по ЗНАЧЕНИЮ (копируется переменная),
при передаче ссылки в фцию передается значение адреса ссылки.

Без main() компиляция возможно, но при запуске будет ошибка.
Несколько методов main() может быть, но при запуске указывается конкретный.
    java m1.B

Побитовые операции могут быть с присваиванием: &=, ^=, |=, >>=, <<=, >>>=

// for без параметров
for(;;) { 
}

виды массивов - одномерные и многомерные массивы

Number - предок числовых типов, кроме всего предок для BigDecimal и BigInteger; есть 6 методов:
    byteValue(), doubleValue(), floatValue(), intValue(), longValue(), shortValue()
    
boxing/unboxing - автоматическое преобразование из примитивных типов данных к ссылочным и наоборот.

################################################# работа со строками (String in Java)

String vs StringBuilder:
public final class String implements java.io.Serializable, Comparable<String>, CharSequence
public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence
public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence

StringBuilder и StringBuffer - mutable,
используйте его, если Вы хотите изменять содержимое строки

String - final, поэтому наследоваться не получится.

new StringBuilder("ABCDEFG").reverse(); // перевернуть строку

Как заменить символ в строке?
Ответ: replace(), StringBuilder.setCharAt(int index, char ch), преобразовать в toCharArray() и заменить там.

string.indexOf(char c) или lastIndexOf() + substring() - выделение подстроки в строке
line.split(" ", 2); - на подстроки, 2 - количество подстрок

String - потокобезопасный, потому что immutable

stringBuilder.toString().equals(new String('bla')) - сравнение String с StringBuilder (приводим к одному типу)

Плюсы imutable String:
    пул строк, адреса имена и пароли нельзя подменить, потокобезопасность,
    hashcode кэшируется (не требует повторного пересчета) и String эффективна для HashMap (кэш хэшкода для каждой строки),
    ClassLoader.forName() может загрузить класс по имени.
    
Для пароля лучше использовать массив строк или символов, а не String,
чтобы пароль не попал в пулл.

str.replaceAll(Character.toString(ch), ""); - удаление символа из String

################################################# коллекции (Collections)
Минусы массивов: нужно следить за длиной, индексная адресация (долгое добавление и удаление)

рекурсивные типы данных - списки и деревья используются в коллекциях

Коллекции хранят ссылочные типы данных.

TreeSet vs SortedSet:
TreeSet и TreeMap имплементируют интерфейсы NavigableSet и NavigableMap, которые расширяют интерфейсы SortedSet и SortedMap

В List - доступ по индексу.

ArrayDeque и LinkedList - реализации Queue

SortedMap - хранит ключи в порядке возрастания (опирая на Comparable/Comparator)

TreeSet инкапсулирует в себе TreeMap, который в свою очередь использует сбалансированное бинарное красно-черное дерево для хранения элементов.
O(log(n)) - время add, remove и contains.

Если вызывается конструктор без параметров, то по умолчанию будет создан массив из 10-ти элементов типа Object:
ArrayList<String> list = new ArrayList<String>();

Если места в ArrayList не достаточно, новая емкость рассчитывается по формуле (oldCapacity * 3) / 2 + 1.
Другой вариант???: У ArrayList увеличение происходит в 1.5 раза. int newCapacity = oldCapacity + (oldCapacity >> 1);

При удалении элементов текущая величина capacity не уменьшается, что может привести к своеобразным утечкам памяти.
Поэтому не стоит пренебрегать методом trimToSize().

Плюсы ArrayList:
Быстрый доступ к элементам по индексу за время O(1);
Доступ к элементам по значению за линейное время O(n);

HashSet реализован на основе хеш-таблицы, а TreeSet — на основе бинарного дерева.

HashSet гораздо быстрее чем TreeSet ( o(1) vs o(log(n)) для add(), remove(), contains() ).
(константное время против логарифмического для большинства операций, таких как add, remove, contains)

В TreeSet и TreeMap не хранится null:
    SortedMap не позволяет использование ключей null,
    Следовательно, и TreeMap не поддерживает хранение элементов типа null.
    TreeSet работает по тому же принципу что и HashSet, но использует NavigableMap для хранения элементов.
    Если вы попробуете добавить null в TreeSet, получите исключение NullPointerException.
    
Если создать свой Comparator поддерживающий null,
то null можно использовать в TreeSet и TreeMap.

HashMap работает строго быстрее TreeMap (реализован на красно-черном дереве).

HashMap быстрее TreeMap, КРОМЕ ситуаций с вещественными числами,
с ними лучше TreeMap с реализованным компаратором сранивающим числа на равенство (если разница меньше 1e-9).

В TreeSet доп. методы:
first(), last(), headSet(), tailSet()

Если в Map положить два значения с одинаковым ключом, значение перезапишется.

ТгееМар:
    ТгееМар() — создает пустой объект с естественным  порядком элементов;
    TreeМар(Comparator с) — создает пустой объект, в котором порядок задается объектом сравнения с;
    ТгееМар(Map f) — создает объект, содержащий все элементы отображения f, с естественным порядком его элементов;
    ТгееМар(SortedMap sf) — создает объект, содержащий все элементы отображения sf, в том же порядке.
    
Collections:
    Collections.sort(List myList) 	Сортирует список в естественном порядке.
    Collections.sort(List, Comparator c) 	Сортировка с использованием компаратора.
    Collections.shuffle(List myList) 	Перемешивает коллекцию в случайном порядке.
    Collections.reverse(List myList) 	Переворачивает коллекцию в обратном порядке.
    Collections.binarySearch(List mlist, T key) 	поиск в коллекции по ключу с использованием бинарного поиска.
    Collections.copy(List dest, List src) 	Копирует коллекцию источник src в dest.
    Collections.frequency(Collection c, Object o) 	Возвращает число вхождений объекта в коллекции.
    Collections.synchronizedCollection(Collection c) 	Возвращает синхронизированную (потокобезопасную) коллекцию.
    
Синхронизированные:
    @Deprecated HashTable, Vector.
    
Получить синхронизированную коллекцию из не синхронизированной?
    Collections.synchronizedList(list);
    Collections.synchronizedSet(set);
    Collections.synchronizedMap(map);

Iterator и Enumeration:
    Enumeration в два раза быстрее Iterator и использует меньше памяти.
    Iterator потокобезопасен, т.к. не позволяет другим потокам модифицировать коллекцию при переборе.
    Enumeration можно использовать только для read-only коллекций. Так же у него отсутствует метод remove();
        Enumeration: hasMoreElement(), nextElement()
        Iterator: hasNext(), next(), remove()
        
Iterator и ListIterator:
    ListIterator только для List, есть previous(), add() и remove()
    Iterator для Set, List и Map, нет remove()
    
iterator.add() - нету, потому что он и так есть у коллекций и у каждого типа коллекций он устроен по разному.

итераторы fail-safe и fail-fast:
    В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры,
        потому что они работают с клоном коллекции вместо оригинала.
    Итератор коллекции CopyOnWriteArrayList и итератор представления keySet
        коллекции ConcurrentHashMap являются примерами итераторов fail-safe.
    Итератор fail-fast вызывает исключение сразу как обнаружит что структура коллекции была изменена после начала перебора.
        
for(:) - Реализован на основе Iterator.

Что делать, чтобы не возникло исключение ConcurrentModificationException?
    1. Подобрать итератор fail-safe (напр. ListIterator).
    2. Подобрать Enumeration для старых коллекций.
    3. Использовать ConcurrentHashMap и CopyOnWriteArrayList - лучший вариант.
    4. преобразовать список в массив и перебирать массив
        или
        использовать synchronized(list)
        (эти способы медленные)
        
Stack и Vector оба потокобезопасны!!!

По умолчанию, Vector удваивает свой размер когда заканчивается выделенная под элементы память.
ArrayList же увеличивает свой размер только на половину

Использование Queue и Stack:
    Queue - Хорошо для списка заданий и обработки запросов.
    Stack - полезно в рекурсивных алгоритмах
    
Comparable vs Comparator
    Integer, Double и String реализуют интерфейс Comparable
    Comparable помогает сохранять естественную сортировку
    Comparator позволяет сортировать элементы по разным особым шаблонам
    Comparator обычно передается конструктору коллекции
    Comparable может быть реализован именно элементами коллекции или ключами Map, а Comparator реализуется отдельным объектом
        (чтобы поменять порядок сортировки через Comparator не меняя реализацию Comparable самих объектов)
        
Почему коллекции не наследуют интерфейсы Cloneable и Serializable?
    1. Ну, простейший ответ — «потому что не надо»
    2. не всегда нужен подкласс Cloneable потому что каждая операция клонирования потребляет очень много памяти
    3. Если вам нужно клонирование и сериализация — просто воспользуйтесь теми классами где она есть, если нет — остальными классами.

Размер по умолчанию (У всех Hash... default load factor == 0.75f ):
    ArrayList-10 - увеличивается на половину, если не хватает места
    Vector-10 - увеличивается в 2 раза, если не хватает места
    HashSet-16
    HashMap-16
    HashTable-11
    HashSet-16
    LinkedList-0
    
    Threshold = (Current Capacity) * (Load Factor)  ( Threshold = 16 * 0.75 = 12 )
    
    
equals() and hashCode не обязательно реализовывать для TreeSet and TreeMap,
они используют compareTo, но иметь их это хорошая практика.
################################################# исключения (exceptions)

Throwable extends Serializable

Errors - не следует обрабатывать в самом коде (напр. закончилась память)
    это: все ошибки с JVM и ThreadDead, StackOverflow. UnknownError etc

Можно/нужно ли обрабатывать ошибки jvm?
    Обрабатывать можно, но делать этого не стоит.
    Разработчику не предоставлены инструменты для обработки ошибок системы и виртуальной машины.
    
Наличие\обработка Checked исключения проверяются на этапе компиляции.
Наличие\обработка Unchecked исключения происходит на этапе выполнения. (напр. RuntimeException)

RuntimeException - могут быть выброшены во время обычной работы JVM в отличии от Error (для проблем с JVM)
    т.е. это то, что может случиться во время работы JVM, напр. IndexOutOfBound, NoSuchElement, ClassCast, Arithmetic, IllegalArgument, NullPointer
    
Exception это: NoSuchField, ReflectionOperation, IllegalAccess, ClassNotFound, NoSuchMethod, FileNotFound

main() может выбросить исключение и оно будет обработано в JVM

return; из finally затрет return из catch()

исключение пере-выброшенное из finally затрет аналогичное пере-выброшенное из try{}
НО если ДО finally стоит catch(), то он может перехватить исключение из try{} ДО выполнения finally и обработать его.
    try { throw new NullPointerException(); }
    catch (NullPointerException ex) { } // обработаем
    finally { throw new MyPointerException(); }

OutOfMemoryError
    1. java.lang.OutOfMemoryError: Java heap space - Обычно проблема кроется в утечке памяти. Размер задается параметрами -Xms и -Xmx
    2. java.lang.OutOfMemoryError: PermGen space - в Permanent области, размер которой задается параметрами -XX:PermSize и -XX:MaxPermSize
    3. java.lang.OutOfMemoryError: GC overhead limit exceeded - как при переполнении первой, так и второй областей.
            Связана она с тем, что памяти осталось мало и GC постоянно работает, пытаясь высвободить немного места.
            Данную ошибку можно отключить с помощью параметра -XX:-UseGCOverheadLimit, но, конечно же, её надо не отключать,
                а либо решать проблему утечки памяти, либо выделять больше объема, либо менять настройки GC.
    4. java.lang.OutOfMemoryError: unable to create new native thread - Выбрасывается, когда нет возможности создать еще потоки.
    
SQLException - обрабатываемое, но есть мнение что лучше бы оно было необрабатываемым.

FileNotFoundException extends IOException

----------
из java.lang
--интерфейс Thread.UncaughtExceptionHandler - реализуется в классах, в которых нужно обработать необрабатываемые исключения (реализован в ThreadGroup)

void uncaughtException(Thread поток, Throwable исключение)
	- единственный метод
	поток - вызвавший ошибку
	исключение - ссылка на исключение
	
// t is the parent code thread
t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {

    public void uncaughtException(Thread t, Throwable e) {
       LOGGER.error(t + " throws exception: " + e);
    }
 });

################################################# ООП

Сигнатура метода в Java — это имя метода плюс параметры (причем порядок параметров имеет значение).

перегруженными -  с одинаковыми именами, но разными сигнатурами

Могут ли нестатические методы перегрузить статические? Да. (т.к. к static можно получить доступ через this???)

Изменить тип возвращаемого значения при переопределении метода нельзя, будет ошибка.
Но можно сузить возвращаемое значение, если они совместимы. (сузить - вернуть наследника вместо базового)

Восходящее. Преобразование от потомка к предку называется восходящим, от предка к потомку — нисходящим.
    (простое присваивание к ссылке базового типа)
Нисходящее преобразование должно указываться явно с помощью указания нового типа в скобках.
    (приведение)
    
Виды блоков инициализации
    нестатический (instance initializer)
    статический (class initializer)

Блок инициализации выполняется так же, как если бы он был расположен в верхней части тела любого конструктора.
Если блоков инициализации несколько, они выполняются в порядке следования в тексте класса.
Так же возможно создать такой блок в анонимном классе.
(!!!) Блок инициализации способен генерировать исключения, если их объявления перечислены в предложениях throws всех конструкторов класса.

Сначала вызываются все статические блоки от первого предка до последнего наследника.
Потом попарно вызываются динамический блок инициализации и конструктор в той же последовательности (от предка до последнего потомка).

Если в классе есть хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.

Что будет, если в static блоке кода возникнет исключительная ситуация?
    Если в явном виде написать любое исключение в static-блоке, то компилятор не скомпилирует исходники.
    Если unchecked исключение вывалится в static-блоке, то класс не будет инициализирован.
    
 Какое исключение выбрасывается при ошибке в блоке инициализации? (init тут видимо имеется ввиду не-статик блок)
    Для static: java.lang.ExceptionInInitializerError - если исключение наследуется от RuntimeException
    Для init:   exception, который и вызвал исключение - если он наследуется от RuntimeException.
    Верно для static и init:
        java.lang.Error — если исключение вызвано Error. 
        java.lang.ThreadDeath — смерть потока. Ничего не вываливается.
        
особенности инициализации final static переменных:
    Переменные должны быть инициализированы во время объявления или в static блоке.

Ключевое слово interface используется для создания полностью абстрактных классов. 
Интерфейс может содержать поля, но они автоматически являются статическими (static) и неизменными (final).
final методов у интерфейса БЫТЬ НЕ МОЖЕТ! (они abstract)

Анонимный класс:
Анонимный класс не имеет доступ к локальным переменным области,
    в которой он определен, если они не финальные (final) или неизменяемые (effectively final).
Вы не можете определять статические члены анонимного класса.
Конструктора в анонимном классе быть не может.

Типы классов в java:
    Top level classes
    Interfaces (не могут быть локальными, т.к. Не могут быть объявлены как private/public/protected или static)
    Enum
    Static nested classes
    Member inner classes
    Local inner classes
    Anonymous inner classes

При созданиие hashCode он:
    Хэш код должен быть равномерно распределен на области возможных принимаемых значений.
    (видимо имеется ввиду опредять его для часто меняющихся у ВСЕХ объектов переменных)
    
Если у объекта, который используется в качестве ключа в hashMap изменится поле, которое участвует в определении hashCode?
    Будут. При обращении по ключу мы можем не найти значение.
    
абстрактный класс и интерфейса:
    Интерфейсы могут быть реализованы классами которые не связаны друг с другом.
    С абстрактными классами вы теряете индивидуальность класса, наследующего его; 
    С интерфейсами вы просто расширяете функциональность каждого класса.

Можно ли получить доступ к private переменным класса и если да, то каким образом?
    Field reflectField = SomeClass.class.getDeclaredField("name");
    reflectField.setAccessible(true); // Если не дать доступ, то будет ошибка
    String fieldValue = (String) reflectField.get(someClass);
    // try{}catch(NoSuchFieldException | IllegalAccessException){}
    
Для volatile переменной JVM гарантирует синхронизацию для операций чтения/записи,
    но не гарантирует для операций изменения значения переменной????

58. Имеет ли смысл объявлять метод private final?
    Нет, такой метод и так не виден для наследников, а значит не может быть ими переопределен.
    
Не static final поле можно инициализировать И В static блоке И В динамическом???

К конструктору не применимо ключевое слово final.

Да, можно отменить сборку объекта с помощью метода finalize(), присвоив его ссылку какому-то статическому методу.
НО повторного вызова finalize не будет, потому что по контракту он вызывается только ОДИН РАЗ???

62. Почему метод clone объявлен как protected? Что необходимо для реализации клонирования?
    Это указывает на то, что хоть метод и есть в классе Object и разработчик желает им воспользоваться,
    то его нужно переопределить. Для этого нужно реализовать интерфейс Clonable, чтобы соблюсти контракт.

################################################# потоки ввода/вывода

java.io и java.nio, в java.util работа с архивами

InputStream представляет классы, которые получают данные из различных источников:
    массив байтов, строка (String), файл, канал (pipe),
    последовательность различных потоков, которые можно объединить в одном потоке,
    другие источники (например, подключение к интернету)
    
OutputStream - тоже самое, только вывод (но не в String, предполагается что вы сможете создать их из массива байтов)

RandomAccessFile - напоминает использование совмещенных в одном классе потоков DataInputStream и DataOutputStream (они реализуют те же интерфейсы DataInput и DataOutput)
    имеет методы seek() - позволяет переместиться к определенной позиции и изменить хранящееся там значение
    содержит методы для чтения и записи примитивов и строк UTF-8.
    
5. Какие есть режимы доступа к файлу?
     RandomAccessFile может открываться: чтения («r») или чтения/записи («rw»), «rws» (сразу запись изменений без flush)
     
классах-надстройках - BufferedOutputStream, BufferedInputStream, BufferedWriter

8. Какой класс-надстройка позволяет читать данные из входного байтового потока в формате примитивных типов данных?
    DataInputStream - Для чтения байтовых данных
        readByte() - для чтения байтов, не читает EOF байт (не различает)
        available() - сколько байт осталось до конца (т.к. через readByte() это не узнать)
        Конструктор: DataInputStream(InputStream stream)
        Методы: readDouble(), readBoolean(), readInt()
    ByteArrayInputStream - подходящий для передачи в DataInputStream (String можно преобразовать через getBytes() )
    
OutputStreamWriter — мост между классом OutputStream и классом Writer. (outputStreamWriter.write("Hello World"); )
InputStreamReader — аналог для чтения. ( int data = inputStreamReader.read() while(data != -1){  data = inputStreamReader.read(); } )


java.io.File:
     list()
     File.listFiles() возвращает массив объектов File
     File.separator - различных систем символ разделителя различается
        прим. можно безопасно использовать слэш ‘/’ для всех систем!!!
    
FilenameFilter:
FilenameFilter с методом accept() работает как фильтр списка файлов:
    String[] myFiles = directory.list(new FilenameFilter() {
    public boolean accept(File directory, String fileName) {
        return fileName.endsWith(".txt");
    }

Свои реализации сериализации:
    ExternalizablewriteExternal и readExteranl
    реализации интерфейса ObjectInputValidation и переопределения метода validateObject() и выбросим в нем InvalidObjectException

17. Какие классы позволяют архивировать объекты?
    DeflaterOutputStream, InflaterInputStream, ZipInputStream, ZipOutputStream,  GZIPInputStream, GZIPOutputStream.
    
Еще один пример чтения:
    FileInputStream fis= new FileInputStream("bla");
    byte[] buf = new byte[1024];
    int len;
    while((len=fis.read(buf))>0){
        zos.write(buf, 0, len);
    }

################################################# многопоточность

Процесс — это совокупность кода и данных, разделяющих общее виртуальное адресное пространство. Процессы изолированы друг от друга.

Один поток («нить» или «трэд») – это одна единица исполнения кода.
    Каждый поток последовательно выполняет инструкции процесса, которому он принадлежит, параллельно с другими потоками этого процесса.
    
Синхронизация — это процесс, который позволяет выполнять все параллельные потоки в программе синхронно.

Аналогом такого метода main, для дочерних нитей служит метод run интерфейса Runnable.

Еще один способ создания потока (не Runnable или Thread):
    1. Создать объект класса, реализующего интерфейс Callable с методом call(){} (аналог run(){} )
    2. Создать объект ExecutorService с указанием пула потоков.
    3. Создать объект Future. Запуск происходит через метод submit(); Сигнатура: <T> Future<T> submit(Callable<T> task)
    
    Пример:
        ExecutorService pool = Executors.newFixedThreadPool(3);
        Callable<Integer> callable = new Callable() { call() { return "OK"; } };
        Future<Integer> future = pool.submit(callable);
        String result = future.get();
        
Поток закончит выполнение, когда завершится его метод run() или call(). Для главного потока это метод main().


13. Как принудительно остановить поток?
    В Java 8 нет метода, который бы принудительно останавливал поток.
    Класс Thread содержит в себе скрытое булево поле, которое называется флагом прерывания. Установить этот флаг можно вызвав метод interrupt() потока.
    Проверяем флаг прерывания:
        interrupt() - ставит флаг прерывания в true???
        bool isInterrupted() - проверяем флаг прерывания
        Thread.interrupted() - проверяем флаг прерывания и СБРАСЫВАЕМ ЕГО
        
У методов, приостанавливающих выполнение потока, таких как sleep(), wait() и join()
есть одна особенность — если во время их выполнения будет вызван метод interrupt() этого потока,
они, не дожидаясь конца времени ожидания, сгенерируют исключение InterruptedException.

Даже если метод main() уже завершился, но еще выполняются порожденные им потоки, система будет ждать их завершения.

Если завершился последний обычный поток процесса, и остались только потоки-демоны,
то они будут принудительно завершены и выполнение процесса закончится.

sleep() может выполняться либо заданное кол-во времени (миллисекунды или наносекунды)
либо до тех пор пока он не будет остановлен ПРЕРЫВАНИЕМ
    (в этом случае он сгенерирует исключение InterruptedException).

То что в synchronized(...) наз. монитором вместо ...

Deadlock - явление при котором все потоки находятся в режиме ожидания

Race conditions - когда 2+ потока работают неправильно параллельно с одними данными
    (затирают, читают не в том порядке и пр.)

29. В каком случае будет выброшено исключение InterruptedException, какие методы могут его выбросить?
    Методы, требующие обработку этого исключения: wait, sleep, join.
    Исключение будет выброшено, если флаг interrupt у потока true.
    
Пример где нужен yield:
    while(!msgQueue.hasMessages())		//Пока в очереди нет сообщений
    {
        Thread.yield();		//Передать управление другим потокам
    }
    
33. Можно ли создавать новые экземпляры класса, пока выполняется static synchronized метод?
    Да.
    
34. Предположим в методе run возник RuntimeException, который не был пойман.
        Если в дочернем потоке упадет Exception, то метод run() аварийно завершится и исключение будет передано в главный поток.
            Далее в консоль будет выведен стектрейс, приведенный ниже.
        Если исключение не обрабатывать, то нить (вызванная в методе run()) просто аварийно завершится.
            Восстановить работу нити после такого сценария нельзя, можно только создать нить заново.
            
            
35. Какие стандартные инструменты Java вы бы использовали для реализации пула потоков?
        Коротко:
            можно использовать LinkedList queue и private final Thread[] pool;
            при execute(Runnable r) добавлять в pool
            
ThreadGroup
    Группа нитей образует дерево, в котором каждая другая группа нитей имеет родителя (кроме исходной).
    Поток имеет право доступа к данным из своей группы нитей,
        но не имеет такого доступа к другим группам или к родительской группе потоков.
        
ThreadPoolExecutor - реализация ExecutorService. Он выполняет переданную задачу (Callable или Runnable)
    Пул потоков содержит в себе ThreadPoolExecutor, который может содержать изменяющееся число нитей.
    Число нитей в пуле задается с помощью corePoolSize и maximumPoolSize.
        
39.Что такое «атомарные типы» в Java?
    Имеют операцию compare-and-set, быстрая.
    
    compareAndSet() - механизм оптимистичной блокировки и позволяет изменить значение value,
        только если оно равно ожидаемому значению (т.е. current).

    В пакет java.util.concurrent.atomic входят 9 видов атомарных переменных (AtomicInteger;
        AtomicLong; AtomicReference; AtomicBoolean;
        формы для массивов атомарных целых чисел;
        длинные (long);
        ссылки;
        а также атомарные с пометкой Класс эталона (reference), которые атомарно обновляют две величины).
    
С модификатором volatile, то гарантируется выполнение отношения happens-before,
    что ведет к тому, что измененное значение этой переменной увидят все потоки.
    
41.Что такое Executor?
    Интерфейс предоставляет возможность избежать вникания в механику выполнения задачи:
        executor.execute(new RunnableTask1()); // == Thread(new(RunnableTask())).start():
        
42.Что такое ExecutorService?
    ExecutorService исполняет асинхронный код в одном или нескольких потоках.
    Создание инстанса ExecutorService’а делается
        либо вручную через конкретные имплементации (ScheduledThreadPoolExecutor или ThreadPoolExecutor),
        но проще будет использовать фабрики класса Executors:
            service.submit(new Runnable() {}); // 

Про .submit():
    1. Вызов метода get на объекте Future возвратит значение,
        который возвращает Callable (ИЛИ null, если используется Runnable)
    2. Метод имеет 2 checked-исключения: InterruptedException, который бросается,
        когда выполнение прервано через метод interrupt(), или ExecutionException
        если код в Runnable или Callable бросил RuntimeException,
        что решает проблему поддержки исключений между потоками.

43.Зачем нужен ScheduledExecutorService?
    Иногда требуется выполнение кода асихронно и периодически или требуется выполнить код через некоторое время.
    Он позволяет поставить код выполняться в одном или нескольких потоках и сконфигурировать интервал или время, на которое выполненение будет отложено.
    
    Пример:
        Executors.newSingleThreadScheduledExecutor().schedule(new Runnable() { ... }, 5, TimeUnit.SECONDS);

#################################################
Byte, Short, Integer, and Long - immutable

#################################################

В классе Integer есть private static class IntegerCache,
это pool кэширующий значения -128..127 (т.е. 256 значений), большие переменные не кэшируются.

Весь этот пул представляет собой массив,
каждое значение которого является элементом расположенным
в порядке числового возрастания и мы можем напрямую
обратиться к нему по индексу за константное время O(1).

Существуют пуллы: String, Byte, Short, Character, Integer, Long и Boolean
ПРИЧЕМ все они имеют кэш (пул): -128..127

Для ПРИМИТИВНЫХ типов пуллов НЕ СУЩЕСТВУЕТ, потому что нельзя создать ссылку на них.

Integer.valueOf(int) в отличии от new Integer() вернет объект из пула, если он там есть.
(касается не только Integer)

Этот пулл (кэш) реализация паттерна Flyweight (Приспособленец).

Можно установить границы кэша для Integer вручную:
-XX:AutoBoxCacheMax=NEWVALUE or -Djava.lang.Integer.IntegerCache.high=NEWVALUE

Требования к пулу описаны в  JLS (Java Language Specification).

Пример:
Integer a = 1;
Integer b = 1;
Integer c = 999;
Integer d = 999;
System.out.println(a == b); // true
System.out.println(c == d); // false

Пример 2:
"hel" + "lo"
    преобразуется в (причем сложение строк внутри будет через StringBuilder)
new String("hello").intern()

Если строки в поле нет, то intern() поместит строку в пул и вернет ссылку.

Минусы:
    создание строки занимает больше времени,
    можно забить пул и тогда начнутся лаги, т.к. кэш системный и имеет ограничения.

#################################################
Если мы говорим о локальных final переменных, то они хранятся в стековой памяти.
Если мы имеем дело со static final полями, то эти поля хранятся в MetaSpace (раньше в PermGen),
если мы говорим о реализации JVM HotSpot.

#################################################
Пулл констант - еще один пулл (это не пулл типов )

В каждом .class-файле есть структура данных, которая называется пулом констант.

Пример:
    Чтобы передать в метод println строку "Hello", надо загрузить в стек ссылку на строку "Hello",
    а саму строку где-то сохранить. Вот это где-то как раз и есть пул констант.

Если говорить о расположении пула констант в памяти JVM, то это один из участков MetaSpace.
У каждого класса свой пул констант.

Что такое константы (не про final поля! не точно!):
    имена переменных, методов, классов и интерфейсов, строковые литералы

Что такое НЕ константы:
    Адреса объектов постоянно меняются. Объекты постоянно перемещаются, с каждой сборкой мусора.
    Они НЕ константы.
    
Чтобы посмотреть подробности можно использовать команду: javap -v MyClass.class

Подробнее: https://ru.stackoverflow.com/a/846541

#################################################
Методы byteValue(), shortValue(), intValue(), longValue(), floatValue(), doubleValue()

Метод xxxValue() — преобразует в Java числовое значение объекта,
который вызывает метод, в примитивный тип данных, который возвращается из метода.

d1.equals(d2) эквивалент d1.doubleValue() == d2.doubleValue()

Integer i1 = 10; 
i11.doubleValue(); // 10.0

#################################################
Integer i1 = 10; 
Integer i2 = 10; 
            
Double d1 = 10d; 
Double d2 = 10d; 
    
System.out.println(i1 == i2); // true
System.out.println(d1 == d2); // false

#################################################
Как работает intern():
https://ru.stackoverflow.com/a/715054
    (обязательно глянуть ролик)

Если коротко:
    Это сжатие класса до 1го "канонического" объекта.
    НИКОГДА не делать intern() самому, т.к. все хранится в Hashtable (или HashMap)
    и это называется пул строк. Эта переменная оставлена для системы, туда лучше не лезть (из видеолекции).
    Эта HashMap называется еще StringTable???
    Этот системный пулл, как и все HashMap в Java ограничен 60k бакетами и можно его забить так что будет тормозить.
    Если нужно сделать intern(), то лучше определить свой класс-кэш с HashMap или CuncurentHashMap и методом putIfAbsent()
    и это быдет быстрее.
    

Строка может попасть в пул констант в двух случаях:
    1. На этапе компиляции. 
    2. Вызов String.intern()
    
Про intern:
    1. Из intern пула НЕ возможно удалить данные
    2. intern медленнее чем реализация (через ConcurrentHashMap, например) интернирования. Потому что во внутренней таблице (в которой хранятся интерниованные строки) всего около 60 000 бакетов и большОе количество строк может забить эти бакеты. Покачто эта Map не ресайзится.
    3. intern может влиять на работу всей JVM так как таблица используется для хранения информации о классах
    (прим. Заполнить его до состояния "тормозов" это минимум от 100к уникальных стрингов.)
    
Понятия:
    дедубликация - когда вместо intern() и хранения переменной как 1го объекта создаем свой класс-кэш
                    в этом классе мы храним "похожести"
    интернирование - intern(), обратное, если объект такой же помещаем делаем общую ссылку на него из многих мест
    
Вероятностный дедубликатор - тоже что и дедубликация, но перед get/put выполняем проверку вероятности (случайного числа),
                                меняя вероятность можно подстроить баланс память/время
#################################################
Из static блока исключения нельзя выбрасывать, но можно их перехватить до попытки выброса и сделать re-throw unchecked исключения (throw new RuntimeException(){}), чтобы Thread упал.
Из dynamic блока ВИДИМО можно выбрасывать как обычно, если они перечислены в throws конструктора.

Выбрасывать исключения из конструктора - нормально.

#################################################
Создание immutable объекта:
1. не делать сетеры
2. Все поля private final
3. Методы final (чтобы не дать override)
4. Все изменения mutable полей возвращают НОВЫЙ объект. immutable поля возвращать как обычно.

Дополнительно: можно сделать private constructor и создавать в factory methods

#################################################
Порядок инициализации таков:
    Статические элементы родителя
    Статические элементы наследника
    Глобальные переменные родителя
    Конструктор родителя
    Глобальные переменные наследника
    Конструктор наследника

#################################################
Динамический прокси

Как работает:
    Принимает класс-лоадер и массив интерфейсов (interfaces),
    а возвращает объект класса java.lang.Class,
    который загружен с помощью переданного класс-лоадера и реализует переданный массив интерфейсов. 

java.lang.reflect.Proxy
handler и сам класс прокси разделены (принцип единственности ответственности).
    Почему:
        Прокси-класс генерируется во время выполнения, но вызванные
        им обработчики могут быть добавлены в обычный исходный код и скомпилированы с остальной программой.
        
Из неочевидных целей использования: реализацию отложенной инициализации затратных ресурсов;
        
Как я понял:
    создается прокси для интерфесов класса,
    при этом можно не создавать сам объект класса, создастся автоматически.
    НО! Если интерфесов нет, то нужно выбрать другую реализацию прокси.

// обработчик, содержит public Object invoke(Object proxy, Method method, Object[] args)
InvocationHandler handler = new MyInvocationHandler(...);

Class proxyClass = Proxy.getProxyClass(
    Foo.class.getClassLoader(), new Class[] { Foo.class }); // прокси
Foo f = (Foo) proxyClass.
    getConstructor(new Class[] { InvocationHandler.class }).
    newInstance(new Object[] { handler });                 // реализация через конструктор через рефлексию
    
#################################################
Важная инфа для собеседования (про бакеты и реализацию):
https://ru.stackoverflow.com/questions/619860/

Хэш код - это int
index = hashcode % table_size

bucket - это список (массив) в котором index это hashcode.
С технической точки зрения «корзины» — это элементы массива, которые хранят ссылки на списки элементов.
Добавление, поиск и удаление элементов выполняется за константное время.

equals и hashCode обязателен для: HashMap, HashSet и Hashtable

1. В JDK 7 и ниже, для хранения пар в одной корзине используется linked list;
2. В JDK 8 для этой цели используется balanced tree, следовательно, в худшем случае, значение по ключу может быть получено уже за O(log n).

В Map:
    // 
    static class Entry implements Map.Entry
    {
    final K key;
    V value;
    Entry next;
    final int hash;
    ...//Еще много кода тут
    }

    // видимо это bucket
    transient Entry[] table;
    transient Node<K,V>[] table;

HashSet работает как HashMap:
Внутри HashSet используется private transient HashMap<E,Object> map;
В качестве ключа здесь используется переданный в метод add(...) объект,
а в качестве значения – объект заглушка класса Object.

У ArrayList переменные:
elementData.length - размер с буфером
size - реальный размер

List с вставкой в позицию: list.add(list.size()/2, newElem)

В HashMap можно использовать неправильный hashCode (с одинаковым значением), но тогда получится аналог List (сравнение по equals).
#################################################
happens before (отношения строгого порядка)

Каждый CPU хранит кэш, потоки в Java используют кэш CPU (на уровне железа). valotile говорит не использовать кэш.
Причем кэш CPU общий для всех потоков. ПОЭТОМУ если в Thread хотя бы ОДНА переменная valotile,
    то кэш выключится для ВСЕХ СОСЕДНИХ (других полей класса) переменных даже если они НЕ valotile.
    (ПРИМ. проверить ГАРАНТИРОВАННО ли соседние с valotile переменные тоже становятся valotile из-за общего кэша!!!)
    
Конструкции вызывающие happens before: final, volatile, or synchronized,
    Дополнительно: static initializers, и новые Thread могут видеть текущее состояние памяти родителя без synchronization
    (для всего остального порядок выполнения не гарантирован)

Выделяют
    synchronized Order - тоже игнорирует кэш CPU для потоков при входе в блок и записывает данные при выходе из блока.
    happens before Order - команды CPU которые говорят операциям не менять порядок операций местами даже если это выгодно.
        т.е. все операции ДО операции с valotile переменной будут в строгом порядке!
        
synchronized vs happens before (valotile) - это разные вещи, НЕ взаимозаменяемые.
    synchronized - может выполнять только ОДИН поток
        и внутри synchronized блока операции внутри JVM могут поменяться местами (в отличии от happens before которая все выполняет по порядку)
        НУЖНО ЗНАТЬ (общая инфа ???): в synchronized напрямую читает и пишет в кэш, другой поток не может загрузить свой context в тот же кэш (не будет переключения контекста).

Кроме того happens before автоматически действует для:
    Синхронизация и мониторы:
        1. Захват монитора (начало synchronized, метод lock) и всё, что после него в том же потоке.
        2. Возврат монитора (конец synchronized, метод unlock) и всё, что перед ним в том же потоке. 
        3. Возврат монитора и последующий захват другим потоком.
    Запись и чтение:
        1. запись в любую переменную и последующее чтение её же
        2. Всё, что в том же потоке перед записью в volatile-переменную, и сама запись.
        3. volatile-чтение и всё, что после него в том же потоке.
        4. Запись в volatile-переменную и последующее считывание её же. (аналогия: volatile запись как возврат монитора, а чтение как захват)
            (Для объектных переменных (например, volatile List x;) столь сильные гарантии выполняются для ссылки на объект, но не для его содержимого. ПРОВЕРИТЬ!)
    Обслуживание объекта: 
        1. static инициализации (блок и переменная)
        2. инициализация final в конструкторе
        3. Любая работа с объектом и finalize()
    Обслуживание потока: 
        4. Запуск потока и любой код в потоке.
        5. Зануление переменных, относящихся к потоку, и любой код в потоке.
        6. Код в потоке и join(); код в потоке и isAlive() == false.
        7. interrupt() потока и обнаружение факта останова.
#################################################
Double checked locking (Блокировка с двойной проверкой)

Сначала проверяется условие блокировки без какой-либо синхронизации;
поток делает попытку получить блокировку, только если результат проверки говорит о том, что получение блокировки необходимо.

Из-за того, что потоки могут для оптимизаций менять местами строки кода при выполнении,
    Double checked locking может НЕ СРАБОТАТЬ. Эта проблема привела к появлению happens before (volatile) в Java Memory Model
    
Часто ИСПОЛЬЗУЕТСЯ при реализации lazy инициализаций, например lazy Singleton переменная всегда volatile (в т.ч. ссылка как Я понял???).
#################################################
Cohesion и Coupling

Cohesion - (single responsibility), low Cohesion когда класс должен брать на себя как можно меньше ответственности
    (реализовывать как можно меньше функций, больше функций выносить в другие классы)

Coupling - (low coupling == хорошая инкапсуляция), классы должны как можно меньше знать друг и друге
    (т.е. должны видеть меньше public переменных друг друга)

#################################################
Рекомендуется официальная документация с описанием какая структура на чем основана
	https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html

-----------------------------------------------------------------------------------------------------
Interface	Hash Table	Resizable Array		Balanced Tree	Linked List		Hash Table + Linked List
-----------------------------------------------------------------------------------------------------
Set			HashSet	 						TreeSet	 						LinkedHashSet
List	 				ArrayList	 						LinkedList	 
Deque	 				ArrayDeque	 						LinkedList	 
Map			HashMap	 						TreeMap	 						LinkedHashMap
-----------------------------------------------------------------------------------------------------

Тут полная табл
    https://stackoverflow.com/a/559862
    http://bigocheatsheet.com/

ArrayList
    get, set                                O(1)
    add, remove                             O(n)
    contains, indexOf                       O(n)
LinkedList
    get, set, add, remove (с любого конца)  O(1)    - просто вызов add
    get, set, add, remove (по индексу)      O(n)    - в конкретное место
    contains, indexOf                       O(n)
ArrayDeque
    offer, peek, poll, size                 O(1)
PriorityQueue
    peek                                    O(1)
    add, remove                             O(log n)
HashSet
    add, remove, contains                   O(1)
HashMap
    get, put, remove, containsKey           O(1)
TreeSet
    add, remove, contains                   O(log n)
TreeMap
    remove, get, put, containsKey           O(log n)
LinkedHashSet
    add, remove, contains                   O(1)

CopyOnWriteArrayList
    get()                                   O(1)
    add, remove, contains                   O(n) 
#################################################
Cglib - популярная библиотека для работы с байткодом на этапе компиляции, используется также в фреймворках
#################################################
x instanceof SomeClass is false if x is null
#################################################
throw как goto, вариант использования

public void doSomething() {
    try {
        // bunch of code
        throw new MyException();
        // second bunch of code
    } catch (MyException e) {
        // third bunch of code
    }       
}
#################################################
делать return из finally плохо т.к. может получиться двойной перевыброс,
т.к. тоже значение может быть выброшено из try (обычным способом).

public int getPlayerScore(String playerFile) {
    int score = 0;
    try {
        throw new IOException();
    } finally {
        return score; // <== the IOException is dropped
    }
}
#################################################
public class A {
    public static void f1(long i) {} // вызовется с примитивом, хотя вызов с оболочкой (note: неправла, но чтобы запомнить: jvm "экономит" память вызывая с меньшим типом)
    public static void f1(Long i) {}
    public static void main(String args[]) { f1(new Integer(1)); }
}
#################################################
equals по спецификации должно быть: https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-
reflexive
symmetric
transitive
consistent

