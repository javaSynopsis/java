Note. В процессе редактирования.

# Common
Современное приложение на Java.

# Microserves application
1. Разработка
   1. Eureka
   2. Zuul
   3. Kafka & zookeeper
   4. Fein
   5. Lombok
   6. Hibernate ORM
   7. Hibernate Valitator
   8. Postgres
   9. zipkin - система распределенной трасировки, которая показывает логи выполнения методов и их время, в том числе в UI; чтобы логи видеть службы (код) нужно анатировать чтобы включить их анализ https://www.baeldung.com/tracing-services-with-zipkin
   10. swagger
   11. orika - для маппинга в dto https://www.baeldung.com/orika-mapping
   12. Kubernatis - для оркестровки образами в продакшене
   13. Docker и kitematic - для удобного разварачивания образов на десктопе
   14. docker compose - формирует набор docker образов связанных друг с другом (общающихся) и запускающихся в определенном порядке (прим. при запуске в kitematic нужно определить порядок запуска)
   15. Elastic
   16. kibana - показ логов и анализа данных в том числе в виде графики
   17. nginx - стоит до Zuul для балансирования нагрузки
   18.  Elasticsearch, Logstash и Kibana (ELK) - стэк для сбора и визуализации логов
   19.  IBM MQ - использован не факт
   20.  Prometheus - 
   21.  quartz
2. IDE
   1. Idea
   2. Copirights поле с описанием прав на созданные файлы в комментах
   3. настраиваем file headers - авторство кода добавляемое к файлу
   4. плагины
      1. checkstyle - указываем файл правил
      2. gerrit - указываем сервис gerrit с указанием дополнительных прав доступа
      3. sonarlint - указываем сервер правил sonarqube
   5. Настраиваем правила imports, причем imports спец. либ проекта стоят вторыми по счету после import static
3. Структура микросервиса
   1. каждый микросервис запускается в docker
   2. в модуле есть под-модули maven: api, db, impl, lib; в каждом из них есть свой каталог src/main и resources и target куда все собирается. каждый из этих модулей может использоваться в других микросервисах и поэтому выделены в отдельные под-модули
   3. api под-модуль содержит feign и его dto чтобы если dto или api с такой же сигнатурой используется в другом микросервисе (например вызов другим микросервисом этого же по тому же api) можно было просто подключить этот модуль.
   4. db содержит скрипты liquibase; тут же в resources каталоге могут быть другие (например cvs) файлы которые используются в sql
   5. impl содержит все остальное, сервисы, entities, configurations, utils; сюда же вынесен каталог resources; при этом в impl также содержится например реализация интерфейсов RestController из api подмодуля проекта (т.е. в api интерфейсы с RequestMapping, а в impl их реализация помеченная RestController)
   6. mymicroservice-lib-blabla используется как просто библиотека которая может быть нужна для других микросервисов 
   7. для работы микросервиса под нагрузкой используется стратегия семофор для feign которая обрабатывает запросы в одном потоке (note. как реверс проекси)
   8. для security у каждого сервиса есть пользователь (свой логин/пароль), это называется технический пользователь. Роли каждого микросервиса определяют к каким end points других микросервисов этот микросервис имеет доступ.
   9. Вместо Eureka + Zuul можно использовать инструменты kubernetes для discovery client и ribbon, например https://dzone.com/articles/quick-guide-to-microservices-with-kubernetes-sprin и https://github.com/spring-cloud/spring-cloud-kubernetes
   10. в проекте находится каталог log куда складываются логи
   11. в корне есть каталог helm с настройками для kubernetes
   12. в корне есть каталог environments с настройками для kubernetes (secrets например) и др.
   13. Репликация данных как вариант делается вручную через очереди kafka, т.е. если например сервис возвращает User (dto) с каким-то полем зависящим от поля Admin сущности другого сервиса, то 1ый сервис через kafka просит у 2го сервиса значение нужного поля Admin, а потом использует его в выражении вычисляющем значение своего поля User.
   14. В проекте перед первым deploy микросервиса нужно накатывать sql скрипты вручную, чтобы создать схему на которую потом liquibase накатит данные
   15. Микросервисы логически делятся на бизнес микросервисы с чисто бизнес логикой и остальные
   16. Какталог resource в api модуле играет роль controller из MVC
   17. resource - так называется пакет с контроллерами (которые тут называются resource и оканчиваются на `Resource`) и с Feign (классы оканчивающиеся на `...ResourceFeignClient` например `EmployeeResourceFeignClient`)
   18. На самом деле есть одна база прокся база patron. За которой есть кластер баз. Все сервисы видят 1 базу.
   19. В микросервисе есть под модуль parent он родительский для ЧАСТИ других под модулей т.к. основной родительский в корне микросервиса. Этот модуль содержит часть properties, dependencyManagement и правил развертывания.
   20. Сегменты - это полные копии приложения со всеми его микросервисами. Чтобы оттестировать слепки сервисов определенных версий работающих вместе. При этом залогиненный пользователь в одном сегменте должен иметь доступ к другому и данные из одного сегмента должны быть доступны другому (т.е. какое-то взаимодействие с сегментами есть)
   21. структура каталога liquibase разделена на версии (каждый каталог - отдельная версия с корневым xml файлом конфигурации). В основной файл сделан include этих файлов версий
   22. дистрибутивные данные - это данные по умолчанию в DB, которыми наполняется DB при старте сервиса. Они хранятся в cvs файлах, новые версии файла заменяют старые и меняем id записи в конфигах liquibase чтобы "пролить" данные заново в DB. При этом тестовые данные которыми заполняется DB лежат в отдельном файле, при запуске в параметре maven передается путь к файлу который "проливать" в DB (тестовый или тот что для продакшена). Параметры liquibase это properties которые в модуле parent проекта.
   23. Над некоторыми custom exception классами проставлены @ResponseStatus аннотации и эти exceptions наследуют RuntimeException
4. devops
   1. jira + confluens
   2. kanban доска с полями: ready to do, blocked, in progress, waiting, testing, complete
5. Особенности кода проекта
   1. в configure для MVC есть проверка if на `auth=off` и тогда все end-point становятся разрешенными (permit all)
   2. использована библиотека https://github.com/tkaczmarzyk/specification-arg-resolver для декларативной работы со Specification
   3. Константы венесены в enum (строки используемые во многих местах)
   4. Idea ругается на слишком длинную команду запуска, поэтому в настройках запуска нужно изменить тип на classpath file
   5. Проливание данных в DB сделано через плагин для maven для liquibase и доступно в IDE в разделе Plugins в меню сборки проекта через maven (2 раза кликнуть по записи liquibase:update)
6. Основные микросервисы
   1. auth - выдает токены внешним пользователями
   2. auth internal - выдает токены сервисами чтобы они могли логиниться друг в друга
   3. notification
   4. session - управляет сессиями, у сессий есть доп. инфа, может например удалять сессии
   5. ACL - управление ролями
   6. справочники - сервис, который хранит данные (таблицы) и может отдавать их, если проект небольшой, то справочники можно хранить в микросервисе общих справочников, а в дальнейшем разбить его на много мелких справочников